<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Aviation Calculator</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

<!-- PWA -->
<link rel="manifest" href="./manifest.json">

<!-- iOS standalone tweaks (content.html doesn't inherit Next layout metas) -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="Aviation Calculator">

<!-- Icons (use relative paths) -->
<link rel="apple-touch-icon" href="./math_icon_180.png">
<link rel="icon" type="image/png" sizes="16x16" href="./math_icon_16.png">
<link rel="icon" type="image/png" sizes="32x32" href="./math_icon_32.png">
<link rel="icon" type="image/png" sizes="48x48" href="./math_icon_48.png">

<!-- Theme colors for both modes (optional) -->
<meta name="theme-color" content="#f5f5f7" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#0c0c0f" media="(prefers-color-scheme: dark)">

<style>
  /* ===== Theme tokens ===== */
  :root{
    --bg:#f5f5f7; --card:#ffffff; --text:#1c1c1e; --muted:#8e8e93; --accent:#007aff; --ring:rgba(0,122,255,.18);
    --surface:rgba(255,255,255,.7);
    --dur-fast:180ms; --dur-med:220ms; --ease:cubic-bezier(.22,.61,.36,1);
    --danger: #e5484d;  /* red */
  }
  @media (prefers-color-scheme: dark){
    :root{
      --bg:#0c0c0f; --card:#1c1c20; --text:#f2f2f7; --muted:#8e8e93; --ring:rgba(10,132,255,.15);
      --surface:rgba(28,28,32,.9);
    }
  }

  /* ===== Resets / layout ===== */
  *{ box-sizing:border-box }
  html,body{ min-height:100%; height:auto; overflow-x:hidden }
  body{
    margin:0; line-height:1.45; background:var(--bg); color:var(--text);
    font-family:-apple-system,BlinkMacSystemFont,"SF Pro Text","Helvetica Neue",Helvetica,Arial,sans-serif;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
    padding-top:calc(env(safe-area-inset-top) + 0px);
  }
  .app{ max-width:1180px; margin:0 auto; padding:16px}
  h1{ font-size:22px; font-weight:700; letter-spacing:.2px; margin:0 0 8px }
  .subtitle{ color:var(--muted); margin-bottom:18px; font-size:14px }
  .hidden{ display:none }

  /* ===== Tiles ===== */
  .grid{
    display:grid; grid-template-columns:repeat(auto-fill,minmax(220px,1fr)); gap:14px;
    opacity:0; transform:translateY(6px); animation:fadeSlideIn var(--dur-med) var(--ease) forwards;
  }
  .tile,.panel{
    background:var(--card); border-radius:18px;
    box-shadow:0 12px 28px rgba(0,0,0,.08), 0 2px 6px rgba(0,0,0,.05);
    border:1px solid rgba(0,0,0,.04);
  }
  .tile{
    padding:16px; cursor:pointer;
    transition:transform var(--dur-fast) var(--ease), box-shadow var(--dur-fast) var(--ease);
    will-change:transform;
  }
  .tile:hover{ transform:translateY(-2px) }
  .tile:active{ transform:translateY(0) scale(.995) }
  .tile h3{ margin:0 0 6px; font-size:16px }
  .tile p{ margin:0; color:var(--muted); font-size:13px }

  /* ===== Panels (ETP style) ===== */
  .panel{ max-width:1100px; margin:16px auto 0; padding:16px }
  .panel > .backbar, .panel > .toolbar, .panel > .form, .panel > .io,
  .panel > .note, .panel > .footer, .panel > .disclosure{
    max-width:1100px; margin-left:auto; margin-right:auto;
  }
  .backbar{ display:flex; align-items:center; gap:8px; margin:4px 0 8px }
  .backbar h3{ margin:0; font-size:16px; font-weight:600 }
  .toolbar{ display:flex; flex-wrap:wrap; align-items:center; gap:8px; margin-bottom:8px }

  .btn{
    border:0; background:var(--accent); color:#fff; padding:9px 14px; border-radius:12px; font-size:14px; cursor:pointer;
    transition:transform var(--dur-fast) var(--ease), box-shadow var(--dur-fast) var(--ease), background var(--dur-fast) var(--ease);
    will-change:transform;
  }
  .btn:active{ transform:translateY(1px) }
  .btn.secondary{ background:#e5e5ea; color:#111 }
  @media (prefers-color-scheme: dark){ .btn.secondary{ background:#2a2a2f; color:#fff } }
  .btn.ghost{ background:transparent; color:var(--accent); padding:8px 10px }
  .btn.linky{ background:transparent; color:var(--accent); padding:6px 8px; font-size:13px }

  .form{
    display:grid; grid-template-columns:repeat(auto-fit,minmax(180px,1fr));
    gap:12px; margin-top:8px;
  }
  .field{
    display:flex; flex-direction:column; gap:6px;
    background:linear-gradient(180deg, rgba(0,0,0,.02), rgba(0,0,0,0));
    padding:10px; border-radius:14px; border:1px solid rgba(0,0,0,.06);
  }
  @media (prefers-color-scheme: dark){ .field{ border-color:rgba(255,255,255,.06) } }

  label{ font-size:12px; color:var(--muted) }
  input, select{
    border:0; background:transparent; outline:none; font-size:16px; padding:4px 2px; color:var(--text); border-radius:10px;
    transition:box-shadow var(--dur-fast) var(--ease), background var(--dur-fast) var(--ease);
  }
  input:focus, select:focus{ box-shadow:0 0 0 8px var(--ring) }

  .io{ display:grid; grid-template-columns:1fr 1fr; gap:12px; margin-top:12px }
  @media (max-width:820px){ .io{ grid-template-columns:1fr } }

  .box{
    background:linear-gradient(180deg, var(--surface), rgba(255,255,255,.5));
    padding:12px; border-radius:14px; border:1px solid rgba(0,0,0,.06);
    backdrop-filter:saturate(140%) blur(4px);
  }
  @media (prefers-color-scheme: dark){
    .box{ background:linear-gradient(180deg, rgba(28,28,32,.9), rgba(28,28,32,.7)); border-color:rgba(255,255,255,.06) }
  }
  .box h4{ margin:0 0 6px; font-size:13px; color:var(--muted); font-weight:600 }
  .kv{ font-variant-numeric:tabular-nums; font-size:16px }

  .disclosure{
    margin-top:10px; border-radius:14px; border:1px solid rgba(0,0,0,.06); overflow:hidden;
  }
  .disclosure summary{
    list-style:none; cursor:pointer; padding:12px 14px; font-weight:600; color:var(--text);
    background:linear-gradient(180deg, rgba(0,0,0,.03), rgba(0,0,0,0));
    display:flex; align-items:center; justify-content:space-between; gap:8px;
  }
  /* Make Conversions dropdown headers lighter */
#av-conversions .disclosure summary {
    font-weight:500; /* or 400 for normal weight */
}
  .disclosure summary::-webkit-details-marker{ display:none }
  .chev{ transition:transform var(--dur-fast) var(--ease) }
  details[open] .chev{ transform:rotate(90deg) }
  .disclosure .content{ padding:12px 14px; border-top:1px solid rgba(0,0,0,.06); animation:fadeSlideIn var(--dur-med) var(--ease) }

  .note{ margin-top:12px; color:var(--muted); font-size:13px }
  .footer{ margin-top:16px; color:var(--muted); font-size:12px }
  .warn{ color:#b91c1c; font-weight:600 }
  .ok{ color:#065f46; font-weight:600 }
  .right{ text-align:right }
  .two{ display:grid; grid-template-columns:1fr 1fr; gap:8px }
  @media (max-width:820px){ .two{ grid-template-columns:1fr } }
  .note:empty{ display:none }

  /* ===== Perf output (C172) ===== */
  .perf-output{
    background:#f0f2f5; border-radius:14px; padding:14px; margin-top:14px;
  }
  .perf-output h4{ margin:4px 0 10px }
  .perf-output .io{ margin-top:10px }
  .perf-output .box{ display:flex; flex-direction:column; gap:10px }
  .perf-output .kv{ line-height:1.6 }
  @media (prefers-color-scheme: dark){ .perf-output{ background:#2c2c2e } }

  /* ===== Groundspeed helper (scoped) ===== */
  #gsHelper{ background:#f2f2f7; border-radius:14px; padding:0; margin:14px 0; overflow:hidden }
  #gsHelper > summary{
    background:inherit; padding:12px 14px; font-weight:600; font-size:15px; color:var(--text);
    cursor:pointer; border-bottom:1px solid rgba(0,0,0,.06); display:flex; justify-content:center; align-items:center; position:relative;
  }
  #gsHelper > summary .chev{ position:absolute; right:14px; transition:transform .2s ease }
  #gsHelper[open] > summary .chev{ transform:rotate(90deg) }
  #gsHelper > summary::-webkit-details-marker{ display:none }
  #gsHelper .content{ padding:14px }
  #gsHelper .box{
    background:#fff; border:1px solid rgba(0,0,0,.08); border-radius:12px; padding:10px 12px; margin-top:10px;
    box-shadow:0 1px 3px rgba(0,0,0,.08);
  }
  #gsHelper .box h4{
    margin-top:0; font-weight:600; color:#111; border-bottom:1px solid rgba(0,0,0,.06); padding-bottom:4px; margin-bottom:8px;
  }
  /* make fields inside gsHelper look more “cardy” without touching global .field */
  #gsHelper .field{
    background:#fafafa; border:1px solid rgba(0,0,0,.12); border-radius:10px; padding:10px 12px; margin-bottom:12px;
  }
  #gsHelper .field label{ display:block; font-weight:600; color:#222; margin-bottom:6px }
  @media (prefers-color-scheme: dark){
    #gsHelper{ background:#2c2c2e }
    #gsHelper > summary{ color:#f2f2f7; border-bottom:1px solid rgba(255,255,255,.08) }
  }

  /* ===== Lat/Long UI bits (scoped) ===== */
  .gc-seg-row{ display:flex; align-items:center; gap:6px; margin-top:4px }
  .gc-seg{ display:flex; align-items:center; gap:6px }
  .gc-seg .seg{
    height:34px; padding:6px 8px; border:1px solid rgba(0,0,0,.12); border-radius:8px; background:#fff;
    width:60px; text-align:center;
  }
  .gc-seg .seg.dd{ width:64px }
  .gc-seg .sep{ color:var(--muted); user-select:none }
  @media (prefers-color-scheme: dark){
    .gc-seg .seg{ background:#1f1f23; color:#f2f2f7; border-color:rgba(255,255,255,.08) }
  }
  .field-head{
    display:grid; grid-template-columns:1fr auto 1fr; align-items:center; gap:8px; margin-bottom:4px;
  }
  .field-head label{ margin:0; font-weight:500 }
  .hemi-row{ display:flex; gap:8px }
  .hemi-btn{
    border:1px solid rgba(0,0,0,.15); padding:4px 10px; border-radius:10px; font-size:12px; cursor:pointer; background:#fff; color:#111;
  }
  .hemi-btn[aria-pressed="true"]{ background:var(--accent); color:#fff; border-color:transparent }
  @media (prefers-color-scheme: dark){
    .hemi-btn{ background:#1f1f23; color:#f2f2f7; border-color:rgba(255,255,255,.12) }
  }
  .btn.tiny.clear-btn,
  .field .clear-btn{
    font-size:14px; padding:2px 6px; border-radius:6px; background:var(--surface); color:var(--muted); cursor:pointer;
  }
  .field-head .clear-btn{ justify-self:end }
  .gc-block{ margin-bottom:16px }

  /* ===== Small helpers ===== */
  .oat-wrap{ position:relative }
  .oat-sign-btn{
    position:absolute; right:10px; top:34px; border:0; background:#e5e5ea; color:#111;
    padding:4px 8px; border-radius:10px; font-size:12px; cursor:pointer;
  }
  @media (prefers-color-scheme: dark){ .oat-sign-btn{ background:#2a2a2f; color:#fff } }

  /* ===== Animations ===== */
  @keyframes fadeSlideIn{ to{ opacity:1; transform:translateY(0) } }

  /* ===== Optional: hide scrollbars visually (still scrollable) ===== */
  html,body{ overflow:auto; scrollbar-width:none; -ms-overflow-style:none }
  html::-webkit-scrollbar, body::-webkit-scrollbar{ display:none }

  /* ===== Conversions (scoped) ===== */
/* ===== Conversions (scoped) ===== */
/* Inherit global theme so it matches other panels */
#av-conversions{
  --r:14px;
  --gap:10px;
  --maxw:1100px;
  background:transparent;   /* was a separate light gray */
  color:inherit;
  font:inherit;
}
#av-conversions .wrap{
  max-width:var(--maxw);
  margin:0 auto;            /* remove extra top/btm space */
  padding:0;
}
#av-conversions .card{
  background:transparent;   /* let the panel provide the card feel */
  border-radius:var(--r);
  box-shadow:none;          /* no inner card-on-card look */
  padding:0;
}
#av-conversions h2{margin:0 0 6px;font-size:18px}
#av-conversions .muted{color:var(--muted);font-size:12px}
#av-conversions .hr{height:1px;background:#e5e7eb;margin:10px 0;border-radius:1px}
#av-conversions .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
#av-conversions .field{display:flex;flex-direction:column;gap:6px}
#av-conversions label{font-size:12px;color:var(--muted)}
#av-conversions input,#av-conversions select{border:1px solid #e5e7eb;border-radius:10px;padding:9px 10px;font:inherit;background:#fff;outline:none}
#av-conversions input:focus,#av-conversions select:focus{
  border-color:transparent;box-shadow:0 0 0 8px var(--ring)
}
#av-conversions .row{display:flex;gap:10px;flex-wrap:wrap}
#av-conversions .note{font-size:11px;color:var(--muted);margin-top:6px}
/* tidy spacing inside each accordion */
[data-sec] .content .row{margin-bottom:12px}
[data-sec] .content .grid{margin-top:0}
@media (max-width:640px){#av-conversions .grid{grid-template-columns:1fr}}
/* Left side: title + slim Clear inline */
#av-conversions .sum-left{
  display:inline-flex;
  align-items:center;
  gap:8px;           /* space between title and Clear */
}

/* Bring back your original skinny Clear button look */
#av-conversions .clear-btn{
  background:transparent;
  border:none;
  color:var(--accent);
  font-size:13px;
  cursor:pointer;
  display:none;      /* hidden until user changes something */
  padding:0;         /* no padding so it won't nudge layout */
  margin:0 0 0 8px;  /* sits just to the right of the heading */
  line-height:1;
}
#av-conversions .clear-btn:focus{
  outline:none;
  text-decoration:underline;
}

/* Optional: if you ever see the summary height jump, pin the line-height */
#av-conversions .disclosure summary{ line-height:1.25 }

/* tune these once */
:root { --inpad: 12px; --signW: 1.15em; --signGap: 0.2em; }

/* make sure this wins over any .field input rules */
.field .input-affix { position: relative; width: 100%; }

.field .input-affix > input {
  width: 100%;
  box-sizing: border-box;
  margin: 0;
  /* reserve just the button width + tiny gap + the input's own inner padding */
  padding-right: calc(var(--inpad) + var(--signW) + var(--signGap)) !important;
}

.field .input-affix > .oat-sign-btn {
  position: absolute;
  top: 50%;
  right: var(--inpad);     /* aligns with the input’s inner padding */
  transform: translateY(-50%);
  width: var(--signW);     /* fixed width so we can keep padding minimal */
  text-align: center;
  background: transparent;
  border: 0;
  padding: 0;
  line-height: 1;
  font-size: 0.92em;       /* small = smaller reserved space */
  cursor: pointer;
  z-index: 2;
}

.input-affix > .oat-sign-btn:focus {
  outline: none;
}

/* === PivAlt visual === */
.label-row{
  display:flex; align-items:center; justify-content:space-between;
  gap:8px; margin-bottom:6px;
}
.pillrow{ display:flex; gap:6px; flex-wrap:wrap; }
.pill{
  border:1px solid rgba(0,0,0,.1);
  background:var(--card);
  color:var(--text);
  font-size:12px; line-height:1; padding:4px 10px; border-radius:999px;
  cursor:pointer;
}
.pill:focus{ outline:none; box-shadow:0 0 0 2px var(--ring); }
.pill.action{ color:var(--acc); border-color:rgba(10,132,255,.35); }

.result-flex{
  display:flex; align-items:center; justify-content:space-between; gap:20px;
}
.result-left .kv{ white-space:nowrap; }

/* make all numbers normal weight by default */
.kv .num{ font-weight:400; letter-spacing:.2px; }

/* only Max/Min numbers bold */
.range-mini .num{ font-weight:700; }

.range-mini{
  display:flex; flex-direction:column; align-items:center; gap:10px;
  min-width:110px; margin-left:18px; padding-left:12px;
}
.range-mini .label{ font-size:12px; color:var(--muted); white-space:nowrap; }
.msl-sub{
  font-size:11px;
  color:var(--muted);
  white-space:nowrap;
  margin:4px 0;
}

/* Make the vertical line darker and the orange tick visible */
.range-mini .line{
  position:relative;
  width:3px; height:110px;
  background: var(--text, #1c1c1e);
  border-radius:3px; opacity:.95;
}

.range-mini .marker{
  position:absolute; left:50%; transform:translateX(-50%);
  width:18px; height:3px; border-radius:2px;
  background:#ff9f0a;               /* orange */
  box-shadow:0 0 0 1px rgba(0,0,0,.15);
  display:none;                      /* JS shows/hides */
}
@media (max-width:480px){
  .range-mini{ min-width:90px; }
  .range-mini .line{ height:96px; }
}
/* ===== Live Overlay as centered popup ===== */
.pa-live{
  position:fixed; inset:0; z-index:9999;
  display:flex; align-items:center; justify-content:center;
  padding: max(env(safe-area-inset-top, 0px), 8px)
           max(env(safe-area-inset-right,0px), 8px)
           max(env(safe-area-inset-bottom,0px), 8px)
           max(env(safe-area-inset-left, 0px), 8px);
  background: rgba(0,0,0,.35);   /* dim backdrop */
}
.pa-live.hidden{ display:none; }

/* Dialog sizing: always inside the screen */
.pa-live-dialog{
  width: min(94vw, 720px);
  max-height: min(92dvh, 720px); /* use dynamic viewport on iOS */
  background: var(--card, #fff);
  border-radius: 16px;
  box-shadow: 0 10px 30px rgba(0,0,0,.25);
  display:flex; flex-direction:column;
  overflow:hidden;               /* clip contents */
}

/* Header sticks to top; body scrolls if needed */
.pa-live-top{
  display:flex; align-items:center; justify-content:space-between;
  padding: 12px 14px;
  background: inherit;
  position: sticky; top: 0; z-index: 1;
  border-bottom: 1px solid rgba(0,0,0,.06);
}
.pa-live-hdg{ font-size:16px; color:var(--text, #1c1c1e); }

.pa-live-body{
  padding: 14px;
  overflow:auto;                 /* internal scroll on tiny screens */
  display:flex; gap:24px; align-items:center; justify-content:center;
}

/* Giant range */
.range-giant{
  display:flex; flex-direction:column; align-items:center; gap:14px;
  min-width:min(38vw, 220px);
}
.range-giant .label{ display:flex; flex-direction:column; align-items:center; text-align:center; }
.range-giant .label .agl .num{ font-weight:700; }
.range-giant .label .msl{ font-size:15px; color:var(--muted, #6b7280); }

.range-giant .line{
  position:relative;
  width:6px;
  height: clamp(220px, 55dvh, 480px); /* never exceeds viewport */
  background:var(--text, #1c1c1e);
  border-radius:6px; opacity:.95;
}
.range-giant .marker{
  position:absolute; left:50%; transform:translateX(-50%);
  width:32px; height:4px; border-radius:3px;
  background:#ff9f0a; box-shadow:0 0 0 1px rgba(0,0,0,.15);
}

/* Big number stack (MSL big, AGL smaller) */
.pa-live-number{
  display:flex; flex-direction:column; align-items:flex-start; gap:10px;
  min-width:min(48vw, 360px);
}
.pa-live-title{ font-size:18px; color:var(--muted, #6b7280); }

.pa-live-msl{
  font-size: clamp(28px, 6.6vw, 58px);
  font-weight:700; letter-spacing:.2px; color:var(--text, #1c1c1e);
}
.pa-live-agl{
  font-size: clamp(16px, 3.5vw, 22px);
  color:var(--muted, #6b7280);
}

/* Stack vertically on narrow devices */
@media (max-width:640px){
  .pa-live-body{ flex-direction:column; gap:18px; }
  .pa-live-number{ align-items:center; min-width:auto; }
  .range-giant{ min-width:auto; }
}

/* iOS older Safari fallback (no dvh support) */
@supports not (height: 100dvh){
  .pa-live-dialog{ max-height: 92vh; }
  .range-giant .line{ height: clamp(220px, 55vh, 480px); }
}

/* --- Make panel boxes never overflow on phones --- */
@media (max-width: 640px){
  .io{ display:block; }                /* stack boxes */
  .io .box{ width:100%; overflow:hidden; }
  .result-flex{ justify-content:flex-start; gap:12px; }
  .result-left .kv{ white-space:normal; } /* allow wrap */
  .range-mini{ order:-1; margin-left:0; margin-right:12px; min-width:72px; }
}

/* Tighten the Result layout on all screens so it fits */
.result-flex{
  display:flex; align-items:flex-start; justify-content:flex-start;
  gap:14px; flex-wrap:nowrap; width:100%;
}
.result-left .kv{ white-space:normal; }
.lead{ font-weight:600; }

/* Keep the mini range inside the field and visible */
.range-mini{
  display:flex; flex-direction:column; align-items:center; gap:8px;
  min-width:96px; margin-left:0; padding-left:4px;
}
.range-mini .label{ display:flex; flex-direction:column; align-items:center; text-align:center; }
.range-mini .line{ width:3px; height:96px; background: var(--text, #1c1c1e); border-radius:3px; opacity:.95; }
.range-mini .marker{
  position:absolute; left:50%; transform:translateX(-50%);
  width:18px; height:3px; border-radius:2px; background:#ff9f0a;
  box-shadow:0 0 0 1px rgba(0,0,0,.15); display:none;
}

/* --- Live popup: shorter + no scrolling --- */
.pa-live{
  position:fixed; inset:0; z-index:9999;
  display:flex; align-items:center; justify-content:center;
  padding: max(env(safe-area-inset-top, 0px), 8px)
           max(env(safe-area-inset-right,0px), 8px)
           max(env(safe-area-inset-bottom,0px), 8px)
           max(env(safe-area-inset-left, 0px), 8px);
  background: rgba(0,0,0,.35);
}
.pa-live.hidden{ display:none; }

.pa-live-dialog{
  width: min(94vw, 680px);
  max-height: min(80dvh, 640px);   /* shorter so Safari toolbars won't overlap */
  background: var(--card, #fff);
  border-radius: 14px;
  box-shadow: 0 10px 30px rgba(0,0,0,.25);
  display:flex; flex-direction:column;
  overflow:hidden;
}

.pa-live-top{
  display:flex; align-items:center; justify-content:space-between;
  padding: 10px 12px;
  position: sticky; top: 0; z-index: 1;
  border-bottom: 1px solid rgba(0,0,0,.06);
}

.pa-live-body{
  padding: 12px;
  display:flex; gap:16px; align-items:center; justify-content:center;
  overflow:hidden;                /* lock internal scroll */
}

/* Giant range slightly shorter */
.range-giant .line{
  height: clamp(180px, 42dvh, 360px);
}

@media (max-width:640px){
  .pa-live-body{ flex-direction:column; gap:14px; }
}

/* Disable page scrolling when live popup is open */
.no-scroll{ overflow:hidden; height:100dvh; }

/* ===== Live overlay: phone-fit tweaks ===== */
@media (max-width: 480px){      /* only phones */
  /* trim the white card so it never exceeds ~75 % of the screen height */
  .pa-live-dialog{
    max-height: 75dvh;          /* was 80dvh */
    border-radius: 12px;
  }

  /* tighten vertical spacing inside */
  .pa-live-body{ gap: 10px; padding: 10px; }

  /* shorter black line */
  .range-giant .line{
    height: clamp(120px, 38dvh, 280px);   /* was min 180px */
  }

  /* less gap around the range + number stack */
  .range-giant{ gap: 10px; min-width: 64px; }
  .pa-live-number{ gap: 6px; }

  /* downsize the big fonts a touch */
  .pa-live-msl{ font-size: clamp(26px, 6.0vw, 48px); }
  .pa-live-agl{ font-size: clamp(14px, 3.2vw, 20px); }
  .range-giant .label .msl{ font-size: 14px; }

  /* Max/Min blocks a hair tighter */
  .range-giant .label{ gap: 2px; }

  /* make the orange marker thinner on small screens */
  .range-giant .marker{ width: 26px; height: 3px; }
}
/* === PivAlt: keep fields fitting, put mini range on the RIGHT, no wrapping === */

/* keep whole row inside the box */
#panel-pivalt .result-flex{
  display:flex; align-items:flex-start; justify-content:flex-start;
  gap:14px; width:100%; overflow:hidden;
}

/* text block first (left) */
#panel-pivalt .result-left{ order:1; min-width:0; }

/* mini range last (right) and inside the field */
#panel-pivalt .range-mini{
  order:2;
  margin-left:auto;   /* push to the right edge */
  margin-right:0;
  min-width:96px;
  flex:0 0 auto;      /* don’t stretch, don’t shrink */
  padding-left:8px;   /* a little breathing room from text */
}

/* === Fix: mini range sits on the right, but its labels are centered === */
#panel-pivalt .result-flex{
  display:flex; align-items:flex-start; justify-content:flex-start;
  gap:14px; width:100%; overflow:hidden;
}

/* mini range stays right-aligned inside the box */
#panel-pivalt .range-mini{
  margin-left:auto;            /* push to right edge */
  margin-right:0;
  min-width:96px;
  flex:0 0 auto;               /* don't stretch/shrink */
  padding-left:8px;
}

/* center each label block ABOVE and BELOW the vertical line */
#panel-pivalt .range-mini .label{
  display:flex;
  flex-direction:column;
  align-items:center;          /* center horizontally */
  text-align:center;           /* center text */
  gap:2px;
}

/* keep each line single-line (no wrapping) */
#panel-pivalt .range-mini .label,
#panel-pivalt .range-mini .msl-sub{ white-space:nowrap; }

/* vertical line + marker (unchanged) */
#panel-pivalt .range-mini .line{
  position:relative; width:3px; height:96px;
  background: var(--text, #1c1c1e); border-radius:3px; opacity:.95;
}
#panel-pivalt .range-mini .marker{
  position:absolute; left:50%; transform:translateX(-50%);
  width:18px; height:3px; border-radius:2px;
  background:#ff9f0a; box-shadow:0 0 0 1px rgba(0,0,0,.15);
}

/* phone: keep it inside the box */
@media (max-width:640px){
  #panel-pivalt .result-flex{ gap:12px; }
  #panel-pivalt .range-mini{ min-width:84px; padding-left:6px; }
}
/* Keep the mini range on the right, but center its labels */
#panel-pivalt .range-mini{
  margin-left:auto; min-width:108px; padding-left:8px; flex:0 0 auto;
}
#panel-pivalt .range-mini .label{
  display:flex; flex-direction:column; align-items:center; text-align:center; gap:4px;
}

/* Make each AGL line ONE row (no wrapping of number/unit) */
#panel-pivalt .range-mini .label .row{
  display:inline-flex; align-items:baseline; gap:4px; white-space:nowrap;
}

/* Keep the MSL line a single row too */
#panel-pivalt .range-mini .msl-sub{ white-space:nowrap; }

.section { margin: 10px 0 14px; }
.section-title { margin: 0 0 8px; font-weight: 600; font-size: 1rem; color: var(--text); }
.mode-pills .btn.secondary {
  background: transparent;
  border: 1px solid var(--border);
  padding: 6px 14px;
  font-size: 14px;
  border-radius: 999px;
  cursor: pointer;
}

/* Active / selected state */
.mode-pills .btn.secondary.active {
  background: #e5e5ea;   /* light gray in light mode */
  border-color: #e5e5ea;
  color: #111;
}

@media (prefers-color-scheme: dark){
  .mode-pills .btn.secondary.active {
    background: #2a2a2f; /* dark gray in dark mode */
    border-color: #2a2a2f;
    color: #fff;
  }
}
/* ===== Time Organizer rows ===== */
.to-row{
  position: relative;
  display:flex; align-items:center; gap:8px;
  padding:8px; border:1px solid rgba(0,0,0,.06); border-radius:12px;
  background:linear-gradient(180deg, rgba(0,0,0,.02), rgba(0,0,0,0));
}
.to-title{ flex:1; min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.to-tags{ display:flex; gap:6px; flex-wrap:wrap; }
.to-tag{ font-size:12px; padding:2px 8px; border-radius:999px; border:1px solid rgba(0,0,0,.08); }
.to-tag.muted{ opacity:.55; }

/* Actions pinned hard-right; pills expand to the left */
.to-actions{ margin-left:auto; display:flex; align-items:center; gap:8px; justify-content:flex-end; }

/* Inline mode: hide normal info but keep row + 3-dot visible */
.to-row.is-inline .to-title,
.to-row.is-inline .to-tags,
.to-row.is-inline [data-act] { display:none; }

/* Inline pill group (shown only in inline mode) */
.action-group{ display:none; align-items:center; gap:8px; }
.to-row.is-inline .action-group{ display:inline-flex; }

/* Transparent pill buttons (base) */
.btn.pill-ghost{
  color: var(--text);
  background: transparent;
  border: 1px solid var(--border);
  border-radius: 999px;
  padding: 6px 12px;
  font-size: 13px;
  line-height: 1;
}

/* DELETE pill — solid red text, readable in light/dark */
.btn.pill-ghost.danger{
  color: var(--danger) !important; /* make it red */
  border-color: color-mix(in srgb, var(--danger), transparent 70%) !important;
}

.btn.pill-ghost.danger:hover{
  background: color-mix(in srgb, var(--danger), transparent 92%);
}

/* 3-dot stays pinned at far right */
.menu-btn{
  width:28px; height:28px;
  border-radius:999px; border:1px solid var(--border);
  background:rgba(0,0,0,.04);
  line-height:26px; text-align:center; font-weight:600;
  padding:0;
}

/* Buffer chip between rows */
.to-gap{ display:flex; justify-content:center; }
.to-gap-btn{
  cursor:pointer; padding:4px 12px; border-radius:999px;
  font-size:12px; border:1px solid rgba(0,0,0,.12);
  background: rgba(0,0,0,.04);
}
.to-gap-btn.active{
  border-color: var(--accent);
  box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent), transparent 80%);
}

/* Spacer */
.mt-16{ margin-top:16px; }

/* Center pill under schedule */
.center-pill{ margin-top:10px; display:flex; justify-content:center; }
.center-pill::before{
  content: attr(data-text);
  display:inline-block; padding:8px 16px; border-radius:999px;
  border:1px solid var(--border); background:rgba(0,0,0,.04);
  font-weight:600;
}
/* Keep -1m/+1m looking the same as before */
.to-actions .btn.secondary{
  padding:4px 10px;
  font-size:12px;
  border-radius:999px;
}

/* Make Delete pill clearly red and readable */
.btn.pill-ghost.danger{
  color: var(--danger) !important;        /* hard red text */
  border-color: color-mix(in srgb, var(--danger), transparent 70%) !important;
}

/* Optional: extra pop on hover for Delete */
.btn.pill-ghost.danger:hover{
  background: color-mix(in srgb, var(--danger), transparent 92%);
}
/* Compact − / + buttons (keeps your .btn.secondary look) */
.to-actions .btn.secondary{
  padding: 0 10px;
  height: 28px;
  font-size: 14px;
  border-radius: 999px;
}

/* Mobile spacing between Plan and Schedule boxes */
.io .box + .box { margin-top: 12px; }
@media (min-width: 720px){
  .io .box + .box { margin-top: 0; }
}
/* === Tile layout base === */
.tile{ position:relative; padding-bottom:16px; }
.tile-head{ display:flex; gap:8px; align-items:flex-start; }
.tile-head .title-wrap{ flex:1; min-width:0; }
.tile-head h3{ margin:0 0 4px; font-size:16px; }
.tile-head p { margin:0; color:var(--muted); font-size:13px; }

/* 3-dot button top-right */
.tile-menu-btn{
  position:absolute; top:8px; right:8px;
  width:22px; height:22px; padding:0; border:none; background:transparent;
  color:var(--muted); font-size:18px; line-height:1; cursor:pointer; user-select:none; z-index:1;
}
.tile-menu-btn:focus-visible{ outline:none; border-radius:6px; box-shadow:0 0 0 2px var(--ring); }

/* --- Animated footer (no border line) --- */
.tile-footer{
  display:flex; justify-content:center; align-items:center; gap:14px; flex-wrap:wrap;
  margin-top:6px; padding-top:0;

  /* closed state */
  max-height:0; overflow:hidden;
  opacity:0; transform:translateY(-4px);
  transition:
    max-height 180ms cubic-bezier(.2,.7,.3,1),
    opacity    180ms cubic-bezier(.2,.7,.3,1),
    transform  180ms cubic-bezier(.2,.7,.3,1),
    padding-top 180ms cubic-bezier(.2,.7,.3,1);
  will-change: max-height, opacity, transform;
}

/* open state */
.tile.menu-open .tile-footer{
  padding-top:6px;
  max-height:120px;           /* adjust if more rows needed */
  opacity:1;
  transform:translateY(0);
  transition:
    max-height 180ms cubic-bezier(.2,.7,.3,1),
    opacity    180ms cubic-bezier(.2,.7,.3,1),
    transform  180ms cubic-bezier(.2,.7,.3,1),
    padding-top 180ms cubic-bezier(.2,.7,.3,1);
}

/* Flat text buttons */
.btn.flat{
  background:transparent; border:none; padding:4px 2px;
  font-size:13px; color:var(--text); cursor:pointer;
}
.btn.flat:hover{ text-decoration:underline; }
.btn.flat:active{ opacity:.85; }
.btn.flat:focus-visible{ outline:none; box-shadow:0 0 0 2px var(--ring); border-radius:6px; }

/* Motion respect */
@media (prefers-reduced-motion: reduce){
  .tile-footer,
  .tile.menu-open .tile-footer{
    transition:none;
    transform:none;
  }
}
.mode-pills.centered {
  display: flex;
  justify-content: center;
  margin-top: 6px; /* space below input */
  gap: 6px;        /* spacing between buttons */
}
.tz-info-note {
  font-size: 0.8em;
  color: #9aa3b2; /* your muted gray token */
  margin-top: 4px;
}
.tile-head {
  display: block; /* no longer flex — heading controls icon position */
}

.tile-icon {
  margin-right: 6px;
  color: var(--muted);
  font-size: 16px;
}
.tz-swap-btn {
  padding: 2px 10px;
  border: none;
  border-radius: 999px;   /* pill shape */
  background: var(--card-2, #e5e5ea);
  color: var(--text, #111);
  font-size: 13px;
  cursor: pointer;
  transition: background 0.2s;
}

.tz-swap-btn:hover {
  background: var(--accent, #0a84ff);
  color: #fff;
}

</style>

</head>
<body>
<div class="app">
  <h1>Aviation Calculator</h1>
  <div class="subtitle">Offline, single file. Apple-like quick fades. Click a tile to open. Values auto-compute as you type.</div>

  <!-- Tiles -->
  <div id="tiles" class="grid">
    <div class="tile" data-panel="c172-perf">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-chart-simple tile-icon"></i> C172 Performance</h3>
          <p>Short-field takeoff/landing, climb, cruise, range</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="conversions">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-right-left tile-icon"></i> Conversions</h3>
          <p>Speed, distance, temp, pressure, fuel, time &amp; more</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="toc-tod">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-arrows-up-down tile-icon"></i> TOC &amp; TOD</h3>
          <p>Top of Climb / Descent planning</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="etp-pnr">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-arrows-left-right-to-line tile-icon"></i> ETP &amp; PNR</h3>
          <p>Equal Time Point and Point of No Return</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="meet">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-people-arrows-left-right tile-icon"></i> Meetpoint</h3>
          <p>Head-on pass: where and when</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="vortri">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-compass-drafting tile-icon"></i> VOR Triangle</h3>
          <p>Distances from VOR using two radials</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="gc">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-globe tile-icon"></i> Lat/Long</h3>
          <p>Distance and True course</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="tas">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-gauge-high tile-icon"></i> True Airspeed</h3>
          <p>From IAS/CAS, pressure altitude, temperature</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="sdt">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-stopwatch tile-icon"></i> Speed • Distance • Time</h3>
          <p>Universal solver & scenarios</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="wind">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-wind tile-icon"></i> Wind • Angles</h3>
          <p>WCA, heading, GS, components, limits</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="altitudes">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-mountain tile-icon"></i> Altitudes</h3>
          <p>PA, DA, TA, conversions</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="fpm">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-chart-line tile-icon"></i> IFR Gradients</h3>
          <p>FPM • ft/nm • angles • TOD</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="pivalt">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-crosshairs tile-icon"></i> Pivotal Altitude</h3>
          <p>From GS or IAS + wind</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="sixty">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-ruler-combined tile-icon"></i> 60-to-1 Rule</h3>
          <p>Track error • Intercept • Time-to-fix</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="clouds">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-cloud tile-icon"></i> Clouds (Base/Top/Thickness)</h3>
          <p>CCL/LCL, top by lapse or top temp</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="hydro">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-droplet tile-icon"></i> Hydroplaning</h3>
          <p>Vp ≈ 9 · √(psi)</p>
        </div>
      </div>
    </div>

    <div class="tile" data-panel="timeorg">
      <div class="tile-head">
        <div class="title-wrap">
          <h3><i class="fa-solid fa-calendar-days tile-icon"></i> Time Organizer</h3>
          <p>Chain events • Buffers • Leave/Arrive</p>
        </div>
      </div>
    </div>

  </div>

  <!-- All panels start hidden by default -->
  <!-- ===== Panels ===== -->
 <div id="panel-c172-perf" class="panel hidden" aria-hidden="true">
      <div class="backbar">
        <button class="btn ghost" data-back>&larr; All calculators</button>
        <h3>C172S Performance — Short-Field Only</h3>
      </div>

      <div class="toolbar">
        <button class="btn ghost" id="C172_CLEAR">Clear</button>
      </div>

      <!-- Inputs -->
      <details class="disclosure" open>
        <summary><span>Atmosphere & Runway Inputs</span><span class="chev">›</span></summary>
        <div class="content">
          <div class="form">
            <div class="field oat-wrap">
              <label for="F_ELEV">Field elevation / Cruise altitude (ft)</label>
              <div style="display:flex; gap:8px; width:100%;">
                <!-- Ground input with button inside -->
                <div class="input-affix" style="flex:1; min-width:0;">
                  <input id="F_ELEV" inputmode="decimal" placeholder="ground" />
                  <button type="button" class="oat-sign-btn" aria-label="Toggle sign">±</button>
                </div>
                <!-- Cruise input normal -->
                <input id="F_ELEV_CR" inputmode="decimal" placeholder="cruise" style="flex:1; min-width:0;" />
              </div>
            </div>
            <div class="field"><label>Altimeter (inHg)</label><input id="F_ALT" inputmode="decimal" placeholder="##.##"/></div>
            <div class="field oat-wrap">
              <label for="F_OAT">OAT (°C) — Ground / Cruise</label>
              <div style="display:flex; gap:8px; width:100%;">
                <!-- Ground OAT input -->
                <div class="input-affix" style="flex:1; min-width:0;">
                  <input id="F_OAT" inputmode="decimal" placeholder="ground">
                  <button type="button" class="oat-sign-btn" aria-label="Toggle sign">±</button>
                </div>
                <!-- Cruise OAT input -->
                <div class="input-affix" style="flex:1; min-width:0;">
                  <input id="F_OAT_CR" inputmode="decimal" placeholder="cruise">
                  <button type="button" class="oat-sign-btn" aria-label="Toggle sign">±</button>
                </div>
              </div>
            </div>

            <!-- Weight moved directly below OAT -->
            <div class="field"><label>Weight (lb)</label><input id="AC_WT" inputmode="numeric" placeholder="####"/></div>

            <div class="field"><label>Runway heading (°)</label><input id="RWY_HDG" inputmode="numeric" placeholder="###"/></div>
            <!-- Wind: single field ddd@ss kt -->
            <div class="field">
              <label>Wind (ddd@kt)</label>
              <input id="WIND_AT" type="text" inputmode="numeric" placeholder="e.g., 220@12"/>
            </div>
            <!-- Runway surface & slope merged -->
            <div class="field">
              <label>Runway surface &amp; slope</label>
              <div style="display:flex; gap:8px; align-items:center;">
                <select id="RWY_SURF" style="flex:1; min-width:0;">
                  <option value="paved_dry" selected>Paved (dry)</option>
                  <option value="paved_wet">Paved (wet)</option>
                  <option value="grass">Grass/soft</option>
                </select>
                <input id="RWY_SLOPE" type="text" inputmode="decimal" placeholder="slope %"
                      style="width:110px;" />
              </div>
            </div>
            <!-- Cruise RPM field with presets moved below the input -->
            <div class="field">
              <label for="CR_RPM" style="margin:0;">Cruise RPM</label>

              <input id="CR_RPM" inputmode="decimal" placeholder="e.g., 2400"/>

              <!-- Presets under the input (same field) -->
              <div id="CR_RPM_PRESETS" style="display:flex; gap:6px; flex-wrap:wrap; margin-top:8px;">
                <button class="btn secondary" type="button" data-rpm="2300" tabindex="-1"
                  style="padding:2px 10px; font-size:12px; line-height:1.2; border-radius:999px;">2300</button>
                <button class="btn secondary" type="button" data-rpm="2400" tabindex="-1"
                  style="padding:2px 10px; font-size:12px; line-height:1.2; border-radius:999px;">2400</button>
                <button class="btn secondary" type="button" data-rpm="2500" tabindex="-1"
                  style="padding:2px 10px; font-size:12px; line-height:1.2; border-radius:999px;">2500</button>
                <button class="btn secondary" type="button" data-rpm="2600" tabindex="-1"
                  style="padding:2px 10px; font-size:12px; line-height:1.2; border-radius:999px;">2600</button>

                <button id="CR_FIND_75" class="btn secondary" type="button" tabindex="-1"
                  title="Find published RPM with ≤75% MCP"
                  style="padding:2px 12px; font-size:12px; line-height:1.2; border-radius:999px;">≤75%</button>
              </div>
            </div>

            <div class="field">
              <label>Landing flaps</label>
              <select id="LD_FLAPS">
                <option value="full" selected>Full (POH short-field)</option>
                <option value="up">UP (approach +9 KIAS; +35% distance)</option>
              </select>
            </div>
          </div>

          <div class="io">
            <div class="box">
              <h4>Atmosphere</h4>
              <div class="kv" id="OUT_PA">PA: — ft</div>
              <div class="kv" id="OUT_DA">DA: — ft</div>
              <div class="kv muted" id="OUT_ISA">ISA at PA: — °C</div>
            </div>
            <div class="box">
              <h4>Wind components</h4>
              <div class="kv" id="OUT_HW">Head/Tailwind: — kt</div>
              <div class="kv" id="OUT_XW">Crosswind: — kt (R/L)</div>
            </div>
          </div>
        </div>
      </details>

      <!-- NEW: Stall Speeds @ 2550 lb -->
    <details class="disclosure">
      <summary><span>Stall Speeds — 2550 lb (Power IDLE)</span><span class="chev">›</span></summary>
      <div class="content">
        <div class="form">
          <div class="field">
            <label>CG</label>
            <select id="ST_CG">
              <option value="rear" selected>Most Rearward</option>
              <option value="forward">Most Forward</option>
            </select>
          </div>
          <div class="field">
            <label>Flaps</label>
            <select id="ST_FLAPS">
              <option value="up">UP</option>
              <option value="10">10°</option>
              <option value="full" selected>FULL</option>
            </select>
          </div>
          <div class="field">
            <label>Angle of bank</label>
            <select id="ST_BANK">
              <option value="0" selected>0°</option>
              <option value="30">30°</option>
              <option value="45">45°</option>
              <option value="60">60°</option>
            </select>
          </div>
        </div>

        <div class="io">
          <div class="box">
            <h4>Stall speed (from POH tables)</h4>
            <div class="kv" id="ST_OUT_KIAS">KIAS: —</div>
            <div class="kv" id="ST_OUT_KCAS">KCAS: —</div>
          </div>
          <div class="box">
            <h4>Notes</h4>
            <div class="kv">Power: IDLE. KIAS values approximate. Altitude loss in recovery may be up to ~230 ft.</div>
          </div>
        </div>
      </div>
    </details>

    <!-- NEW: Airspeed Calibration (Normal / Alternate static) -->
    <details class="disclosure">
      <summary><span>Airspeed Calibration</span><span class="chev">›</span></summary>
      <div class="content">
        <div class="form">
          <div class="field">
            <label>Static source</label>
            <select id="AC_SRC">
              <option value="normal" selected>Normal static</option>
              <option value="alternate">Alternate static</option>
            </select>
          </div>
          <div class="field">
            <label>Flaps</label>
            <select id="AC_FLAPS">
              <option value="up" selected>UP</option>
              <option value="10">10°</option>
              <option value="full">FULL</option>
            </select>
          </div>
          <div class="field">
            <label>Indicated airspeed (KIAS)</label>
            <input id="AC_KIAS" inputmode="decimal" placeholder="e.g., 90">
          </div>
        </div>

        <div class="io">
          <div class="box">
            <h4 id="AC_OUT_HDR">Calibrated airspeed (KCAS)</h4>
            <div class="kv" id="AC_OUT_VAL">—</div>
          </div>
          <div class="box">
            <h4>Conditions</h4>
            <div class="kv">Level flight / max-power descent; windows/vents closed; heat/defrost max for ALT static.</div>
          </div>
        </div>
      </div>
    </details>

      <!-- Outputs -->
      <div class="perf-output">
        <h4>Short-Field Takeoff (10°)</h4>
        <div class="io">
          <div class="box">
            <div class="kv" id="TOS_GR">Ground roll: — ft</div>
            <div class="kv" id="TOS_50">Over 50 ft: — ft</div>
          </div>
        </div>

        <div class="note warn" id="TO_TW_WARN" style="margin-top:6px"></div>

        <h4 style="margin-top:16px">Short-Field Landing (full)</h4>
        <div class="io">
          <div class="box">
            <div class="kv" id="LDS_GR">Ground roll: — ft</div>
            <div class="kv" id="LDS_50">Over 50 ft: — ft</div>
          </div>
        </div>

        <div class="note" id="LD_NOTE" style="margin-top:6px"></div>
        <div class="note warn" id="LD_TW_WARN" style="margin-top:6px"></div>

        <h4 style="margin-top:16px">Max Rate of Climb (2550 lb)</h4>
        <div class="io">
          <div class="box">
            <div class="kv" id="ROC_SPD">Climb speed: — KIAS</div>
            <div class="kv" id="ROC_FPM">Rate of climb: — fpm</div>
            <div class="kv" id="ROC_AVG_FPM">Avg through climb: — fpm</div>
          </div>
        </div>
        <div class="note" id="ROC_NOTE" style="margin-top:6px">
          Mixture leaned above 3000 ft PA for maximum RPM.
        </div>

        <h4 style="margin-top:16px">Climb: Time, Fuel, Distance (2550 lb)</h4>
        <div class="io">
          <div class="box">
            <div class="kv" id="CL_TIME">Time to climb: — min</div>
            <div class="kv" id="CL_FUEL">Fuel used: — gal</div>
            <div class="kv" id="CL_DIST">Distance: — NM</div>
          </div>
        </div>
        <div class="note" id="CL_NOTE" style="margin-top:6px"></div>

        <h4 style="margin-top:16px">Cruise (2550 lb)</h4>
        <div class="io">
          <div class="box">
            <div class="kv" id="CR_OUT_MCP">% MCP: —</div>
            <div class="kv">
              <div class="kv">
                <span id="CR_OUT_KTAS">KTAS: —</span>
                <label style="margin-left:8px; font-size:0.85em; user-select:none;">
                  <input type="checkbox" id="FAIRING_CB" style="margin-right:4px;" checked>
                  No fairings
                </label>
              </div>
            </div>
            <div class="kv" id="CR_OUT_GPH">GPH: —</div>
          </div>
        </div>
        <div class="note" id="CR_NOTE" style="margin-top:6px">
          Recommended lean mixture. Speed fairings assumed by POH (reduce KTAS by ~2 kt without).
        </div>

        <h4 style="margin-top:16px">Total Range (No wind)</h4>
        <div class="io">
          <div class="box">
            <div class="kv" id="CR_OUT_RANGE">Total Range: — NM</div>
          </div>
        </div>
        <div class="note" id="CR_RANGE_NOTE" style="margin-top:6px">
          Fixed assumptions from POH Range Profile: 53 gal usable, 45 min reserve, recommended lean mixture, std temp, zero wind.
          KTAS reduced by ~2 kt if “No fairings” is checked.
        </div>

        <h4 style="margin-top:16px">Endurance (No wind)</h4>
        <div class="io">
          <div class="box">
            <div class="kv" id="CR_OUT_ENDURANCE">Endurance: — hrs</div>
          </div>
        </div>
        <div class="note" id="CR_ENDURANCE_NOTE" style="margin-top:6px">
          Based on POH Endurance Profile: 53 gal usable, 45 min reserve, recommended lean mixture, std temp.
        </div>

      </div>

      <div style="margin-top:10px; text-align:right;">
        <div style="font-size:0.85em; color:var(--muted); text-align:left; margin-bottom:6px;">
          Note: data does not save after refreshing the page.
        </div>
        <button class="btn secondary" id="savePerf" data-html2canvas-ignore="true">Share / Save Image</button>
      </div>

      <div class="note warn">
        For planning purposes only. Verify all performance calculations with the aircraft POH and applicable FAA regulations.
      </div>
  </div>

  <!-- ETP / PNR -->
  <div id="panel-etp-pnr" class="panel hidden" aria-hidden="true">
    <div class="backbar">
      <button class="btn ghost" data-back>&larr; All calculators</button>
      <h3>ETP &amp; PNR</h3>
    </div>

    <div class="toolbar">
      <button class="btn secondary" id="swap-etp">Swap A↔B winds</button>
      <button class="btn ghost" id="clear-etp">Clear</button>
    </div>

    <div class="form">
      <div class="field">
        <label>Total distance A↔B (nm)</label>
        <input id="D_nm" type="text" placeholder="e.g., 900"/>
      </div>
      <div class="field">
        <label>GS A→B (kts)</label>
        <input id="GS_out" type="text" placeholder="e.g., 420"/>
      </div>
      <div class="field">
        <label>GS B→A (kts)</label>
        <input id="GS_ret" type="text" placeholder="e.g., 480"/>
      </div>
      <div class="field">
        <label>Usable endurance (hh:mm or hours)</label>
        <input id="Endurance" type="text" placeholder="e.g., 6:30 or 6.5"/>
      </div>
    </div>

    <!-- Groundspeed helper -->
    <details class="disclosure" id="gsHelper">
      <summary>
        <span>Groundspeed helper (compute GS from TAS, course and wind)</span>
        <span class="chev">›</span>
      </summary>
      <div class="content">
        <div class="form">
          <div class="field">
            <label>TAS (kt)</label>
            <input id="TAS_helper" type="text" placeholder="e.g., 120"/>
          </div>
          <div class="field">
            <label>True Course A→B (°)</label>
            <input id="TC_out" type="text" placeholder="e.g., 085"/>
          </div>
          <div class="field">
            <label>Wind from (° true)</label>
            <input id="WindFrom" type="text" placeholder="e.g., 320"/>
          </div>
          <div class="field">
            <label>Wind speed (kt)</label>
            <input id="WindSpeed" type="text" placeholder="e.g., 18"/>
          </div>
          <div class="field">
            <label>Return TAS (kt) — optional</label>
            <input id="TAS_ret_helper" type="text" placeholder="defaults to TAS"/>
          </div>
        </div>

        <div class="io">
          <div class="box">
            <h4>A→B results</h4>
            <div class="kv" id="GS_out_calc">GS: — kt</div>
            <div class="kv" id="WCA_out_calc">WCA: — ° (R+ / L–)</div>
            <div class="kv" id="HDG_out_calc">Suggested HDG: — °</div>
          </div>
          <div class="box">
            <h4>B→A results</h4>
            <div class="kv" id="GS_ret_calc">GS: — kt</div>
            <div class="kv" id="WCA_ret_calc">WCA: — ° (R+ / L–)</div>
            <div class="kv" id="HDG_ret_calc">Suggested HDG: — °</div>
          </div>
        </div>

        <div class="toolbar" style="margin-top:10px;">
          <button class="btn" id="apply_gs">Fill GS fields above</button>
          <button class="btn linky" id="clear_gs_helper">Reset helper</button>
        </div>
      </div>
    </details>

  <div class="io">
    <div class="box">
      <h4>Equal Time Point (from A)</h4>
      <div class="kv" id="etpDist">Dist: — nm</div>
      <div class="kv" id="etpTime">Time: — hh:mm</div>
      <div class="kv" id="etpLeg">Time from ETP: — hh:mm</div>
    </div>
    <div class="box">
      <h4>Point of No Return (from A)</h4>
      <div class="kv" id="pnrDist">Dist: — nm</div>
      <div class="kv" id="pnrTime">Time: — hh:mm</div>
    </div>
  </div>

<div class="footer">
  ETP distance = D × GS<sub>ret</sub> / (GS<sub>out</sub> + GS<sub>ret</sub>); ETP time = distance / GS<sub>out</sub>.
  PNR time = Endurance × GS<sub>ret</sub> / (GS<sub>out</sub> + GS<sub>ret</sub>); PNR distance = time × GS<sub>out</sub>.
</div>
</div>

<!-- Meetpoint (head-on pass) -->
<div id="panel-meet" class="panel hidden" aria-hidden="true">
  <div class="backbar">
    <button class="btn ghost" data-back>&larr; All calculators</button>
    <h3>Meetpoint (two aircraft head-on)</h3>
  </div>

  <div class="toolbar">
    <button class="btn ghost" id="clear-meet">Clear</button>
  </div>

  <div class="form">
    <div class="field">
      <label>Total distance A↔B (nm)</label>
      <input id="M_D" type="text" placeholder="e.g., 84.5"/>
    </div>
    <div class="field">
      <label>True Course A→B (°)</label>
      <input id="M_TC" type="text" placeholder="e.g., 195"/>
    </div>
    <div class="field">
      <label>Wind from (° true) — optional</label>
      <input id="M_WF" type="text" placeholder="e.g., 220"/>
    </div>
    <div class="field">
      <label>Wind speed (kt) — optional</label>
      <input id="M_W" type="text" placeholder="e.g., 21"/>
    </div>
  </div>

  <div class="form">
    <div class="field">
      <label>A: TAS (kt) — or leave blank and enter GS</label>
      <input id="M_TAS_A" type="text" placeholder="e.g., 91"/>
    </div>
    <div class="field">
      <label>A: GS override (kt)</label>
      <input id="M_GS_A" type="text" placeholder="e.g., 72"/>
    </div>
    <div class="field">
      <label>B: TAS (kt) — or leave blank and enter GS</label>
      <input id="M_TAS_B" type="text" placeholder="e.g., 91"/>
    </div>
    <div class="field">
      <label>B: GS override (kt)</label>
      <input id="M_GS_B" type="text" placeholder="e.g., 110"/>
    </div>
  </div>

  <div class="io">
    <div class="box">
      <h4>Computed groundspeeds</h4>
      <div class="kv" id="M_GS_A_out">A GS: — kt</div>
      <div class="kv" id="M_GS_B_out">B GS: — kt</div>
    </div>
    <div class="box">
      <h4>Meetpoint</h4>
      <div class="kv" id="M_into_A">Distance into A: — nm</div>
      <div class="kv" id="M_into_B">Distance into B: — nm</div>
      <div class="kv" id="M_time">Time to meet: — hh:mm</div>
    </div>
  </div>
</div>

  <!-- VOR Triangle -->
  <div id="panel-vortri" class="panel hidden" aria-hidden="true">
  <div class="backbar">
    <button class="btn ghost" data-back>&larr; All calculators</button>
    <h3>VOR Triangle (two radials)</h3>
  </div>

  <div class="toolbar">
    <button class="btn ghost" id="clear-vor">Clear</button>
  </div>

  <div class="form">
    <div class="field">
      <label>Distance between A and B (nm)</label>
      <input id="VT_AB" type="text" placeholder="e.g., 84.5"/>
    </div>
    <div class="field">
      <label>VOR radial at A (°)</label>
      <input id="VT_R_A" type="text" placeholder="e.g., 031"/>
    </div>
    <div class="field">
      <label>VOR radial at B (°)</label>
      <input id="VT_R_B" type="text" placeholder="e.g., 155"/>
    </div>
    <div class="field">
      <label>True course A→B (°)</label>
      <input id="VT_TC" type="text" placeholder="e.g., 195"/>
    </div>
  </div>

  <details class="disclosure">
    <summary>
      <span>Optional: time from B to VOR (supply GS or TAS+wind)</span>
      <span class="chev">›</span>
    </summary>
    <div class="content">
      <div class="form">
        <div class="field">
          <label>B→VOR GS override (kt)</label>
          <input id="VT_GS_B" type="text" placeholder="or use TAS + wind below"/>
        </div>
        <div class="field">
          <label>B TAS (kt)</label>
          <input id="VT_TAS_B" type="text" placeholder="e.g., 91"/>
        </div>
        <div class="field">
          <label>Wind from (° true)</label>
          <input id="VT_WF" type="text" placeholder="e.g., 220"/>
        </div>
        <div class="field">
          <label>Wind speed (kt)</label>
          <input id="VT_W" type="text" placeholder="e.g., 21"/>
        </div>
      </div>
      <div class="box" style="margin-top:10px;">
        <h4>Time B→VOR</h4>
        <div class="kv" id="VT_time">Time: — hh:mm</div>
        <div class="kv" id="VT_GS_used">GS used: — kt (course B→VOR shown below)</div>
      </div>
    </div>
  </details>

  <div class="io">
    <div class="box">
      <h4>Distances</h4>
      <div class="kv" id="VT_A">VOR→A: — nm</div>
      <div class="kv" id="VT_B">VOR→B: — nm</div>
    </div>
    <div class="box">
      <h4>Geometry</h4>
      <div class="kv" id="VT_angles">Angles A / VOR / B: — / — / — °</div>
      <div class="kv" id="VT_courseB">Course B→VOR: — °</div>
    </div>
  </div>

  <div class="note" style="margin-top:6px;"></div>
  <div class="footer"></div>
</div>

<!-- Great Circle -->
<div id="panel-gc" class="panel hidden" aria-hidden="true">
  <div class="backbar">
    <button class="btn ghost" data-back>&larr; All calculators</button>
    <h3>Lat/Long Distance &amp; True Course</h3>
  </div>

  <div class="toolbar">
    <button class="btn ghost" id="clear-gc">Clear</button>
  </div>

  <div class="form">

    <div class="field">
      <div class="field-head">
        <label>Lat A</label>
        <div class="hemi-row">
          <button type="button" class="hemi-btn" data-target="lat1" data-axis="lat" data-val="N" aria-pressed="true">N</button>
          <button type="button" class="hemi-btn" data-target="lat1" data-axis="lat" data-val="S" aria-pressed="false">S</button>
        </div>
        <button class="btn tiny clear-btn" id="clear-lat1">✕</button>
      </div>
      <div class="gc-seg-row">
        <div class="gc-seg" id="seg-lat1">
          <input class="seg dd" id="lat1_dd" inputmode="numeric" maxlength="2" placeholder="DD">
          <span class="sep">:</span>
          <input class="seg mm" id="lat1_mm" inputmode="numeric" maxlength="2" placeholder="MM">
          <span class="sep">:</span>
          <input class="seg ss" id="lat1_ss" inputmode="numeric" maxlength="2" placeholder="SS">
        </div>
      </div>
    </div>

    <div class="field">
      <div class="field-head">
        <label>Lon A</label>
        <div class="hemi-row">
          <button type="button" class="hemi-btn" data-target="lon1" data-axis="lon" data-val="E" aria-pressed="false">E</button>
          <button type="button" class="hemi-btn" data-target="lon1" data-axis="lon" data-val="W" aria-pressed="true">W</button>
        </div>
        <button class="btn tiny clear-btn" id="clear-lon1">✕</button>
      </div>
      <div class="gc-seg-row">
        <div class="gc-seg" id="seg-lon1">
          <input class="seg dd" id="lon1_dd" inputmode="numeric" maxlength="3" placeholder="DDD">
          <span class="sep">:</span>
          <input class="seg mm" id="lon1_mm" inputmode="numeric" maxlength="2" placeholder="MM">
          <span class="sep">:</span>
          <input class="seg ss" id="lon1_ss" inputmode="numeric" maxlength="2" placeholder="SS">
        </div>
      </div>
    </div>

    <div class="field">
      <div class="field-head">
        <label>Lat B</label>
        <div class="hemi-row">
          <button type="button" class="hemi-btn" data-target="lat2" data-axis="lat" data-val="N" aria-pressed="true">N</button>
          <button type="button" class="hemi-btn" data-target="lat2" data-axis="lat" data-val="S" aria-pressed="false">S</button>
        </div>
        <button class="btn tiny clear-btn" id="clear-lat2">✕</button>
      </div>
      <div class="gc-seg-row">
        <div class="gc-seg" id="seg-lat2">
          <input class="seg dd" id="lat2_dd" inputmode="numeric" maxlength="2" placeholder="DD">
          <span class="sep">:</span>
          <input class="seg mm" id="lat2_mm" inputmode="numeric" maxlength="2" placeholder="MM">
          <span class="sep">:</span>
          <input class="seg ss" id="lat2_ss" inputmode="numeric" maxlength="2" placeholder="SS">
        </div>
      </div>
    </div>

    <div class="field">
      <div class="field-head">
        <label>Lon B</label>
        <div class="hemi-row">
          <button type="button" class="hemi-btn" data-target="lon2" data-axis="lon" data-val="E" aria-pressed="false">E</button>
          <button type="button" class="hemi-btn" data-target="lon2" data-axis="lon" data-val="W" aria-pressed="true">W</button>
        </div>
        <button class="btn tiny clear-btn" id="clear-lon2">✕</button>
      </div>
      <div class="gc-seg-row">
        <div class="gc-seg" id="seg-lon2">
          <input class="seg dd" id="lon2_dd" inputmode="numeric" maxlength="3" placeholder="DDD">
          <span class="sep">:</span>
          <input class="seg mm" id="lon2_mm" inputmode="numeric" maxlength="2" placeholder="MM">
          <span class="sep">:</span>
          <input class="seg ss" id="lon2_ss" inputmode="numeric" maxlength="2" placeholder="SS">
        </div>
      </div>
    </div>

  </div>

  <div class="io">
    <div class="box">
      <h4>Results</h4>
      <div class="kv" id="gcDist">Distance: — nm</div>
      <div class="kv" id="gcBear">True course: — °</div>
    </div>
    <div class="box">
      <h4>Notes</h4>
      <div class="kv">Haversine distance. Initial great-circle course at departure.</div>
    </div>
  </div>
</div>

  <div class="note" style="margin-top:6px;"></div>
  <div class="footer">
  </div>

<!-- TAS -->
<div id="panel-tas" class="panel hidden" aria-hidden="true">
  <div class="backbar">
    <button class="btn ghost" data-back>&larr; All calculators</button>
    <h3>True Airspeed (simplified)</h3>
  </div>

  <div class="toolbar">
    <button class="btn ghost" id="clear-tas">Clear</button>
  </div>

  <div class="form">
    <div class="field">
      <label>CAS or IAS (kt)</label>
      <input id="cas" type="text" placeholder="e.g., 120"/>
    </div>
    <div class="field oat-wrap">
      <label>Pressure Altitude (ft)</label>
      <div class="input-affix">
        <input id="palt" type="text" placeholder="e.g., 8000"/>
        <button type="button" class="oat-sign-btn" aria-label="Toggle sign">±</button>
      </div>
    </div>

    <div class="field oat-wrap">
      <label>OAT (°C)</label>
      <div class="input-affix">
        <input id="oatc" type="text" placeholder="e.g., 5"/>
        <button type="button" class="oat-sign-btn" aria-label="Toggle sign">±</button>
      </div>
    </div>

    <div class="field" style="align-items:flex-start;">
      <label>Compressibility? (CAS≈EAS if off)</label>
      <input id="compress" type="checkbox" />
    </div>
  </div>

  <div class="io">
    <div class="box">
      <h4>Result</h4>
      <div class="kv" id="tasOut">TAS: — kt</div>
    </div>
    <div class="box">
      <h4>Method</h4>
      <div class="kv">
        ISA temp at PA; density ratio σ; TAS ≈ EAS / √σ. Optional rough compressibility correction for CAS→EAS.
      </div>
    </div>
  </div>

  <div class="note" style="margin-top:6px;"></div>
  <div class="footer"></div>
</div>

<!-- SDT (Universal) -->
<div id="panel-sdt" class="panel hidden" aria-hidden="true">
  <div class="backbar">
    <button class="btn ghost" data-back>&larr; All calculators</button>
    <h3>Speed • Distance • Time (Universal)</h3>
  </div>

  <div class="toolbar">
    <button class="btn ghost" id="clear-sdt">Clear</button>
  </div>

  <!-- Units -->
  <div class="form">
    <div class="field">
      <label>Speed unit</label>
      <select id="SDT_u_v">
        <option value="kt">kt</option>
        <option value="mph">mph</option>
        <option value="mps">m/s</option>
      </select>
    </div>
    <div class="field">
      <label>Distance unit</label>
      <select id="SDT_u_d">
        <option value="nm">nm</option>
        <option value="sm">sm</option>
        <option value="km">km</option>
      </select>
    </div>
    <div class="field">
      <label>Time entry style</label>
      <select id="SDT_u_t">
        <option value="hhmm">hh:mm</option>
        <option value="hours">hours.decimal</option>
      </select>
    </div>
  </div>

  <details class="disclosure" open>
    <summary>
      <span>Single-Leg Solver (enter any two)</span>
      <span class="chev">›</span>
    </summary>
    <div class="content">
      <div class="form">
        <div class="field">
          <label>Speed</label>
          <input id="SDT_v" type="text" placeholder="e.g., 110"/>
        </div>
        <div class="field">
          <label>Distance</label>
          <input id="SDT_d" type="text" placeholder="e.g., 45"/>
        </div>
        <div class="field">
          <label>Time (hh:mm or hours)</label>
          <input id="SDT_t" type="text" placeholder="e.g., 0:24 or 0.4"/>
        </div>
      </div>

      <div class="io">
        <div class="box">
          <h4>Solved</h4>
          <div class="kv" id="SDT_v_out">Speed: —</div>
          <div class="kv" id="SDT_d_out">Distance: —</div>
          <div class="kv" id="SDT_t_out">Time: —</div>
        </div>
        <div class="box">
          <h4>Notes</h4>
          <div class="kv">v = d / t, d = v·t, t = d / v. Time accepts hh:mm or decimal hours.</div>
        </div>
      </div>
    </div>
  </details>

  <details class="disclosure">
    <summary>
      <span>Multi-Leg Average</span>
      <span class="chev">›</span>
    </summary>
    <div class="content">
      <div class="form">
        <div class="field"><label>Leg 1 distance</label><input id="SDT_d1" type="text" placeholder=""/></div>
        <div class="field"><label>Leg 1 time</label><input id="SDT_t1" type="text" placeholder=""/></div>
        <div class="field"><label>Leg 2 distance</label><input id="SDT_d2" type="text" placeholder=""/></div>
        <div class="field"><label>Leg 2 time</label><input id="SDT_t2" type="text" placeholder=""/></div>
        <div class="field"><label>Leg 3 distance</label><input id="SDT_d3" type="text" placeholder=""/></div>
        <div class="field"><label>Leg 3 time</label><input id="SDT_t3" type="text" placeholder=""/></div>
      </div>
      <div class="io">
        <div class="box">
          <h4>Totals</h4>
          <div class="kv" id="SDT_tot_d">Total distance: —</div>
          <div class="kv" id="SDT_tot_t">Total time: —</div>
          <div class="kv" id="SDT_avg_v">Average speed: —</div>
        </div>
        <div class="box">
          <h4>Tip</h4>
          <div class="kv">Leave any leg blank. Average speed = (Σd) / (Σt).</div>
        </div>
      </div>
    </div>
  </details>

  <details class="disclosure">
    <summary>
      <span>Relative Motion (meet/catch-up)</span>
      <span class="chev">›</span>
    </summary>
    <div class="content">
      <div class="form">
        <div class="field">
          <label>Scenario</label>
          <select id="SDT_mode">
            <option value="headon">Head-on (closing)</option>
            <option value="chase">Same direction (catch-up)</option>
          </select>
        </div>
        <div class="field"><label>Initial separation (distance)</label><input id="SDT_sep" type="text" placeholder="e.g., 20"/></div>
        <div class="field"><label>Speed A</label><input id="SDT_va" type="text" placeholder=""/></div>
        <div class="field"><label>Speed B</label><input id="SDT_vb" type="text" placeholder=""/></div>
      </div>
      <div class="io">
        <div class="box">
          <h4>Result</h4>
          <div class="kv" id="SDT_rm_t">Time to meet/catch: —</div>
          <div class="kv" id="SDT_rm_da">Distance A travels: —</div>
          <div class="kv" id="SDT_rm_db">Distance B travels: —</div>
        </div>
        <div class="box">
          <h4>Notes</h4>
          <div class="kv">
            Head-on: t = sep / (vA + vB). Chase: t = sep / (|vFast − vSlow|), distances = v•t.
          </div>
        </div>
      </div>
    </div>
  </details>

  <details class="disclosure">
    <summary>
      <span>Speed of Sound • Mach • ISA ΔT</span>
      <span class="chev">›</span>
    </summary>
    <div class="content">
      <!-- Inputs -->
      <div class="form">
        <div class="field">
          <label>Pressure Altitude (ft)</label>
          <input id="SSA_pa" type="text" placeholder="e.g., 8000"/>
        </div>
        <div class="field">
          <div style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
            <label for="SSA_oat" style="margin:0;">OAT</label>

            <!-- Buttons aligned with the label (top-right of the field) -->
            <div style="display:flex; align-items:center; gap:6px;">
              <button id="SSA_oat_minus" class="btn ghost" type="button" title="−1" style="padding:2px 10px; line-height:1.2;">−</button>
              <button id="SSA_oat_std"   class="btn ghost" type="button" title="Set to ISA at PA" style="padding:2px 10px; line-height:1.2; white-space:nowrap;">Std @ Alt</button>
              <button id="SSA_oat_plus"  class="btn ghost" type="button" title="+1" style="padding:2px 10px; line-height:1.2;">+</button>
            </div>
          </div>

          <div class="input-affix" style="width:100%; margin-top:6px;">
            <input id="SSA_oat" type="text" placeholder="e.g., 5">
            <button type="button" class="oat-sign-btn" aria-label="Toggle sign">±</button>
          </div>
        </div>
        <div class="field">
          <label>Temp unit</label>
          <select id="SSA_tu">
            <option value="C">°C</option>
            <option value="F">°F</option>
          </select>
        </div>
      </div>

      <!-- Optional Mach/TAS coupling -->
      <div class="form">
        <div class="field">
          <label>TAS (for Mach)</label>
          <input id="SSA_tas" type="text" placeholder="kt (optional)"/>
        </div>
        <div class="field">
          <label>Mach (for TAS)</label>
          <input id="SSA_mach" type="text" placeholder="M (optional)"/>
        </div>
      </div>

      <div class="io">
        <div class="box">
          <h4>Atmosphere @ altitude</h4>
          <div class="kv" id="SSA_Tisa">ISA temp: —</div>
          <div class="kv" id="SSA_dT">ISA deviation (ΔT): —</div>
        </div>
        <div class="box">
          <h4>Speed of sound</h4>
          <div style="display:grid; grid-template-columns: 1fr 1fr; gap:4px 12px;">
            <div class="kv" id="SSA_a_kt">kt: —</div>
            <div class="kv" id="SSA_a_mph">mph: —</div>
            <div class="kv" id="SSA_a_kmh">km/h: —</div>
            <div class="kv" id="SSA_a_ms">m/s: —</div>
          </div>
        </div>
      </div>

      <div class="io">
        <div class="box">
          <h4>Mach / TAS</h4>
          <div class="kv" id="SSA_mach_out">Mach (from TAS): —</div>
          <div class="kv" id="SSA_tas_out">TAS (from Mach): —</div>
        </div>
        <div class="box">
          <h4>Notes</h4>
          <div class="kv">
            a = √(γ·R·T). γ=1.4, R=287.05 J/kg·K, T is static air temp (K).
            ISA lapse = 2.0°C per 1000 ft up to ~36,000 ft, then isothermal (−56.5°C).
          </div>
        </div>
      </div>

      <div class="toolbar" style="margin-top:8px;">
        <button class="btn ghost" id="clear-ssa">Clear SoS/Mach</button>
      </div>
    </div>
  </details>

  <div class="footer">All units respect your selectors. Time accepts hh:mm or decimal hours.</div>
</div>

<!-- Wind • Angles -->
<div id="panel-wind" class="panel hidden" aria-hidden="true">
  <div class="backbar">
    <button class="btn ghost" data-back>&larr; All calculators</button>
    <h3>Wind • Angles</h3>
  </div>

  <div class="toolbar">
    <button class="btn ghost" id="clear-wind">Clear</button>
  </div>

  <details class="disclosure" open>
    <summary>
      <span>Enroute: WCA • Heading • GS</span>
      <span class="chev">›</span>
    </summary>
    <div class="content">
      <div class="form">
        <div class="field">
          <label>TAS (kt)</label>
          <input id="W_TAS" type="text" placeholder="e.g., 120"/>
        </div>
        <div class="field">
          <label>Desired course (° magnetic)</label>
          <input id="W_COURSE" type="text" placeholder="e.g., 152"/>
        </div>
        <div class="field">
          <label>Wind from (°)</label>
          <input id="W_WINDDIR" type="text" placeholder="e.g., 340"/>
        </div>
        <div class="field">
          <label>Wind speed (kt)</label>
          <input id="W_WINDSPEED" type="text" placeholder="e.g., 14"/>
        </div>
        <div class="field">
          <label>Wind given as</label>
          <select id="W_WINDREF">
            <option value="mag">Magnetic</option>
            <option value="true">True (aloft forecast)</option>
          </select>
        </div>
        <div class="field" id="W_VARFIELD" style="display:none">
          <label>Variation (E+/W−, °)</label>
          <div class="input-affix">
            <input id="W_VAR" type="text" placeholder="e.g. -8"/>
            <button type="button" class="oat-sign-btn" aria-label="Toggle sign">±</button>
          </div>
        </div>
      </div>

      <div class="io">
        <div class="box">
          <h4>Results</h4>
          <div class="kv" id="W_wca">WCA: — ° (L/R)</div>
          <div class="kv" id="W_hdgM">Heading to fly (Mag): — °</div>
          <div class="kv" id="W_gs">Groundspeed: — kt</div>
        </div>
      </div>
    </div>
  </details>

  <details class="disclosure">
    <summary>
      <span>Runway: head/tailwind & crosswind</span>
      <span class="chev">›</span>
    </summary>
    <div class="content">
      <div class="form">
        <div class="field">
          <label>Runway / heading (deg)</label>
          <input id="W_RWY" type="text" placeholder="e.g., 27 or 270"/>
        </div>
        <div class="field">
          <label>Given as</label>
          <select id="W_RWY_REF">
            <option value="mag">Magnetic</option>
            <option value="true">True</option>
          </select>
        </div>
        <div class="field">
          <label>Variation (E+/W−, °) — optional</label>
          <div class="input-affix">
            <input id="W_VAR2" type="text" placeholder="e.g. 7 or -7"/>
            <button type="button" class="oat-sign-btn" aria-label="Toggle sign">±</button>
          </div>
        </div>
        <div class="field">
          <label>Wind from (° true)</label>
          <input id="W_WF2" type="text" placeholder="e.g., 210"/>
        </div>
        <div class="field">
          <label>Wind speed (kt)</label>
          <input id="W_W2" type="text" placeholder="e.g., 15"/>
        </div>
        <div class="field">
          <label>Max crosswind (kt) — optional</label>
          <input id="W_MAXX" type="text" placeholder="e.g., 15"/>
        </div>
      </div>

      <div class="io">
        <div class="box">
          <h4>Components</h4>
          <div class="kv" id="W_head">Head/Tail: — kt</div>
          <div class="kv" id="W_cross">Crosswind: — kt (L/R)</div>
          <div class="kv" id="W_limit">Limit check: —</div>
        </div>
        <div class="box">
          <h4>Notes</h4>
          <div class="kv">
            Angle uses wind-from vs runway direction. Positive crosswind = from right (crab left); negative = from left (crab right).
          </div>
        </div>
      </div>
    </div>
  </details>
</div>

<!-- Pivotal Altitude -->
<div id="panel-pivalt" class="panel hidden" aria-hidden="true">
  <div class="backbar">
    <button class="btn ghost" data-back>&larr; All calculators</button>
    <h3>Pivotal Altitude</h3>
  </div>

  <div class="toolbar">
    <button class="btn ghost" id="PA_CLEAR">Clear</button>
  </div>

  <details class="disclosure" open>
    <summary><span>Inputs</span><span class="chev">›</span></summary>
    <div class="content">
      <div class="form">
        <!-- 1) Groundspeed direct -->
        <div class="field">
          <label>Groundspeed (kt)</label>
          <input id="PA_GS" inputmode="decimal" placeholder="optional override (e.g., 95)"/>
        </div>

        <!-- 2) IAS with right-justified presets in label row -->
        <div class="field">
          <div class="label-row">
            <label>IAS (kt)</label>
            <div class="pillrow">
              <button class="pill" type="button" data-ias="90">90</button>
              <button class="pill" type="button" data-ias="100">100</button>
            </div>
          </div>
          <input id="PA_IAS" inputmode="decimal" placeholder="90 or 100"/>
        </div>

        <!-- 3) Heading with right-justified reciprocal in label row -->
        <div class="field">
          <div class="label-row">
            <label>Heading (°)</label>
            <button class="pill action" type="button" id="PA_HDG_RECIP">Reciprocal</button>
          </div>
          <input id="PA_HDG" inputmode="numeric" placeholder="e.g., 180"/>
        </div>

        <!-- 4) Wind from / 5) Wind speed -->
        <div class="field">
          <label>Wind from (°)</label>
          <input id="PA_WIND_FROM" inputmode="numeric" placeholder="e.g., 230"/>
        </div>

        <div class="field">
          <label>Wind speed (kt)</label>
          <input id="PA_W" inputmode="decimal" placeholder="e.g., 12"/>
        </div>

        <!-- 6) Ground elevation (MSL) -->
        <div class="field">
          <label>Ground elevation at pylons (MSL ft)</label>
          <input id="PA_GROUND_MSL" inputmode="decimal" placeholder="e.g., 900"/>
        </div>

        <!-- Live button (only shown when required inputs are present) -->
        <div class="field" id="PA_LIVE_FIELD" style="display:none;">
          <button class="btn primary" type="button" id="PA_LIVE_OPEN">Live</button>
        </div>

      </div>

      <!-- Intermediates -->
      <div class="io">
        <div class="box">
          <h4>Intermediates</h4>
          <div class="kv">
            <span>Wind component (±): </span>
            <strong class="num" id="PA_WC_NUM">—</strong><span> kt</span>
          </div>
          <div class="kv">
            <span>GS (from IAS+wind): </span>
            <strong class="num" id="PA_GS_CALC_NUM">—</strong><span> kt</span>
          </div>
          <div class="kv">
            <span>GS used: </span>
            <strong class="num" id="PA_GS_USED_NUM">—</strong><span> kt</span>
          </div>
        </div>

        <!-- Results with mini vertical range -->
        <div class="box">
          <h4>Result</h4>

          <div class="result-flex">
            <div class="result-left">
              <div class="kv"><span class="lead">Pivotal altitude:</span></div>
              <div class="kv">
                <span>(AGL): </span>
                <strong class="num" id="PA_OUT_AGL_NUM">—</strong><span> ft</span>
              </div>
              <div class="kv">
                <span>Target MSL: </span>
                <strong class="num" id="PA_OUT_MSL_NUM">—</strong><span> ft</span>
              </div>
            </div>

            <div class="range-mini" aria-label="Pivotal altitude range">
              <div class="label">
                <div class="row">
                  <span>Max:</span>
                  <strong class="num" id="PA_MAX_MINI_NUM">—</strong>
                  <span>ft</span>
                </div>
                <div class="msl-sub" id="PA_MAX_MSL">(— ft MSL)</div>
              </div>

              <div class="line" id="PA_RANGE_LINE">
                <div class="marker" id="PA_MARKER" title="Current pivotal altitude"></div>
              </div>

              <div class="label">
                <div class="msl-sub" id="PA_MIN_MSL">(— ft MSL)</div>
                <div class="row">
                  <span>Min:</span>
                  <strong class="num" id="PA_MIN_MINI_NUM">—</strong>
                  <span>ft</span>
                </div>
              </div>
            </div>

          </div>

          <div class="note" style="margin-top:6px;">
            Formula: Pivotal Altitude (ft) = GS² / 11.3 (GS in knots).
          </div>
        </div>
      </div>
    </div>
  </details>

  <div class="footer">
    Training/planning aid.
  </div>
</div>

<!-- Altitudes -->
<div id="panel-altitudes" class="panel hidden" aria-hidden="true">
  <div class="backbar">
    <button class="btn ghost" data-back>&larr; All calculators</button>
    <h3>Altitudes</h3>
  </div>

  <div class="toolbar">
    <button class="btn ghost" id="clear-alt">Clear</button>
  </div>

    <div class="content">
      <div class="form">
        <div class="field">
          <label>Indicated Altitude (ft)</label>
          <div class="input-affix">
            <input id="A_IND" type="text" placeholder="e.g., 4500">
            <button type="button" class="oat-sign-btn" aria-label="Toggle sign">±</button>
          </div>
        </div>
        <div class="field">
          <label>Field Elevation (ft)</label>
          <div class="input-affix">
            <input id="A_FLD" type="text" placeholder="e.g., 1200">
            <button type="button" class="oat-sign-btn" aria-label="Toggle sign">±</button>
          </div>
        </div>
        <!-- Altimeter Setting with header-right unit pills -->
        <div class="field">
          <label for="A_ALTSET">Altimeter Setting</label>
          <input id="A_ALTSET" type="text" placeholder="e.g. 29.92"/>

          <div id="A_ALTU_PILLS" class="mode-pills centered" role="tablist" aria-label="Altimeter unit">
            <button type="button" class="btn secondary active" data-altu="inHg" aria-pressed="true">inHg</button>
            <button type="button" class="btn secondary" data-altu="hPa" aria-pressed="false">hPa</button>
          </div>
        </div>

        <div class="field">
          <label for="A_SRC">I have</label>
          <select id="A_SRC">
            <option value="alt">Altimeter setting</option>
            <option value="pa">Pressure Altitude (override)</option>
          </select>
        </div>
        <div class="field" id="A_PA_FIELD" style="display:none">
          <label for="A_PA_IN">Pressure Altitude (ft)</label>
          <input id="A_PA_IN" type="text" placeholder="e.g., 8000"/>
        </div>
        <div class="field">
          <label for="A_OAT">OAT</label>
          <div class="input-affix">
            <input id="A_OAT" type="text" placeholder="e.g. 15">
            <button type="button" class="oat-sign-btn" aria-label="Toggle sign">±</button>
          </div>

          <div id="A_UNIT_PILLS" class="mode-pills centered" role="tablist" aria-label="Temperature unit">
            <button type="button" class="btn secondary active" data-tunit="C" aria-pressed="true">°C</button>
            <button type="button" class="btn secondary" data-tunit="F" aria-pressed="false">°F</button>
          </div>
        </div>
      </div>

      <div class="io">
        <div class="box">
          <h4>Results</h4>
          <div class="kv" id="A_PA">Pressure Altitude: — ft</div>
          <div class="kv" id="A_DA">Density Altitude: — ft</div>
          <div class="kv" id="A_TA">True Altitude: — ft</div>
        </div>
      </div>
    </div>
</div>

<div id="panel-conversions" class="panel hidden" aria-hidden="true">
  <div class="backbar">
    <button class="btn ghost" data-back>&larr; All calculators</button>
    <h3>Conversions</h3>
  </div>

  <section id="av-conversions">
    <div class="wrap">
      <div class="card">

        <!-- DISTANCE / LENGTH -->
        <details class="disclosure" data-sec>
          <summary>
            <span class="sum-left">Distance &amp; Length<button class="clear-btn" type="button">Clear</button>
            </span>
            <span class="chev">›</span>
          </summary>
          <div class="content">
            <div class="grid" data-group="linear" data-base="m" data-map='{"NM":1852,"SM":1609.344,"km":1000,"m":1,"ft":0.3048}'>
              <div class="field"><label>Nautical miles (NM)</label><input inputmode="decimal" data-unit="NM" placeholder="e.g., 12"/></div>
              <div class="field"><label>Statute miles (SM)</label><input inputmode="decimal" data-unit="SM" placeholder="e.g., 13.8"/></div>
              <div class="field"><label>Kilometers (km)</label><input inputmode="decimal" data-unit="km" placeholder="e.g., 22.2"/></div>
              <div class="field"><label>Meters (m)</label><input inputmode="decimal" data-unit="m" placeholder="e.g., 1000"/></div>
              <div class="field"><label>Feet (ft)</label><input inputmode="decimal" data-unit="ft" placeholder="e.g., 3281"/></div>
            </div>
          </div>
        </details>

        <!-- SPEED -->
        <details class="disclosure" data-sec>
          <summary>
            <span class="sum-left">Speed<button class="clear-btn" type="button">Clear</button>
            </span>
            <span class="chev">›</span>
          </summary>
          <div class="content">
            <div class="grid" data-group="speed">
              <div class="field"><label>Knots (kt)</label><input inputmode="decimal" data-speed="kt" placeholder="e.g., 120"/></div>
              <div class="field"><label>Miles per hour (mph)</label><input inputmode="decimal" data-speed="mph" placeholder="e.g., 138"/></div>
              <div class="field"><label>Kilometers per hour (km/h)</label><input inputmode="decimal" data-speed="kmh" placeholder="e.g., 222"/></div>
              <div class="field"><label>Meters per second (m/s)</label><input inputmode="decimal" data-speed="mps" placeholder="e.g., 61.7"/></div>
              <div class="field" style="display:flex; flex-direction:column;">
                <label>Mach</label>
                <div class="input-affix" style="margin-bottom:4px;">
                  <input id="CNV_OAT" inputmode="decimal" placeholder="OAT °C (for Mach)">
                  <button type="button" class="oat-sign-btn" aria-label="Toggle sign">±</button>
                </div>
                <input inputmode="decimal" data-speed="mach" placeholder="e.g., 0.78">
              </div>
            </div>
            <div class="note">Mach uses speed of sound from OAT (a = √(γ·R·T)). If OAT is empty, 15 °C is assumed.</div>
          </div>
        </details>

        <!-- VERTICAL SPEED -->
        <details class="disclosure" data-sec>
          <summary>
            <span class="sum-left">Vertical Speed<button class="clear-btn" type="button">Clear</button>
            </span>
            <span class="chev">›</span>
          </summary>
          <div class="content">
            <div class="grid" data-group="linear" data-base="mps" data-map='{"fpm":0.00508,"fps":0.3048,"mps":1}'>
              <div class="field"><label>Feet per minute (fpm)</label><input inputmode="decimal" data-unit="fpm" placeholder="e.g., 500"/></div>
              <div class="field"><label>Feet per second (ft/s)</label><input inputmode="decimal" data-unit="fps" placeholder="e.g., 8.3"/></div>
              <div class="field"><label>Meters per second (m/s)</label><input inputmode="decimal" data-unit="mps" placeholder="e.g., 2.5"/></div>
            </div>
          </div>
        </details>

        <!-- TEMPERATURE -->
        <details class="disclosure" data-sec>
          <summary>
            <span class="sum-left">Temperature<button class="clear-btn" type="button">Clear</button>
            </span>
            <span class="chev">›</span>
          </summary>
          <div class="content">
            <div class="grid" data-group="temp">
              <!-- Celsius -->
              <div class="field">
                <label>°C</label>
                <div class="input-affix">
                  <input inputmode="decimal" data-unit="C" placeholder="e.g., 15">
                  <button type="button" class="oat-sign-btn" aria-label="Toggle sign">±</button>
                </div>
              </div>
              <!-- Fahrenheit -->
              <div class="field">
                <label>°F</label>
                <div class="input-affix">
                  <input inputmode="decimal" data-unit="F" placeholder="e.g., 59">
                  <button type="button" class="oat-sign-btn" aria-label="Toggle sign">±</button>
                </div>
              </div>
              <!-- Kelvin -->
              <div class="field">
                <label>K (Kelvin)</label>
                <div class="input-affix">
                  <input inputmode="decimal" data-unit="K" placeholder="e.g., 288.15">
                  <button type="button" class="oat-sign-btn" aria-label="Toggle sign">±</button>
                </div>
              </div>
            </div>
          </div>
        </details>

        <!-- PRESSURE -->
        <details class="disclosure" data-sec>
          <summary>
            <span class="sum-left">Pressure<button class="clear-btn" type="button">Clear</button>
            </span>
            <span class="chev">›</span>
          </summary>
          <div class="content">
            <div class="grid" data-group="linear" data-base="Pa" data-map='{"inHg":3386.389,"hPa":100,"mmHg":133.322368,"psi":6894.757293,"Pa":1}'>
              <div class="field"><label>inHg</label><input inputmode="decimal" data-unit="inHg" placeholder="e.g., 29.92"/></div>
              <div class="field"><label>hPa (mbar)</label><input inputmode="decimal" data-unit="hPa" placeholder="e.g., 1013.25"/></div>
              <div class="field"><label>mmHg</label><input inputmode="decimal" data-unit="mmHg" placeholder="e.g., 760"/></div>
              <div class="field"><label>psi</label><input inputmode="decimal" data-unit="psi" placeholder="e.g., 14.696"/></div>
            </div>
            <div class="note">Static conversions only (no altimetry logic).</div>
          </div>
        </details>

        <!-- FUEL (VOLUME / MASS / FLOW) -->
        <details class="disclosure" data-sec>
          <summary>
            <span class="sum-left">Fuel (Volume ↔ Mass ↔ Flow)<button class="clear-btn" type="button">Clear</button>
            </span>
            <span class="chev">›</span>
          </summary>
          <div class="content">
            <div class="row">
              <div class="field" style="min-width:220px">
                <label>Fuel type (lb/US gal)</label>
                <select id="CNV_FUEL_TYPE">
                  <option value="6.00">Avgas ~6.00</option>
                  <option value="6.70">Jet A ~6.70</option>
                  <option value="6.79">Jet A-1 ~6.79</option>
                  <option value="6.50">Jet B ~6.50</option>
                  <option value="custom">Custom…</option>
                </select>
              </div>
              <div class="field" id="CNV_FUEL_DENS_FIELD" style="min-width:220px; display:none">
                <label>Custom density (lb/US gal)</label>
                <input id="CNV_FUEL_DENS" inputmode="decimal" placeholder="e.g., 6.2"/>
              </div>
            </div>

            <div class="grid" data-group="fuel">
              <div class="field"><label>US gallons (gal)</label><input inputmode="decimal" data-fuel="galUS" placeholder="e.g., 40"/></div>
              <div class="field"><label>Liters (L)</label><input inputmode="decimal" data-fuel="L" placeholder="e.g., 151.4"/></div>
              <div class="field"><label>Imperial gallons (imp gal)</label><input inputmode="decimal" data-fuel="galImp" placeholder="e.g., 33.3"/></div>
              <div class="field"><label>Pounds (lb)</label><input inputmode="decimal" data-fuel="lb" placeholder="e.g., 240"/></div>
              <div class="field"><label>Kilograms (kg)</label><input inputmode="decimal" data-fuel="kg" placeholder="e.g., 108.9"/></div>
            </div>

            <div class="grid" data-group="fuelflow" style="margin-top:8px">
              <div class="field"><label>GPH (US gal/hr)</label><input inputmode="decimal" data-flow="gph" placeholder="e.g., 8.5"/></div>
              <div class="field"><label>LPH (L/hr)</label><input inputmode="decimal" data-flow="lph" placeholder="e.g., 32.2"/></div>
              <div class="field"><label>PPH (lb/hr)</label><input inputmode="decimal" data-flow="pph" placeholder="e.g., 51"/></div>
              <div class="field"><label>kg/h</label><input inputmode="decimal" data-flow="kgh" placeholder="e.g., 23.1"/></div>
            </div>

            <div class="note">Density varies with temp; defaults approximate 15 °C.</div>
          </div>
        </details>

        <!-- CLIMB / DESCENT GRADIENT -->
        <details class="disclosure" data-sec>
          <summary>
            <span class="sum-left">Climb/Descent Gradient<button class="clear-btn" type="button">Clear</button>
            </span>
            <span class="chev">›</span>
          </summary>
          <div class="content">
            <div class="row">
              <div class="field" style="width:160px"><label>Groundspeed (kt)</label><input id="CNV_GS" inputmode="decimal" placeholder="e.g., 120"/></div>
            </div>
            <div class="grid" data-group="gradient">
              <div class="field"><label>Gradient (%)</label><input inputmode="decimal" data-grad="pct" placeholder="e.g., 3.0"/></div>
              <div class="field"><label>Degrees (°)</label><input inputmode="decimal" data-grad="deg" placeholder="e.g., 1.7"/></div>
              <div class="field"><label>ft / NM</label><input inputmode="decimal" data-grad="ftnm" placeholder="e.g., 182.3"/></div>
              <div class="field"><label>m / km</label><input inputmode="decimal" data-grad="mkm" placeholder="e.g., 30"/></div>
              <div class="field"><label>fpm @ GS</label><input inputmode="decimal" data-grad="fpm" placeholder="e.g., 364"/></div>
            </div>
            <div class="note">1% = 60.761 ft/NM = 10 m/km. fpm = (ft/NM) × (GS kt ÷ 60).</div>
          </div>
        </details>

        <!-- WEIGHT / MASS / FORCE -->
        <details class="disclosure" data-sec>
          <summary>
            <span class="sum-left">Weight / Mass / Force<button class="clear-btn" type="button">Clear</button>
            </span>
            <span class="chev">›</span>
          </summary>
          <div class="content">
            <div class="grid" data-group="weight">
              <div class="field"><label>Pounds (lb)</label><input inputmode="decimal" data-weight="lb" placeholder="e.g., 2550"/></div>
              <div class="field"><label>Kilograms (kg)</label><input inputmode="decimal" data-weight="kg" placeholder="e.g., 1156.7"/></div>
              <div class="field"><label>Newtons (N)</label><input inputmode="decimal" data-weight="N" placeholder="(kg×9.80665)"/></div>
            </div>
            <div class="note">lb↔kg is mass (1 lb = 0.45359237 kg). N is force via N = kg × 9.80665.</div>
          </div>
        </details>

        <!-- TIME & TIME ZONES -->
        <details class="disclosure" data-sec>
          <summary>
            <span class="sum-left">Time &amp; Time Zones<button class="clear-btn" type="button">Clear</button>
            </span>
            <span class="chev">›</span>
          </summary>
          <div class="content">
            <!-- Decimal time -->
            <div class="muted" style="margin-bottom:6px">Decimal ↔ clock time (24-hour)</div>
            <div class="grid" data-group="time">
              <div class="field"><label>Decimal hours (h)</label><input inputmode="decimal" data-time="decH" placeholder="e.g., 2.75"/></div>
              <div class="field"><label>HH:MM</label><input inputmode="numeric" data-time="hhmm" placeholder="e.g., 2:45"/></div>
              <div class="field"><label>Decimal minutes (min)</label><input inputmode="decimal" data-time="decM" placeholder="e.g., 7.5"/></div>
              <div class="field"><label>MM:SS</label><input inputmode="numeric" data-time="mmss" placeholder="e.g., 7:30"/></div>
            </div>

            <div class="hr" style="margin:12px 0"></div>
              <!-- Time zones -->
              <div class="tz-header" style="margin-bottom:6px; display:flex; align-items:center; justify-content:space-between;">
                <div class="muted">Convert local time between zones (optionally apply DST)</div>
                <button class="tz-swap-btn" type="button" data-tz="swap" title="Swap">Swap</button>
              </div>

              <div class="grid" data-group="tz">
                <div class="field">
                  <label>Local time (HH:MM)</label>
                  <input inputmode="numeric" data-tz="local" placeholder="e.g., 14:30"/>
                </div>
                <div class="field">
                  <label>From zone</label>
                  <select data-tz="from"></select>
                </div>
                <div class="field">
                  <label>To zone</label>
                  <select data-tz="to"></select>
                </div>
                <div class="field">
                  <label>Result</label>
                  <input data-tz="out" placeholder="—" readonly/>
                </div>
              </div>

            <div class="row" style="margin-top:8px">
              <div class="field" style="width:160px"><label>From in DST?</label>
                <select data-tz="fromDst"><option value="auto">Auto</option><option value="yes">Yes</option><option value="no">No</option></select>
              </div>
              <div class="field" style="width:160px"><label>To in DST?</label>
                <select data-tz="toDst"><option value="auto">Auto</option><option value="yes">Yes</option><option value="no">No</option></select>
              </div>
            </div>

            <div class="tz-info-note">
              From: <span data-tz="from">KJFK</span> &nbsp; | &nbsp;
              To: <span data-tz="to">KLAX</span>
            </div>

            <div class="note">Offsets are standard (non-DST) unless a DST toggle is applied. Rules vary by locale; verify operational times with NOTAMs/ATC as needed.</div>
          </div>
        </details>

      </div>
    </div>
  </section>
</div>

<!-- IFR FPM / FPNM / Angles / TOD -->
<div id="panel-fpm" class="panel hidden" aria-hidden="true">
  <div class="backbar">
    <button class="btn ghost" data-back>&larr; All calculators</button>
    <h3>IFR Gradients: FPM • ft/nm • Angles • TOD</h3>
  </div>

  <div class="toolbar">
    <button class="btn ghost" id="clear-fpm">Clear</button>
  </div>

  <!-- Section A: Core conversion (GS + Angle or ft/nm → FPM etc.) -->
  <details class="disclosure" open>
    <summary><span>Conversions: GS • Angle • ft/nm • FPM</span><span class="chev">›</span></summary>
    <div class="content">
      <div class="form">
        <div class="field">
          <label>Groundspeed (kt)</label>
          <input id="FPM_GS" type="text" placeholder="e.g., 120"/>
        </div>
        <div class="field">
          <label>Path angle (°)</label>
          <input id="FPM_ANGLE" type="text" placeholder="e.g., 3.0"/>
        </div>
        <div class="field">
          <label>Gradient (ft / nm)</label>
          <input id="FPM_FPNM" type="text" placeholder="e.g., 318"/>
        </div>
      </div>

      <div class="io">
        <div class="box">
          <h4>Outputs</h4>
          <div class="kv" id="FPM_OUT_FPM">VSI (FPM): —</div>
          <div class="kv" id="FPM_OUT_FPNM">ft / nm: —</div>
          <div class="kv" id="FPM_OUT_ANGLE">Angle: — °</div>
          <div class="kv" id="FPM_OUT_PCT">Gradient: — %</div>
        </div>
        <div class="box">
          <h4>Notes</h4>
          <div class="kv">
            FPM = (ft/nm) × GS / 60.  ft/nm = 6076.12 × tan(θ).  
            For 3°: ft/nm ≈ 318 and FPM ≈ 5.3 × GS (rule of thumb GS×5).
          </div>
        </div>
      </div>
    </div>
  </details>

  <!-- Section B: Meet a required restriction / gradient -->
  <details class="disclosure">
    <summary><span>Required gradient / VSI for a restriction</span><span class="chev">›</span></summary>
    <div class="content">
      <div class="form">
        <div class="field">
          <label>GS (kt)</label>
          <input id="FPM_REQ_GS" type="text" placeholder="e.g., 140"/>
        </div>
        <div class="field">
          <label>Distance to fix (nm)</label>
          <input id="FPM_REQ_D" type="text" placeholder="e.g., 9.5"/>
        </div>
      </div>

      <div class="form">
        <div class="field">
          <label>Current altitude (ft)</label>
          <input id="FPM_REQ_ALT_CURR" type="text" placeholder="e.g., 8000"/>
        </div>
        <div class="field">
          <label>Crossing altitude (ft)</label>
          <input id="FPM_REQ_ALT_XING" type="text" placeholder="e.g., 5000"/>
        </div>
        <div class="field">
          <label>Your VSI capability (FPM) — optional</label>
          <input id="FPM_REQ_CAP" type="text" placeholder="e.g., 900"/>
        </div>
      </div>

      <div class="io">
        <div class="box">
          <h4>Required</h4>
          <div class="kv" id="FPM_REQ_DIR">Direction: —</div>
          <div class="kv" id="FPM_REQ_OUT_FPNM">ft / nm: —</div>
          <div class="kv" id="FPM_REQ_OUT_FPM">VSI (FPM): —</div>
          <div class="kv" id="FPM_REQ_OUT_ANGLE">Angle: — °</div>
          <div class="kv" id="FPM_REQ_OUT_PCT">Gradient: — %</div>
          <div class="kv" id="FPM_REQ_PASS">Capability check: —</div>
        </div>
      </div>
    </div>
  </details>
  
  <!-- Section D: Inline GS helper (optional) -->
  <details class="disclosure">
    <summary><span>Optional: compute GS from TAS & wind</span><span class="chev">›</span></summary>
    <div class="content">
      <div class="form">
        <div class="field"><label>TAS (kt)</label><input id="FPM_H_TAS" type="text" placeholder="e.g., 120"/></div>
        <div class="field"><label>Course (°)</label><input id="FPM_H_TC" type="text" placeholder="e.g., 085"/></div>
        <div class="field"><label>Wind from (° true)</label><input id="FPM_H_WDIR" type="text" placeholder="e.g., 320"/></div>
        <div class="field"><label>Wind speed (kt)</label><input id="FPM_H_WSPD" type="text" placeholder="e.g., 18"/></div>
      </div>
      <div class="io">
        <div class="box">
          <h4>GS</h4>
          <div class="kv" id="FPM_H_GS_OUT">GS: — kt</div>
        </div>
      </div>
      <div class="toolbar">
        <button class="btn" id="FPM_H_APPLY">Apply GS to fields above</button>
      </div>
    </div>
  </details>
</div>

<div id="panel-clouds" class="panel hidden" aria-hidden="true">
  <div class="backbar">
    <button class="btn ghost" data-back>&larr; All calculators</button>
    <h3>Clouds — Base, Top, Thickness</h3>
  </div>

  <div class="toolbar">
    <button class="btn ghost" id="CLOUDS_CLEAR">Clear</button>
  </div>

  <div class="section">
    <h4 class="section-title">Inputs</h4>
    <div class="content">
      <div class="form">

        <div class="field">
          <label>Units</label>
          <select id="CL_UNITS">
            <option value="C">°C</option>
            <option value="F">°F</option>
          </select>
        </div>

        <div class="field">
          <label>Field elevation (ft MSL)</label>
          <input id="CL_FLD_FT" type="text" placeholder="e.g. 1200"/>
        </div>

        <div class="field">
          <label>Surface temperature</label>
          <div class="input-affix">
            <input id="CL_T" type="text" placeholder="e.g. 25"/>
            <button type="button" tabindex="-1" class="oat-sign-btn" aria-label="Toggle sign">±</button>
          </div>
        </div>

        <div class="field">
          <label>Surface dewpoint</label>
          <div class="input-affix">
            <input id="CL_TD" type="text" placeholder="e.g. 15"/>
            <button type="button" tabindex="-1" class="oat-sign-btn" aria-label="Toggle sign">±</button>
          </div>
        </div>

        <div class="field">
          <label>Environmental lapse rate (°C / 1000 ft)</label>
          <input id="CL_LR" type="text" placeholder="e.g. 2.0 (ISA≈1.98)" value="2.0"/>
        </div>

        <div class="field">
          <label>Top method</label>
          <select id="CL_TOP_METHOD">
            <option value="none">None (base only)</option>
            <option value="ttop">Use temp at cloud top</option>
            <option value="freeze">Use freezing level (rough)</option>
          </select>
        </div>

        <div class="field" id="CL_TTOP_FIELD" style="display:none">
          <label>Temperature at cloud top</label>
          <div class="input-affix">
            <input id="CL_TTOP" type="text" placeholder="e.g. -10"/>
            <button type="button" class="oat-sign-btn" data-sign="CL_TTOP" aria-label="Toggle sign">±</button>
          </div>
        </div>

        <div class="field" id="CL_FREEZE_FIELD" style="display:none">
          <label>Freezing level (ft MSL)</label>
          <input id="CL_FREEZE_FT" type="text" placeholder="e.g. 7000"/>
        </div>

      </div>
    </div>
  </div>

  <div class="section">
    <h4 class="section-title">Results</h4>
    <div class="content">
      <div class="io">
        <div class="box">
          <h4>Cloud base (LCL / CCL)</h4>
          <div class="kv">Spread used: <span id="CL_SPREAD">—</span></div>
          <div class="kv">Base (AGL): <span id="CL_BASE_AGL">—</span> ft</div>
          <div class="kv">Base (MSL): <span id="CL_BASE_MSL">—</span> ft</div>
        </div>

        <div class="box">
          <h4>Cloud tops (optional)</h4>
          <div class="kv">Top (MSL): <span id="CL_TOP_MSL">—</span> ft</div>
          <div class="kv">Thickness: <span id="CL_THICK">—</span> ft</div>
        </div>
      </div>

      <div class="note" style="margin-top:8px">
        Rule of thumb: LCL ≈ <strong>400 ft per °C</strong> of surface T–Td spread (≈125 m/°C).
        Tops from lapse rate assume a roughly linear profile; convective tops can exceed this.
        Planning aid only.
      </div>
    </div>
  </div>

  <details class="disclosure">
    <summary><span>Reverse: required dewpoint for a desired base</span><span class="chev">›</span></summary>
    <div class="content">
      <div class="form">
        <div class="field">
          <label>Desired base (AGL ft)</label>
          <input id="CL_DESIRED_BASE" type="text" placeholder="e.g. 3000"/>
        </div>
      </div>
      <div class="io">
        <div class="box">
          <h4>Needed</h4>
          <div class="kv">Required dewpoint: <span id="CL_REQ_TD">—</span></div>
        </div>
      </div>
    </div>
  </details>

  <div class="footer">Training/planning aid.</div>
</div>

<div id="panel-hydro" class="panel hidden" aria-hidden="true">
  <div class="backbar">
    <button class="btn ghost" data-back>&larr; All calculators</button>
    <h3>Hydroplaning — Dynamic Vp</h3>
  </div>

  <div class="toolbar">
    <button class="btn ghost" id="HY_CLEAR">Clear</button>
  </div>

  <!-- Inputs (no dropdowns) -->
  <div class="section">
    <h4 class="section-title">Inputs</h4>
    <div class="content">
      <div class="form">
        <div class="field">
          <label>Tire pressure (psi)</label>
          <input id="HY_PSI" type="text" inputmode="decimal" placeholder="e.g. 42">
        </div>

        <div class="field">
          <label>Tire pressure (kPa)</label>
          <input id="HY_KPA" type="text" inputmode="decimal" placeholder="optional — e.g. 290">
        </div>

        <div class="field">
          <label>Approach / touchdown ground speed (kt)</label>
          <input id="HY_GS" type="text" inputmode="decimal" placeholder="optional — e.g. 65">
        </div>
      </div>
    </div>
  </div>

  <!-- Results (always visible) -->
  <div class="section">
    <h4 class="section-title">Results</h4>
    <div class="content">
      <div class="io">
        <div class="box">
          <h4>Hydroplaning Speed</h4>
          <div class="kv">Safe speed (Vp): <span id="HY_VP">—</span> kt</div>
        </div>

        <div class="box">
          <h4>Your Check</h4>
          <div class="kv">Your speed: <span id="HY_GS_OUT">—</span> kt</div>
          <div class="kv">Risk level: <span id="HY_REL">—</span></div>
        </div>
      </div>

      <div class="note" style="margin-top:8px">
        Vp is where the tires can start riding on water.  
        If your speed is below Vp → generally safe.  
        Near or above Vp → higher chance of hydroplaning.
      </div>
    </div>
  </div>

  <div class="footer">
    Uses the standard dynamic hydroplaning estimate: <strong>Vp ≈ 9 · √(psi)</strong> (knots).  
    Compare your ground speed to Vp; risk increases as GS approaches Vp on water-contaminated surfaces.  
    Training/planning aid only.  
    <br><br>
    Notes: formula assumes dynamic hydroplaning on a water film. Viscous/reverted rubber modes and groove effects are not modeled.
  </div>
</div>

<div id="panel-sixty" class="panel hidden" aria-hidden="true">
  <div class="backbar">
    <button class="btn ghost" data-back>&larr; All calculators</button>
    <h3>60-to-1 Rule — Universal</h3>
  </div>

  <div class="toolbar">
    <button class="btn ghost" id="clear-sixty">Clear</button>
  </div>

  <!-- Inputs -->
  <div class="form" style="margin-top:8px;">
    <div class="field">
      <label>Desired course (° true)</label>
      <input id="S60_course" type="text" placeholder="e.g., 090">
    </div>

    <div class="field">
      <label>Distance flown along planned leg (nm)</label>
      <input id="S60_dist" type="text" placeholder="for track-error calc">
    </div>

    <div class="field">
      <label>Lateral off-course (nm)</label>
      <input id="S60_off" type="text" placeholder="your cross-track">
    </div>

    <div class="field">
      <label>Track error (°)</label>
      <input id="S60_te_in" type="text" placeholder="optional input">
    </div>

    <div class="field">
      <label>Intercept angle desired (°)</label>
      <input id="S60_int_in" type="text" placeholder="optional input">
    </div>

    <div class="field">
      <label>Rejoin distance ahead (nm)</label>
      <input id="S60_fix_in" type="text" placeholder="or let it compute">
    </div>

    <div class="field">
      <label>Groundspeed (kt)</label>
      <input id="S60_gs" type="text" placeholder="for time to rejoin">
    </div>

    <div class="field">
      <label>Side of course</label>
      <div class="pillrow" id="S60_side_row">
        <button type="button" class="pill" data-side="L">Left</button>
        <button type="button" class="pill action" data-side="R">Right</button>
      </div>
    </div>
  </div>

  <!-- Outputs (all in one box) -->
  <div class="io">
    <div class="box">
      <h4>Results</h4>
      <div class="kv" id="S60_out_te">Track error: — °</div>
      <div class="kv" id="S60_out_off">Off-course: — nm</div>
      <div class="kv" id="S60_out_int">Intercept angle: — °</div>
      <div class="kv" id="S60_out_fix">Distance to rejoin: — nm</div>
      <div class="kv" id="S60_out_hdgs">Headings — Parallel: — ° • Intercept: — °</div>
      <div class="kv" id="S60_out_turn">Turn: —</div>
      <div class="kv" id="S60_out_time">Time to rejoin: — min</div>
    </div>
  </div>
</div>

<div id="panel-toc-tod" class="panel hidden" aria-hidden="true">
  <div class="backbar">
    <button class="btn ghost" data-back>&larr; All calculators</button>
    <h3>TOC &amp; TOD</h3>
  </div>

  <div class="toolbar">
    <button class="btn ghost" id="clear-toc-tod">Clear</button>
  </div>

  <!-- Inputs -->
  <div class="form">
    <div class="field">
      <label>Altitude Now (ft MSL)</label>
      <input id="toc_curAlt" inputmode="numeric" />
    </div>
    <div class="field">
      <label>Cruise Altitude (ft MSL)</label>
      <input id="toc_cruiseAlt" inputmode="numeric" />
    </div>
    <div class="field">
      <label>Destination Elevation (ft MSL)</label>
      <input id="tod_destAlt" inputmode="numeric" />
    </div>
    <div class="field">
      <label>Groundspeed (kt)</label>
      <input id="toc_gs" inputmode="numeric" />
    </div>
    <div class="field">
      <label>Average ROC (fpm)</label>
      <input id="toc_roc" inputmode="numeric" />
    </div>

    <!-- Descent Mode Pills -->
    <div class="field">
      <label>Descent Mode</label>
      <div id="tod_mode_group" class="mode-pills" role="tablist" aria-label="Descent mode">
        <button type="button" class="btn secondary active" data-mode="fpm" aria-pressed="true">FPM</button>
        <button type="button" class="btn secondary" data-mode="fpnm" aria-pressed="false">ft / nm</button>
      </div>
    </div>

    <!-- FPM input -->
    <div class="field" id="tod_fpm_field">
      <label>Descent Rate (fpm)</label>
      <input id="tod_fpm" inputmode="numeric" placeholder="e.g. 700">
      <div class="pillrow" style="margin-top:8px;">
        <button class="pill" type="button" data-preset="350" data-mode="fpm">350</button>
        <button class="pill" type="button" data-preset="500" data-mode="fpm">500</button>
        <button class="pill" type="button" data-preset="750" data-mode="fpm">750</button>
        <button class="pill" type="button" data-preset="1000" data-mode="fpm">1000</button>
      </div>
    </div>

    <!-- ft/nm input (no 'deg' at all) -->
    <div class="field" id="tod_fpnm_field" style="display:none;">
      <label>Gradient (ft / nm)</label>
      <input id="tod_fpnm" inputmode="numeric" placeholder="e.g. 318">
      <div class="pillrow" style="margin-top:8px;">
        <button class="pill" type="button" data-preset="265" data-mode="fpnm">265</button>
        <button class="pill" type="button" data-preset="318" data-mode="fpnm">318</button>
        <button class="pill" type="button" data-preset="372" data-mode="fpnm">372</button>
      </div>
    </div>

    <div class="field">
      <label>Distance to Destination (nm)</label>
      <input id="tod_toDest" inputmode="numeric" />
    </div>
  </div>

  <!-- Outputs -->
  <div class="io">
    <div class="box">
      <h4>Top of Climb</h4>
      <div class="kv" id="toc_time">Time to climb: — min</div>
      <div class="kv" id="toc_dist">Distance to TOC: — nm</div>
    </div>
    <div class="box">
      <h4>Top of Descent</h4>
      <div class="kv" id="tod_time">Time before TOD: — min</div>
      <div class="kv" id="tod_beforeDist">Distance before TOD: — nm</div>
    </div>
  </div>

  <div class="note">
    Assumes constant GS and ROC/ROD. Choose descent mode for TOD: FPM, Degrees, or ft/nm.
  </div>
</div>

<!-- Time Organizer -->
<div id="panel-timeorg" class="panel hidden" aria-hidden="true">
  <div class="backbar">
    <button class="btn ghost" data-back>&larr; All calculators</button>
    <h3>Time Organizer</h3>
  </div>

  <!-- Top toolbar -->
  <div class="toolbar">
    <button class="btn ghost" id="TO_CLEAR">Clear</button>
  </div>

  <!-- Plan Settings -->
  <div class="box">
    <h4>Plan Settings</h4>
    <div class="form">
      <div class="field">
        <label>Time mode</label>
        <select id="to_tzmode">
          <option value="local">Local 12-hr</option>
          <option value="zulu">Zulu 24-hr (UTC)</option>
        </select>
      </div>
      <div class="field">
        <label>Schedule</label>
        <select id="to_mode">
          <option value="leave">Leave by (forward)</option>
          <option value="arrive">Arrive by (backward)</option>
        </select>
      </div>
      <div class="field" id="to_anchor_wrap">
        <label id="to_anchor_label">Leave by (Local 12-hr)</label>
        <!-- anchor input will be injected here as TIME (local) or TEXT (zulu) -->
      </div>
      <div class="field">
        <label>Default buffer (min)</label>
        <input id="to_default_buf" inputmode="numeric" placeholder="e.g., 10" />
      </div>
    </div>
    <div class="note">Buffers are <em>not</em> automatic. Tap the buffer chip that appears <em>between</em> events to add/remove it. Data doesn't save after refresh.</div>
  </div>

  <!-- New Event (added spacing above via mt-16) -->
  <div class="box mt-16">
    <h4>New Event</h4>
    <div class="form">
      <div class="field">
        <label>Title</label>
        <input id="to_title" placeholder="e.g., Drive to airport" />
      </div>
      <div class="field">
        <label>Duration (hh:mm or minutes)</label>
        <input id="to_duration" inputmode="decimal" placeholder="0:45 or 45" />
      </div>
    </div>

    <div class="toolbar mt-16">
      <button class="btn" id="TO_ADD">Add to plan</button>
      <button class="btn linky" id="TO_DUP_LAST">Duplicate last</button>
    </div>
  </div>

  <div class="io">
    <div class="box">
      <h4>Plan</h4>
      <div id="to_list" class="kv" style="display:flex;flex-direction:column;gap:8px;"></div>
    </div>
    <div class="box">
      <h4>Schedule</h4>
      <div id="to_schedule" class="kv" style="display:flex;flex-direction:column;gap:6px;"></div>
      <div id="to_complement" class="center-pill" aria-live="polite"></div>
    </div>
  </div>

  <div class="note" id="to_summary" style="margin-top:8px;"></div>
  <div class="footer">Local shows 12-hour times; Zulu shows 24-hour UTC with “Z”. Forward starts at “Leave by”; Backward reveals when to leave to “Arrive by”.</div>
</div>

</div>

<script>
(function TimeOrganizer(){
  const root = document.getElementById('panel-timeorg');
  if(!root) return;

  // elements
  const tzSel       = root.querySelector('#to_tzmode');
  const modeSel     = root.querySelector('#to_mode');
  const anchorWrap  = root.querySelector('#to_anchor_wrap');
  const anchorLbl   = root.querySelector('#to_anchor_label');
  const defBufInp   = root.querySelector('#to_default_buf');

  const titleInp    = root.querySelector('#to_title');
  const durInp      = root.querySelector('#to_duration');

  const listEl      = root.querySelector('#to_list');
  const schedEl     = root.querySelector('#to_schedule');
  const complement  = root.querySelector('#to_complement');
  const summaryEl   = root.querySelector('#to_summary');

  const addBtn      = root.querySelector('#TO_ADD');
  const dupLastBtn  = root.querySelector('#TO_DUP_LAST');
  const clearBtn    = root.querySelector('#TO_CLEAR');

  // state
  let items = [];        // [{title, durMin}]
  let gaps  = [];        // gaps[i] = minutes AFTER items[i] (keep trailing gap)
  let tzMode = 'local';  // 'local' | 'zulu'
  let anchorEl = null;   // current anchor input element (time or text)
  let inlineIdx = -1; // which row is showing inline actions (-1 = none)

  // utils
  const pad2 = n => String(n).padStart(2,'0');
  const clampDay = min => ((min % 1440) + 1440) % 1440;

  function parseHM(str){
    if(!str) return NaN;
    const s = String(str).trim();
    if(s.includes(':')){
      const [h,m='0'] = s.split(':');
      const H = Number(h), M = Number(m);
      return (Number.isFinite(H)?H:0)*60 + (Number.isFinite(M)?M:0);
    }
    const n = Number(s);
    return Number.isFinite(n) ? n : NaN;
  }

  function fmtDur(min){
    if(!Number.isFinite(min)) return '—';
    const sign = min<0 ? '-' : '';
    const t = Math.abs(min);
    const h = Math.floor(t/60), m = Math.round(t%60);
    return sign + h + ':' + pad2(m);
  }

  // anchor parsing (mode-aware)
  function parseAnchorMin(){
    if(!anchorEl) return NaN;
    const v = anchorEl.value.trim();
    if(tzMode === 'zulu'){
      // expect HH:MM 24-hr
      const m = /^([01]\d|2[0-3]):([0-5]\d)$/.exec(v);
      if(!m) return NaN;
      return Number(m[1])*60 + Number(m[2]); // minutes since Z midnight
    } else {
      // local time input element is type="time"
      const [H,M] = v.split(':').map(Number);
      if(!Number.isFinite(H)||!Number.isFinite(M)) return NaN;
      return H*60 + M; // minutes since local midnight
    }
  }

  function fmtClock(min){
    if(!Number.isFinite(min)) return '—';
    const t = clampDay(min);
    const H = Math.floor(t/60), M = Math.round(t%60);
    if(tzMode === 'zulu'){
      return pad2(H)+':'+pad2(M)+'Z'; // always 24-hr with Z
    }
    const ampm = H<12 ? 'AM' : 'PM';
    const h12 = ((H+11)%12)+1;
    return h12+':'+pad2(M)+' '+ampm;
  }

  function defBuf(){
    const n = Number(defBufInp.value);
    return Number.isFinite(n) ? Math.max(0, Math.round(n)) : 0;
  }

  // inject correct anchor field based on tzMode
  function renderAnchorField(){
    anchorWrap.querySelectorAll('input').forEach(n=>n.remove());
    if(tzMode==='zulu'){
      // strict HH:MM text field
      const inp = document.createElement('input');
      inp.id = 'to_anchor';
      inp.type = 'text';
      inp.inputMode = 'numeric';
      inp.placeholder = 'HH:MM';
      inp.pattern = '^([01]\\d|2[0-3]):([0-5]\\d)$';
      inp.title = 'Zulu 24-hr (00–23)';
      inp.addEventListener('input', recalc);
      anchorWrap.appendChild(inp);
      anchorEl = inp;
      anchorLbl.textContent = (modeSel.value==='leave' ? 'Leave by (Zulu 24-hr)' : 'Arrive by (Zulu 24-hr)');
    } else {
      // native time picker (OS decides 12/24 display; we describe as Local 12-hr for your UI)
      const inp = document.createElement('input');
      inp.id = 'to_anchor';
      inp.type = 'time';
      inp.title = 'Local time';
      inp.addEventListener('input', recalc);
      anchorWrap.appendChild(inp);
      anchorEl = inp;
      anchorLbl.textContent = (modeSel.value==='leave' ? 'Leave by (Local 12-hr)' : 'Arrive by (Local 12-hr)');
    }
  }

  function closeInline(){
    if(inlineIdx !== -1){ inlineIdx = -1; }
  }

  function renderList(){
  listEl.innerHTML = '';
  if(items.length===0){
    listEl.innerHTML = '<div class="muted">No events yet. Add one above.</div>';
    return;
  }

  for(let i=0;i<items.length;i++){
    const it = items[i];
    const bufMinutes = gaps[i] || 0;                 // buffer AFTER this event
    const shownDur   = (it.durMin || 0) + bufMinutes;// fold buffer into displayed duration
    const hasBuffer  = bufMinutes > 0;

    const row = document.createElement('div');
    row.className = 'to-row' + (i===inlineIdx ? ' is-inline' : '');

    row.innerHTML = `
      <div class="to-title">${it.title || '(untitled)'}</div>
      <div class="to-tags">
        <span class="to-tag">⏱ ${fmtDur(shownDur)}</span>
      </div>
      <div class="to-actions">
        <button class="btn secondary" data-act="minus" data-idx="${i}">−</button>
        <button class="btn secondary" data-act="plus"  data-idx="${i}">+</button>

        <div class="action-group">
          <button class="btn pill-ghost"        data-ia="up"   data-idx="${i}">Move up</button>
          <button class="btn pill-ghost"        data-ia="down" data-idx="${i}">Move down</button>
          <button class="btn pill-ghost"        data-ia="edit" data-idx="${i}">Edit</button>
          <button class="btn pill-ghost danger" data-ia="del"  data-idx="${i}">Delete</button>
        </div>

        <button class="menu-btn" aria-label="More" data-inline="${i}">⋯</button>
      </div>
    `;
    listEl.appendChild(row);

    // buffer chip below each event (toggles ON/OFF). Minutes fold into shown/scheduled duration.
    const gapDiv = document.createElement('div');
    gapDiv.className = 'to-gap';
    const chipText = hasBuffer ? `Buffer ${bufMinutes} min (tap to remove)` : `Add buffer +${defBuf()} min`;
    gapDiv.innerHTML = `<button class="to-gap-btn ${hasBuffer?'active':''}" data-gap="${i}">${chipText}</button>`;
    listEl.appendChild(gapDiv);
  }

  // − / + actions (auto-close inline)
  listEl.querySelectorAll('[data-act]').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      const idx = Number(btn.dataset.idx);
      const act = btn.dataset.act;
      if(act==='minus'){ items[idx].durMin = Math.max(0, (items[idx].durMin||0) - 1); }
      if(act==='plus' ){ items[idx].durMin = Math.max(0, (items[idx].durMin||0) + 1); }
      closeInline?.();
      recalc();
    });
  });

  // inline action pills (auto-close)
  listEl.querySelectorAll('[data-ia]').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      const idx = Number(btn.dataset.idx);
      const act = btn.dataset.ia;
      if(act==='up'   && idx>0)                  swap(idx, idx-1);
      else if(act==='down' && idx<items.length-1) swap(idx, idx+1);
      else if(act==='edit')                      editItem(idx);
      else if(act==='del')                       deleteItem(idx);
      closeInline?.();
      recalc();
    });
  });

  // 3-dot toggle
  listEl.querySelectorAll('[data-inline]').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      const idx = Number(btn.dataset.inline);
      inlineIdx = (inlineIdx === idx) ? -1 : idx;
      recalc();
    });
  });

  // buffer toggle
  listEl.querySelectorAll('[data-gap]').forEach(btn=>{
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      const i = Number(btn.dataset.gap);
      const current = gaps[i] || 0;
      gaps[i] = current > 0 ? 0 : defBuf();
      closeInline?.();
      recalc();
    });
  });

  // click outside closes inline
  setTimeout(()=>{
    const close = (ev)=>{
      if(!listEl.contains(ev.target)){
        if(inlineIdx !== -1){ inlineIdx = -1; recalc(); }
        document.removeEventListener('click', close);
      }
    };
    document.addEventListener('click', close);
  },0);
}

  function docCloseOnce(){ closeAllMenus(); }
  function closeAllMenus(){
    listEl.querySelectorAll('.menu-panel.open').forEach(p=>p.classList.remove('open'));
    listEl.querySelectorAll('.menu-btn[aria-expanded="true"]').forEach(b=>b.setAttribute('aria-expanded','false'));
  }

  function swap(a,b){
    const tmp = items[a]; items[a] = items[b]; items[b] = tmp;
    // keep gaps tied to positions AFTER each event (we swap the gaps too if adjacent)
    if(Math.abs(a-b)===1){
      const i = Math.min(a,b);
      const gtmp = gaps[i]; gaps[i] = gaps[i+1]; gaps[i+1] = gtmp; // swap the two gap slots across the boundary
    }
  }

  function editItem(i){
    const it = items[i];
    const t = prompt('Edit title:', it.title||'') ?? it.title;
    const d = prompt('Edit duration (HH:MM or minutes):', fmtDur(it.durMin)) ?? fmtDur(it.durMin);
    const dur = parseHM(d);
    if(Number.isFinite(dur)){ items[i].durMin = Math.max(0, Math.round(dur)); }
    items[i].title = (t||'').trim();
  }

  function deleteItem(i){
    items.splice(i,1);
    gaps.splice(i,1); // drop following gap
    while(gaps.length < items.length) gaps.push(0); // keep trailing slot
  }

  // schedule (includes trailing gap so single-event buffer shifts)
  function buildSchedule(){
  if(items.length===0) return {lines:[], totalMin:NaN, startAt:null, endAt:null};

  const lines = [];
  const mode = modeSel.value; // 'leave' | 'arrive'

  // Each block = event duration + its buffer-after
  const totalMin = items.reduce((sum, it, i)=>{
    return sum + ((it.durMin||0) + (gaps[i]||0));
  }, 0);

  const anchorMin = parseAnchorMin();
  let startAt = NaN, endAt = NaN;

  if(mode==='leave'){
    if(Number.isFinite(anchorMin)) startAt = anchorMin;
    let t = Number.isFinite(anchorMin) ? anchorMin : 0;
    for(let i=0;i<items.length;i++){
      const block = (items[i].durMin||0) + (gaps[i]||0);
      const s = t, e = t + block;
      lines.push(`${fmtClock(s)}–${fmtClock(e)}  •  ${items[i].title || '(untitled)'}`);
      t = e;
    }
    if(Number.isFinite(anchorMin)) endAt = t;
  } else {
    if(Number.isFinite(anchorMin)) endAt = anchorMin;
    let t = Number.isFinite(anchorMin) ? anchorMin : 0;
    for(let i=items.length-1;i>=0;i--){
      const block = (items[i].durMin||0) + (gaps[i]||0);
      const e = t, s = t - block;
      lines.unshift(`${fmtClock(s)}–${fmtClock(e)}  •  ${items[i].title || '(untitled)'}`);
      t = s;
    }
    if(Number.isFinite(anchorMin)) startAt = t;
  }

  return {lines,totalMin,startAt,endAt};
}

  function renderSchedule(){
    const {lines,totalMin,startAt,endAt} = buildSchedule();
    // list
    schedEl.innerHTML = '';
    lines.forEach(s => {
      const div = document.createElement('div');
      div.textContent = s;
      schedEl.appendChild(div);
    });
    // summary
    const sum = [];
    if(Number.isFinite(totalMin)) sum.push(`Total: ${fmtDur(totalMin)}`);
    if(Number.isFinite(startAt))  sum.push(`Start: ${fmtClock(startAt)}`);
    if(Number.isFinite(endAt))    sum.push(`End: ${fmtClock(endAt)}`);
    summaryEl.textContent = sum.join(' • ');

    // complement pill text
    if(modeSel.value==='leave' && Number.isFinite(endAt)){
      complement.dataset.text = `Arrive by ${fmtClock(endAt)}`;
    } else if(modeSel.value==='arrive' && Number.isFinite(startAt)){
      complement.dataset.text = `Leave by ${fmtClock(startAt)}`;
    } else {
      complement.dataset.text = '';
    }
  }

  function recalc(){
    renderList();
    renderSchedule();
  }

  // wiring
  tzSel.addEventListener('change', ()=>{
    tzMode = tzSel.value;            // switch mode
    renderAnchorField();             // rebuild anchor field to match mode
    recalc();
  });

  modeSel.addEventListener('change', ()=>{
    // keep current tz label
    anchorLbl.textContent = (modeSel.value==='leave'
      ? (tzMode==='zulu' ? 'Leave by (Zulu 24-hr)' : 'Leave by (Local 12-hr)')
      : (tzMode==='zulu' ? 'Arrive by (Zulu 24-hr)' : 'Arrive by (Local 12-hr)'));
    recalc();
  });

  defBufInp.addEventListener('input', recalc);

  addBtn.addEventListener('click', ()=>{
    const title = (titleInp.value||'').trim();
    const dur   = parseHM(durInp.value);
    if(!Number.isFinite(dur)){ durInp.focus(); return; }
    items.push({ title, durMin: Math.max(0, Math.round(dur)) });
    while(gaps.length < items.length) gaps.push(0); // keep trailing gap
    titleInp.value=''; durInp.value='';
    recalc();
  });

  dupLastBtn.addEventListener('click', ()=>{
    if(!items.length) return;
    const last = items[items.length-1];
    items.push({ title:last.title, durMin:last.durMin });
    while(gaps.length < items.length) gaps.push(0);
    recalc();
  });

  clearBtn.addEventListener('click', ()=>{
    items = []; gaps = [];
    titleInp.value=''; durInp.value='';
    if(anchorEl) anchorEl.value = '';
    defBufInp.value = defBufInp.value || '10';
    recalc();
  });

  // init
  defBufInp.value = defBufInp.value || '10';
  renderAnchorField(); // create the initial field (local)
  recalc();
})();
</script>

<script>
  (function(){
  const $ = s => document.querySelector(s);
  const num = v => parseFloat(v||'') || 0;

  // --- Mode (pill) wiring ---
  const modeGroup = document.getElementById('tod_mode_group');
  let todMode = 'fpm'; // default

  function setMode(m){
    todMode = (m === 'fpnm') ? 'fpnm' : 'fpm';
    // Toggle pill styling and aria
    modeGroup.querySelectorAll('button[data-mode]').forEach(btn=>{
      const on = btn.getAttribute('data-mode') === todMode;
      btn.classList.toggle('active', on);
      btn.setAttribute('aria-pressed', on ? 'true' : 'false');
    });
    // Show/hide fields
    document.getElementById('tod_fpm_field').style.display  = (todMode==='fpm')  ? '' : 'none';
    document.getElementById('tod_fpnm_field').style.display = (todMode==='fpnm') ? '' : 'none';
    calcTOC_TOD();
  }

  // Pill clicks
  modeGroup.addEventListener('click', (e)=>{
    const btn = e.target.closest('button[data-mode]');
    if(!btn) return;
    setMode(btn.getAttribute('data-mode'));
  });

  // Preset buttons (pills only: fpm / fpnm)
  document.querySelectorAll('[data-preset]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const val  = btn.getAttribute('data-preset');
      const mode = btn.getAttribute('data-mode');
      setMode(mode);
      if(mode==='fpm')  document.getElementById('tod_fpm').value  = val;
      if(mode==='fpnm') document.getElementById('tod_fpnm').value = val;
      calcTOC_TOD();
    });
  });

  // Initialize default mode
  setMode('fpm');

  function calcTOC_TOD(){
  const num = v => parseFloat(v||'') || 0;

  const curAlt    = num(document.getElementById('toc_curAlt').value);
  const cruiseAlt = num(document.getElementById('toc_cruiseAlt').value);
  const destAlt   = num(document.getElementById('tod_destAlt').value);
  const gs        = num(document.getElementById('toc_gs').value);
  const roc       = num(document.getElementById('toc_roc').value);

  // NOTE: we renamed the input to avoid ID collision
  const distToDest = num(document.getElementById('tod_toDest')?.value);


  // ----- TOC -----
  let climbAlt = Math.max(0, cruiseAlt - curAlt);
  let climbTime = roc > 0 ? climbAlt / roc : 0;
  let climbDist = gs > 0 ? climbTime * gs / 60 : 0;

  // ----- TOD -----
  let descentAlt = Math.max(0, cruiseAlt - destAlt);
  let todTime = 0, todDist = 0;

  if (todMode === 'fpm') {
    const rod = num(document.getElementById('tod_fpm').value);
    todTime = (rod > 0) ? (descentAlt / rod) : 0;
    todDist = (gs  > 0) ? (todTime * gs / 60) : 0;
  } else { // 'fpnm'
    const fpnm = num(document.getElementById('tod_fpnm').value);
    todDist = (fpnm > 0) ? (descentAlt / fpnm) : 0;
    todTime = (gs   > 0) ? ((todDist / gs) * 60) : 0;
  }

  // Show TOD “start in … nm” if user entered distance to destination
  const todFromDest = (distToDest > 0 && todDist > 0) ? (distToDest - todDist) : null;

  // ----- Outputs -----
  document.getElementById('toc_time').textContent =
    climbTime ? `Time to climb: ${climbTime.toFixed(1)} min` : 'Time to climb: —';
  document.getElementById('toc_dist').textContent =
    climbDist ? `Distance to TOC: ${climbDist.toFixed(1)} nm` : 'Distance to TOC: —';

  document.getElementById('tod_time').textContent =
    todTime ? `Time before TOD: ${todTime.toFixed(1)} min` : 'Time before TOD: —';

  // NOTE: output element was renamed to avoid the old ID collision
  const outBefore = document.getElementById('tod_beforeDist');

  if (todFromDest !== null) {
    // Distance from current position until descent starts
    outBefore.textContent = `Start descent in ~${todFromDest.toFixed(1)} nm`;
  } else if (todDist > 0) {
    // If no distance-to-destination is provided, show how much distance the descent takes
    outBefore.textContent = `Descent requires ~${todDist.toFixed(1)} nm`;
  } else {
    outBefore.textContent = 'Start descent: —';
  }
}

  // Wire up inputs on this panel
  document
    .querySelectorAll('#panel-toc-tod input, #panel-toc-tod select')
    .forEach(el => el.addEventListener('input', calcTOC_TOD));

  // Initial compute (setMode('fpm') elsewhere already calls calcTOC_TOD,
  // but calling once here is safe and keeps things robust)
  calcTOC_TOD();
})();
</script>

<script>
(function(){
  const $  = s => document.querySelector(s);
  const $$ = s => Array.from(document.querySelectorAll(s));
  const num = v => {
    const x = parseFloat(String(v||'').replace(/[^\-0-9.]/g,''));
    return Number.isFinite(x) ? x : NaN;
  };
  const round = (x,d=1)=> Number.isFinite(x) ? Math.round(x*10**d)/10**d : NaN;
  const fmt   = (x,d=1)=> Number.isFinite(x) ? round(x,d).toFixed(d) : '—';
  const norm360 = d => ((d%360)+360)%360;

  // Inputs
  const course = $('#S60_course');
  const dist   = $('#S60_dist');
  const off    = $('#S60_off');
  const te_in  = $('#S60_te_in');
  const int_in = $('#S60_int_in');
  const fix_in = $('#S60_fix_in');
  const gs     = $('#S60_gs');

  // Outputs
  const outTE   = $('#S60_out_te');
  const outOFF  = $('#S60_out_off');
  const outINT  = $('#S60_out_int');
  const outFIX  = $('#S60_out_fix');
  const outHDG  = $('#S60_out_hdgs');
  const outTURN = $('#S60_out_turn');
  const outTIME = $('#S60_out_time');

  // Side pills
  let SIDE = 'R';
  $$('#S60_side_row .pill').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      $$('#S60_side_row .pill').forEach(b=>b.classList.remove('action'));
      btn.classList.add('action');
      SIDE = btn.dataset.side;
      update();
    });
  });

  function update(){
    const crs = num(course.value);
    const D   = num(dist.value);
    const X   = num(off.value);
    const TEi = num(te_in.value);
    const INTi= num(int_in.value);
    const FIXi= num(fix_in.value);
    const V   = num(gs.value);

    let TE, OFF, INT, FIX, HDGparallel, HDGintercept, TURN, TIME;

    // --- Track error / Off-course (either path)
    if(Number.isFinite(D) && Number.isFinite(X) && D>0){
      TE  = 60 * X / D;
      OFF = X;
    }
    if(!Number.isFinite(TE) && Number.isFinite(TEi)){
      TE = TEi;
    }
    if(!Number.isFinite(OFF) && Number.isFinite(TE) && Number.isFinite(D) && D>0){
      OFF = TE * D / 60;
    }

    // --- Intercept angle / Distance to rejoin (either path)
    //  INT ≈ 60 * OFF / FIX  <=>  FIX ≈ 60 * OFF / INT
    if(Number.isFinite(OFF) && Number.isFinite(FIXi) && FIXi>0){
      INT = 60 * OFF / FIXi;
      FIX = FIXi;
    }
    if(!Number.isFinite(FIX) && Number.isFinite(OFF) && Number.isFinite(INTi) && INTi>0){
      FIX = 60 * OFF / INTi;
      INT = INTi;
    }
    if(!Number.isFinite(INT) && Number.isFinite(INTi)){
      INT = INTi;
    }

    // --- Headings
    if(Number.isFinite(crs)){
      HDGparallel = norm360(crs);
      if(Number.isFinite(INT)){
        HDGintercept = norm360(crs + (SIDE==='L' ? +INT : -INT));
        TURN = (SIDE==='L')
          ? `Turn RIGHT to ${fmt(HDGintercept,0)}°`
          : `Turn LEFT to ${fmt(HDGintercept,0)}°`;
      }
    }

    // --- Time
    if(Number.isFinite(FIX) && Number.isFinite(V) && V>0){
      TIME = (FIX / V) * 60; // minutes
    }

    // --- Outputs
    outTE.textContent   = `Track error: ${fmt(TE)} °`;
    outOFF.textContent  = `Off-course: ${fmt(OFF)} nm`;
    outINT.textContent  = `Intercept angle: ${fmt(INT)} °`;
    outFIX.textContent  = `Distance to rejoin: ${fmt(FIX)} nm`;

    const p = Number.isFinite(HDGparallel)  ? `${fmt(HDGparallel,0)}°`  : '— °';
    const i = Number.isFinite(HDGintercept) ? `${fmt(HDGintercept,0)}°` : '— °';
    outHDG.textContent  = `Headings — Parallel: ${p} • Intercept: ${i}`;

    outTURN.textContent = `Turn: ${TURN || '—'}`;
    outTIME.textContent = `Time to rejoin: ${Number.isFinite(TIME) ? fmt(TIME) : '—'} min`;
  }

  // Wire inputs
  $$('#panel-sixty input').forEach(el => el.addEventListener('input', update));

  // Clear
  $('#clear-sixty')?.addEventListener('click', ()=>{
    ['#S60_course','#S60_dist','#S60_off','#S60_te_in','#S60_int_in','#S60_fix_in','#S60_gs']
      .forEach(id => { const el = document.querySelector(id); if(el) el.value=''; });
    SIDE = 'R';
    $$('#S60_side_row .pill').forEach(b=> b.classList.toggle('action', b.dataset.side==='R'));
    update();
  });

  update();
})();
</script>

<script>
(function(){
  const $ = s => document.querySelector(s);
  const num = v => {
    const x = parseFloat(String(v||'').replace(/[^\-0-9.]/g,''));
    return Number.isFinite(x) ? x : NaN;
  };
  const toC = (x, units) => units==='F' ? (x-32)/1.8 : x;
  const toF = (x, units) => units==='F' ? x : (x*1.8+32);

  const U   = $('#CL_UNITS');
  const FLD = $('#CL_FLD_FT');
  const T   = $('#CL_T');
  const TD  = $('#CL_TD');
  const LR  = $('#CL_LR');
  const METH= $('#CL_TOP_METHOD');
  const TTOP= $('#CL_TTOP');
  const FRZ = $('#CL_FREEZE_FT');
  const TTOP_FIELD = $('#CL_TTOP_FIELD');
  const FRZ_FIELD  = $('#CL_FREEZE_FIELD');

  const OUT_SPREAD   = $('#CL_SPREAD');
  const OUT_BASE_AGL = $('#CL_BASE_AGL');
  const OUT_BASE_MSL = $('#CL_BASE_MSL');
  const OUT_TOP_MSL  = $('#CL_TOP_MSL');
  const OUT_THICK    = $('#CL_THICK');
  const REQ_TD       = $('#CL_REQ_TD');
  
  // Clouds ± (panel-only, single toggle + focus input)
  document.querySelectorAll('#panel-clouds .oat-sign-btn').forEach(btn => {
    btn.addEventListener('click', (ev) => {
      ev.stopPropagation();   // don't trigger global handler
      ev.preventDefault();    // don't steal focus

      // prefer the input next to the button inside .input-affix
      const input = btn.closest('.input-affix')?.querySelector('input, textarea');
      if (!input) return;

      const v = (input.value || '').trim();
      input.value = v.startsWith('-') ? v.slice(1) : (v ? ('-' + v) : '-');

      input.dispatchEvent(new Event('input',  { bubbles: true }));
      input.dispatchEvent(new Event('change', { bubbles: true }));

      // focus and place caret at the end
      input.focus({ preventScroll: true });
      try {
        const end = input.value.length;
        input.setSelectionRange(end, end);
      } catch (_) {}
    });
  });

  function fmtInt(x){
    return Number.isFinite(x) ? Math.round(x).toLocaleString() : '—';
  }
  function fmtTemp(x, units){
    if(!Number.isFinite(x)) return '—';
    const val = units==='F' ? x : x; // already in chosen units when we call this
    return `${Math.round(val)} °${units}`;
  }

  function recalc(){
    const units = U.value;               // 'C' or 'F'
    const fld   = num(FLD.value);        // ft
    const tIn   = num(T.value);
    const tdIn  = num(TD.value);
    const lr    = num(LR.value);         // °C / 1000 ft

    const tC  = Number.isFinite(tIn)  ? toC(tIn, units)  : NaN;
    const tdC = Number.isFinite(tdIn) ? toC(tdIn, units) : NaN;

    // Spread in °C
    const spreadC = (Number.isFinite(tC) && Number.isFinite(tdC)) ? (tC - tdC) : NaN;
    OUT_SPREAD.textContent = Number.isFinite(spreadC)
      ? (units==='F' ? `${Math.round((spreadC*1.8))} °F` : `${Math.round(spreadC)} °C`)
      : '—';

    // LCL / Base (AGL ft): ~400 ft per °C of spread
    const baseAGL = Number.isFinite(spreadC) ? Math.max(0, spreadC * 400) : NaN;
    OUT_BASE_AGL.textContent = fmtInt(baseAGL);

    // Base MSL
    const baseMSL = (Number.isFinite(baseAGL) && Number.isFinite(fld)) ? (fld + baseAGL) : NaN;
    OUT_BASE_MSL.textContent = fmtInt(baseMSL);

    // Tops (optional)
    let topMSL = NaN;
    if(METH.value === 'ttop'){
      const ttopIn = num(TTOP.value);
      const ttopC  = Number.isFinite(ttopIn) ? toC(ttopIn, units) : NaN;
      // ΔT (°C) from surface to top
      if([tC, ttopC, lr, fld].every(Number.isFinite) && lr > 0){
        const dT = tC - ttopC;                // °C
        const topAGL = (dT / lr) * 1000;      // ft
        topMSL = fld + topAGL;
      }
      TTOP_FIELD.style.display = '';
      FRZ_FIELD.style.display  = 'none';
    }else if(METH.value === 'freeze'){
      const frz = num(FRZ.value);
      if(Number.isFinite(frz)) topMSL = frz;
      TTOP_FIELD.style.display = 'none';
      FRZ_FIELD.style.display  = '';
    }else{
      TTOP_FIELD.style.display = 'none';
      FRZ_FIELD.style.display  = 'none';
    }

    OUT_TOP_MSL.textContent = fmtInt(topMSL);

    // Thickness
    const thick = (Number.isFinite(topMSL) && Number.isFinite(baseMSL)) ? Math.max(0, topMSL - baseMSL) : NaN;
    OUT_THICK.textContent = fmtInt(thick);

    // Reverse: required dewpoint for desired base
    const wantBase = num($('#CL_DESIRED_BASE').value);
    if(Number.isFinite(wantBase) && Number.isFinite(tC)){
      const neededSpreadC = wantBase / 400;   // °C
      const reqTdC = tC - neededSpreadC;
      const out = (units==='F') ? (reqTdC*1.8 + 32) : reqTdC;
      REQ_TD.textContent = fmtTemp(out, units);
    }else{
      REQ_TD.textContent = '—';
    }
  }

  // Method switch updates visible fields immediately
  METH.addEventListener('change', recalc);

  // Recalc on any input
  ['input','change'].forEach(evt=>{
    document.querySelectorAll('#panel-clouds input, #panel-clouds select').forEach(el=>{
      el.addEventListener(evt, recalc);
    });
  });

  // Clear
  $('#CLOUDS_CLEAR').addEventListener('click', ()=>{
    [FLD,T,TD,LR,TTOP,FRZ,$('#CL_DESIRED_BASE')].forEach(el=>{ if(el) el.value=''; });
    U.value='C'; METH.value='none'; LR.value='2.0';
    recalc();
  });

  // Initial compute
  recalc();
})();
</script>

<script>
(function(){
  const $ = s => document.querySelector(s);
  const num = v => {
    const x = parseFloat(String(v||'').replace(/[^\-0-9.]/g,''));
    return Number.isFinite(x) ? x : NaN;
  };
  const round = (x, d=1) => Number.isFinite(x) ? (Math.round(x*10**d)/10**d) : NaN;
  const fmt = (x, d=1) => Number.isFinite(x) ? round(x,d).toLocaleString() : '—';

  // Inputs
  const PSI = $('#HY_PSI');
  const KPA = $('#HY_KPA');
  const GS  = $('#HY_GS');

  // Outputs (simplified)
  const OUT_VP  = $('#HY_VP');
  const OUT_GS  = $('#HY_GS_OUT');
  const OUT_REL = $('#HY_REL');

  // psi <-> kPa sync
  let syncing = false;
  const kpaToPsi = kpa => kpa * 0.1450377377;
  const psiToKpa = psi => psi / 0.1450377377;

  function syncFromPSI(){
    if(syncing) return;
    syncing = true;
    const p = num(PSI.value);
    KPA.value = Number.isFinite(p) ? String(round(psiToKpa(p),1)) : '';
    syncing = false;
  }
  function syncFromKPA(){
    if(syncing) return;
    syncing = true;
    const k = num(KPA.value);
    PSI.value = Number.isFinite(k) ? String(round(kpaToPsi(k),1)) : '';
    syncing = false;
  }

  PSI?.addEventListener('input', ()=>{ syncFromPSI(); recalc(); });
  KPA?.addEventListener('input', ()=>{ syncFromKPA(); recalc(); });
  GS ?.addEventListener('input', recalc);

  function recalc(){
    const psi = num(PSI?.value);
    const gs  = num(GS ?.value);

    // Vp ≈ 9 * √psi (knots)
    const Vp = Number.isFinite(psi) && psi > 0 ? 9 * Math.sqrt(psi) : NaN;
    OUT_VP.textContent = fmt(Vp,1);

    OUT_GS.textContent = fmt(gs,1);

    // Simple risk text
    let rel = '—';
    if(Number.isFinite(gs) && Number.isFinite(Vp)){
      if(gs < Vp) rel = 'Safe (below Vp)';
      else if(gs < Vp*1.1) rel = 'Caution (around Vp)';
      else rel = 'Risk (above Vp)';
    }
    OUT_REL.textContent = rel;
  }

  // Clear
  $('#HY_CLEAR')?.addEventListener('click', ()=>{
    if(PSI) PSI.value = '';
    if(KPA) KPA.value = '';
    if(GS)  GS.value  = '';
    recalc();
  });

  // Initial
  recalc();
})();
</script>

<script>
/* ===== Router ===== */
const tiles = document.getElementById('tiles');
const panels = {
  'c172-perf': document.getElementById('panel-c172-perf'),
  'conversions': document.getElementById('panel-conversions'),
  'etp-pnr': document.getElementById('panel-etp-pnr'),
  'meet':    document.getElementById('panel-meet'),
  'vortri':  document.getElementById('panel-vortri'),
  'gc':      document.getElementById('panel-gc'),
  'tas':     document.getElementById('panel-tas'),
  'sdt':     document.getElementById('panel-sdt'),
  'wind':    document.getElementById('panel-wind'),
  'altitudes': document.getElementById('panel-altitudes'),
  'fpm':     document.getElementById('panel-fpm'),
  'pivalt':  document.getElementById('panel-pivalt'),
  'sixty': document.getElementById('panel-sixty'),
  'clouds':  document.getElementById('panel-clouds'),
  'hydro':  document.getElementById('panel-hydro'),
  'toc-tod': document.getElementById('panel-toc-tod'),
  'timeorg': document.getElementById('panel-timeorg')
};

function hideAllPanels() {
  tiles.style.display = 'grid';
  Object.values(panels).forEach(p => {
    if (p) {
      p.classList.remove('visible');
      p.setAttribute('aria-hidden','true');
      p.classList.add('hidden');
    }
  });
}

function showPanel(id) {
  const target = panels[id];
  if (!target) return;
  
  tiles.style.display = 'none';
  
  Object.entries(panels).forEach(([key, p]) => {
    if (key === id) return;
    if (p) {
      p.classList.remove('visible');
      p.setAttribute('aria-hidden','true');
      p.classList.add('hidden');
    }
  });
  
  target.classList.remove('hidden');
  target.setAttribute('aria-hidden','false');
  requestAnimationFrame(() => { target.classList.add('visible'); });
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

function showTiles() {
  tiles.style.display = 'grid';
  Object.values(panels).forEach(p => {
    if (p) {
      p.classList.remove('visible');
      p.setAttribute('aria-hidden','true');
      p.classList.add('hidden');
    }
  });
}

tiles.addEventListener('click', (e) => {
  const t = e.target.closest('.tile');
  if (!t) return;
  showPanel(t.dataset.panel);
});

document.querySelectorAll('[data-back]').forEach(b => b.addEventListener('click', showTiles));

hideAllPanels();

// ===== One-open-at-a-time for every panel (robust) =====
(function singleOpenDetailsPerPanel(){
  // On load, if multiple are open in a panel, keep only the first
  document.querySelectorAll('.panel').forEach(panel=>{
    const opened = panel.querySelectorAll('details[open]');
    for (let i = 1; i < opened.length; i++) opened[i].open = false;
  });

  // Whenever any <details> opens, close the others in the same panel
  document.addEventListener('toggle', (ev)=>{
    const d = ev.target;
    if (!d || d.tagName !== 'DETAILS' || !d.open) return;
    const panel = d.closest('.panel');
    if (!panel) return;
    panel.querySelectorAll('details[open]').forEach(other=>{
      if (other !== d) other.open = false;
    });
  }, true); // capture = true helps on some Safari builds
})();

/* ===== Helpers ===== */
function parseEndurance(str){
  if(!str) return NaN;
  if(String(str).includes(':')){
    const [h,m] = String(str).split(':').map(Number);
    const hh = Number.isFinite(h)?h:0;
    const mm = Number.isFinite(m)?m:0;
    return hh + mm/60;
  }
  const n = Number(str);
  return Number.isFinite(n) ? n : NaN;
}
function hhmm(hours){
  if(!Number.isFinite(hours)) return '—';
  const sign = hours<0 ? '-' : '';
  const t = Math.abs(hours);
  const h = Math.floor(t);
  const m = Math.round((t-h)*60);
  return sign + h.toString() + ':' + m.toString().padStart(2,'0');
}
function fmt(x,dp=1){ return Number.isFinite(x) ? Number(x).toFixed(dp) : '—'; }
function clamp360(a){ a = a%360; return a<0 ? a+360 : a; }
function toRad(d){ return d*Math.PI/180; }
function toDeg(r){ return r*180/Math.PI; }
function numStrict(v){ const s = (v??'').toString().trim(); if(s==='') return NaN; const n = Number(s); return Number.isFinite(n)?n:NaN; }

/* ===== Wind triangle core ===== */
function windSolve(TAS, courseDeg, windFromDeg, windSpeed){
  const TASn = numStrict(TAS), C = clamp360(numStrict(courseDeg));
  const WF = clamp360(numStrict(windFromDeg)), W = numStrict(windSpeed);
  if(!Number.isFinite(TASn) || !Number.isFinite(C) || !Number.isFinite(WF) || !Number.isFinite(W)) return null;
  const WT = clamp360(WF + 180);
  const r = clamp360(WT - C);
  const along = W * Math.cos(toRad(r));
  const cross = W * Math.sin(toRad(r));
  const GS = TASn + along;
  let WCA = 0;
  if (TASn > 0) {
    const s = Math.max(-1, Math.min(1, cross / TASn));
    WCA = toDeg(Math.asin(s));
  }
  const HDG = clamp360(C + WCA);
  return { GS, WCA, HDG };
}

// ===== TOD: Distance-to-go required gradient/VSI =====
(function(){
  const CURR  = document.getElementById('FPM_TOD_CURR');
  const TGT   = document.getElementById('FPM_TOD_TGT');
  const GS    = document.getElementById('FPM_TOD_GS');      // optional, for FPM
  const DTG   = document.getElementById('FPM_TOD_DTG');     // new distance-to-go

  const OUT_DIR   = document.getElementById('FPM_TOD_REQ_DIR');
  const OUT_FPNM  = document.getElementById('FPM_TOD_REQ_FPNM');
  const OUT_ANG   = document.getElementById('FPM_TOD_REQ_ANGLE');
  const OUT_PCT   = document.getElementById('FPM_TOD_REQ_PCT');
  const OUT_FPM   = document.getElementById('FPM_TOD_REQ_FPM');

  function recalcRequired(){
  // bail out gracefully if outputs aren’t present
  if (!OUT_DIR || !OUT_FPNM || !OUT_ANG || !OUT_PCT || !OUT_FPM) return;

  const curr = numStrict(CURR?.value);
  const tgt  = numStrict(TGT?.value);
  const dtg  = numStrict(DTG?.value);
  const gs   = numStrict(GS?.value);

  // need current/target and a positive DTG
  if (!Number.isFinite(curr) || !Number.isFinite(tgt) || !Number.isFinite(dtg) || dtg <= 0){
    OUT_DIR.textContent  = 'Direction: —';
    OUT_FPNM.textContent = 'ft / nm: —';
    OUT_ANG.textContent  = 'Angle: — °';
    OUT_PCT.textContent  = 'Gradient: — %';
    OUT_FPM.textContent  = 'VSI (FPM): —';
    return;
  }

    const deltaAlt = curr - tgt;              // positive = need to descend
    const dir = deltaAlt > 0 ? 'Descent' : 'Climb';
    const reqFPNM = Math.abs(deltaAlt) / dtg; // ft per nm
    const angleRad = Math.atan(reqFPNM / 6076.12);
    const angleDeg = toDeg(angleRad);
    const pct = (reqFPNM / 6076.12) * 100;    // % grade

    let fpm = '—';
    if (Number.isFinite(gs)) {
      fpm = (reqFPNM * gs) / 60;              // VSI in fpm
    }

    OUT_DIR.textContent  = `Direction: ${dir}`;
    OUT_FPNM.textContent = `ft / nm: ${fmt(reqFPNM,0)}`;
    OUT_ANG.textContent  = `Angle: ${fmt(angleDeg,1)} °`;
    OUT_PCT.textContent  = `Gradient: ${fmt(pct,1)} %`;
    OUT_FPM.textContent  = `VSI (FPM): ${Number.isFinite(fpm) ? fmt(fpm,0) : '—'}`;
  }

  [CURR, TGT, DTG, GS].forEach(el => el && el.addEventListener('input', recalcRequired));
  recalcRequired();
})();

/* ===== Wind • Angles ===== */
const WIN = {
  // enroute
  TAS: document.getElementById('W_TAS'),
  TC:  document.getElementById('W_TC'),
  WF:  document.getElementById('W_WF'),
  W:   document.getElementById('W_W'),
  VAR: document.getElementById('W_VAR'),
  out_wca:  document.getElementById('W_out_wca'),
  out_hdg_t:document.getElementById('W_out_hdg_t'),
  out_hdg_m:document.getElementById('W_out_hdg_m'),
  out_gs:   document.getElementById('W_out_gs'),
  in_wca:   document.getElementById('W_in_wca'),
  in_hdg_t: document.getElementById('W_in_hdg_t'),
  in_hdg_m: document.getElementById('W_in_hdg_m'),
  in_gs:    document.getElementById('W_in_gs'),

  // runway
  RWY:     document.getElementById('W_RWY'),
  RWY_REF: document.getElementById('W_RWY_REF'),
  VAR2:    document.getElementById('W_VAR2'),
  WF2:     document.getElementById('W_WF2'),
  W2:      document.getElementById('W_W2'),
  MAXX:    document.getElementById('W_MAXX'),
  head:    document.getElementById('W_head'),
  cross:   document.getElementById('W_cross'),
  limit:   document.getElementById('W_limit'),

  clear:   document.getElementById('clear-wind'),
};

function magFromTrue(T, v){                 // v: +E, -W
  if(!Number.isFinite(T)) return NaN;
  const vv = Number(v);
  return Number.isFinite(vv) ? clamp360(T - vv) : NaN; // East is least
}
function trueFromMag(M, v){                 // v: +E, -W
  if(!Number.isFinite(M)) return NaN;
  const vv = Number(v);
  return Number.isFinite(vv) ? clamp360(M + vv) : NaN; // True = Mag + Var
}
function fmtDeg(x){ return Number.isFinite(x) ? Math.round(clamp360(x)).toString().padStart(3,'0') : '—'; }

function computeWindEnrouteSimple(){
  const TAS = numStrict(WIN.TAS.value);
  const courseMag = clamp360(numStrict(document.getElementById('W_COURSE').value));
  const windDir = clamp360(numStrict(document.getElementById('W_WINDDIR').value));
  const windSpd = numStrict(document.getElementById('W_WINDSPEED').value);
  const windRef = document.getElementById('W_WINDREF').value;
  const VAR = numStrict(document.getElementById('W_VAR').value);

  // guard
  if(!Number.isFinite(TAS) || !Number.isFinite(courseMag) || !Number.isFinite(windDir) || !Number.isFinite(windSpd)){
    document.getElementById('W_wca').textContent = 'WCA: — ° (L/R)';
    document.getElementById('W_hdgM').textContent = 'Heading to fly (Mag): — °';
    document.getElementById('W_gs').textContent = 'Groundspeed: — kt';
    return;
  }

  // Step 1: convert wind direction to magnetic if given as True
  let windDirMag = windDir;
  if(windRef === 'true' && Number.isFinite(VAR)){
    windDirMag = magFromTrue(windDir, VAR); // true → mag
  }

  // Step 2: solve wind triangle in magnetic frame
  const sol = windSolve(TAS, courseMag, windDirMag, windSpd);
  if(!sol){
    document.getElementById('W_wca').textContent = 'WCA: — ° (L/R)';
    document.getElementById('W_hdgM').textContent = 'Heading to fly (Mag): — °';
    document.getElementById('W_gs').textContent = 'Groundspeed: — kt';
    return;
  }

  const lr = sol.WCA >= 0 ? 'Right' : 'Left';
  document.getElementById('W_wca').textContent = `WCA: ${fmt(sol.WCA,1)} ° (${lr})`;
  document.getElementById('W_hdgM').textContent = `Heading to fly (Mag): ${fmt(sol.HDG,1)} °`;
  document.getElementById('W_gs').textContent = `Groundspeed: ${fmt(sol.GS,1)} kt`;
}

// Show/hide variation field depending on windRef
document.getElementById('W_WINDREF').addEventListener('change', ()=>{
  const ref = document.getElementById('W_WINDREF').value;
  document.getElementById('W_VARFIELD').style.display = (ref==='true') ? '' : 'none';
  computeWindEnrouteSimple();
});

// Wire up
['input','change'].forEach(ev=>{
  [WIN.TAS, document.getElementById('W_COURSE'), document.getElementById('W_WINDDIR'),
   document.getElementById('W_WINDSPEED'), document.getElementById('W_WINDREF'),
   document.getElementById('W_VAR')].forEach(el=>el?.addEventListener(ev, computeWindEnrouteSimple));
});

// Run once
computeWindEnrouteSimple();

function normRunwayInput(v){
  const n = numStrict(v);
  if(!Number.isFinite(n)) return NaN;
  return n <= 36 ? n*10 : n; // allow 9/27 style
}

function computeWindRunway(){
  let RWY = normRunwayInput(WIN.RWY.value);     // 31 -> 310
  const ref  = (WIN.RWY_REF?.value || 'mag');   // 'mag' or 'true'
  const VAR2 = numStrict(WIN.VAR2.value);       // +E / -W (optional)
  const Wspd = numStrict(WIN.W2.value);
  const WF_in = numStrict(WIN.WF2.value);

  // guard
  if(!Number.isFinite(RWY) || !Number.isFinite(Wspd) || !Number.isFinite(WF_in)){
    WIN.head.textContent  = 'Head/Tail: — kt';
    WIN.cross.textContent = 'Crosswind: — kt (L/R)';
    WIN.limit.textContent = 'Limit check: —';
    return;
  }

  // Determine frames (true vs magnetic)
  let useTrueMath = false;
  let RWY_true = NaN, RWY_mag = NaN, WF_true = NaN, WF_mag = NaN;

  if (ref === 'mag') {
    RWY_mag = clamp360(RWY);
    if (Number.isFinite(VAR2)) {
      // We can convert both to true and compute there
      RWY_true = trueFromMag(RWY_mag, VAR2);
      WF_true  = clamp360(WF_in);            // input is labeled true
      useTrueMath = true;
    } else {
      // No variation provided: assume ATIS-style magnetic wind
      WF_mag = clamp360(WF_in);
      useTrueMath = false;
    }
  } else {
    // Runway given as true
    RWY_true = clamp360(RWY);
    WF_true  = clamp360(WF_in);              // input is true
    useTrueMath = true;
  }

  // Compute components
  let ang, head, cross;
  if (useTrueMath) {
    if(!Number.isFinite(RWY_true) || !Number.isFinite(WF_true)){
      WIN.head.textContent  = 'Head/Tail: — kt';
      WIN.cross.textContent = 'Crosswind: — kt (L/R)';
      WIN.limit.textContent = 'Limit check: —';
      return;
    }
    ang   = toRad(clamp360(WF_true - RWY_true));
  } else {
    if(!Number.isFinite(RWY_mag) || !Number.isFinite(WF_mag)){
      WIN.head.textContent  = 'Head/Tail: — kt';
      WIN.cross.textContent = 'Crosswind: — kt (L/R)';
      WIN.limit.textContent = 'Limit check: —';
      return;
    }
    ang   = toRad(clamp360(WF_mag - RWY_mag));
  }

  head  = Wspd * Math.cos(ang);
  cross = Wspd * Math.sin(ang); // + = from right (crab left)

  const headStr  = head >= 0 ? `Headwind ${fmt(Math.abs(head),1)} kt` : `Tailwind ${fmt(Math.abs(head),1)} kt`;
  const crossStr = `${fmt(Math.abs(cross),1)} kt (${cross>=0?'from R':'from L'})`;

  WIN.head.textContent  = `Head/Tail: ${headStr}`;
  WIN.cross.textContent = `Crosswind: ${crossStr}`;

  const maxX = numStrict(WIN.MAXX.value);
  if (Number.isFinite(maxX)) {
    const ok = Math.abs(cross) <= maxX + 1e-9;
    WIN.limit.textContent = `Limit check: ${ok ? 'Within' : 'Exceeds'} ${fmt(maxX,1)} kt`;
  } else {
    WIN.limit.textContent = 'Limit check: —';
  }
}

// Wire up (runway only – Enroute is already wired above with computeWindEnrouteSimple)
['input','change'].forEach(ev=>{
  [WIN.RWY, WIN.RWY_REF, WIN.VAR2, WIN.WF2, WIN.W2, WIN.MAXX]
    .forEach(el => el?.addEventListener(ev, computeWindRunway));
});

WIN.clear?.addEventListener('click', ()=>{
  [
    WIN.TAS,
    document.getElementById('W_COURSE'),
    document.getElementById('W_WINDDIR'),
    document.getElementById('W_WINDSPEED'),
    document.getElementById('W_WINDREF'),
    document.getElementById('W_VAR'),
    WIN.RWY, WIN.RWY_REF, WIN.VAR2, WIN.WF2, WIN.W2, WIN.MAXX
  ].forEach(el => { if(el) el.value=''; });
  computeWindEnrouteSimple();
  computeWindRunway();
});

// Initial
computeWindEnrouteSimple();
computeWindRunway();
/* ===== Altitudes ===== */
let ALT = {}; // keep it global so other code can read it

// Unit state mirrors pill defaults (matches your HTML pills)
let A_TUNIT = 'C';     // 'C' or 'F'
let A_ALTU  = 'inHg';  // 'inHg' or 'hPa'

// helper to flip the gray "active" pill correctly
function setPillActive(group, dataAttr, val){
  if (!group) return;
  group.querySelectorAll('button.btn.secondary').forEach(btn=>{
    const on = btn.getAttribute(dataAttr) === val;
    btn.classList.toggle('active', on);
    btn.setAttribute('aria-pressed', on ? 'true' : 'false');
  });
}

function updateAltInputVisibility(){
  const src = document.getElementById('A_SRC')?.value || 'alt';
  const paField = document.getElementById('A_PA_FIELD');
  if (paField) paField.style.display = (src === 'pa') ? '' : 'none';
}

function computeAltitudes(){
  // Read inputs (guard in case fields aren’t present)
  const v = el => el ? el.value : '';

  let indAlt  = numStrict(v(ALT.IND));          // may be blank
  const fldElev = numStrict(v(ALT.FLD));        // may be blank
  let altSet  = numStrict(v(ALT.ALTSET));       // may be blank if using PA override
  let oat     = numStrict(v(ALT.OAT));          // may be blank
  const tUnit = A_TUNIT;                        // 'C' or 'F'
  const aUnit = A_ALTU;                         // 'inHg' or 'hPa'
  const src   = document.getElementById('A_SRC')?.value || 'alt';
  const paIn  = numStrict(document.getElementById('A_PA_IN')?.value);

  // Temp: convert F → C if needed
  if (tUnit === 'F' && Number.isFinite(oat)) {
    oat = (oat - 32) * 5/9;
  }

  // Altimeter: convert hPa → inHg if needed
  if (aUnit === 'hPa' && Number.isFinite(altSet)) {
    altSet = altSet / 33.8638866667; // 1 inHg = 33.8638866667 hPa
  }

  // Compute PA
  let PA = NaN;

  if (src === 'pa') {
    if (Number.isFinite(paIn)) {
      PA = paIn;
      if (!Number.isFinite(indAlt) && Number.isFinite(fldElev)) indAlt = fldElev;
    }
  } else {
    if (!Number.isFinite(indAlt) && Number.isFinite(fldElev)) indAlt = fldElev;
    if (Number.isFinite(indAlt) && Number.isFinite(altSet)) {
      PA = indAlt + (29.92 - altSet) * 1000;
    }
  }

  if (!Number.isFinite(PA)) {
    if (ALT.PA) ALT.PA.textContent = 'Pressure Altitude: — ft';
    if (ALT.DA) ALT.DA.textContent = 'Density Altitude: — ft';
    if (ALT.TA) ALT.TA.textContent = 'True Altitude: — ft';
    return;
  }

  // ISA & DA
  const ISA = 15 - (PA / 1000) * 2;
  const tempDev = Number.isFinite(oat) ? (oat - ISA) : 0;
  const DA = PA + 120 * tempDev;

  // TA (simple temp correction)
  let TA = Number.isFinite(indAlt) ? indAlt : PA;
  if (Number.isFinite(oat) && Number.isFinite(indAlt)) {
    TA = indAlt + 4 * tempDev * (indAlt / 1000);
  }

  if (ALT.PA) ALT.PA.textContent = `Pressure Altitude: ${fmt(PA,0)} ft`;
  if (ALT.DA) ALT.DA.textContent = `Density Altitude: ${fmt(DA,0)} ft`;
  if (ALT.TA) ALT.TA.textContent = `True Altitude: ${fmt(TA,0)} ft`;
}

// ===== Altimeter auto-format + unit pills =====
const altSetInput = document.getElementById('A_ALTSET');
const altuPills   = document.querySelectorAll('#A_ALTU_PILLS button');

function setAltUnit(unit){
  altSetInput.dataset.unit = unit;
  altSetInput.placeholder = unit === 'inHg' ? 'e.g. 29.92' : 'e.g. 1013.2';
  altSetInput.value = ''; // keep simple: clear on unit switch (no auto-convert)
}

function formatAltimeter() {
  const unit = altSetInput.dataset.unit || 'inHg';
  let d = (altSetInput.value || '').replace(/[^0-9]/g, ''); // digits only

  if (unit === 'inHg') {
    // Insert decimal after 2 digits
    if (d.length > 2) {
      altSetInput.value = d.slice(0,2) + '.' + d.slice(2);
    } else {
      altSetInput.value = d;
    }
  } else {
    // hPa: if starts with 2-9, place decimal after 3; otherwise after 4
    const group = /^[2-9]/.test(d) ? 3 : 4;
    if (d.length > group) {
      altSetInput.value = d.slice(0, group) + '.' + d.slice(group);
    } else {
      altSetInput.value = d;
    }
  }
}

altSetInput.addEventListener('input', formatAltimeter);

altuPills.forEach(btn => {
  btn.addEventListener('click', () => {
    altuPills.forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    setAltUnit(btn.dataset.altu);
  });
});

// init (respect any pre-marked .active pill)
setAltUnit(document.querySelector('#A_ALTU_PILLS .active')?.dataset.altu || 'inHg');


// ===== OAT placeholder per unit (°C / °F) =====
const oatInput = document.getElementById('A_OAT');
const oatPills = document.querySelectorAll('#A_UNIT_PILLS button');

function setOATUnit(unit){
  oatInput.dataset.unit = unit;
  oatInput.placeholder = unit === 'F' ? 'e.g. 59' : 'e.g. 15';
}

oatPills.forEach(btn => {
  btn.addEventListener('click', () => {
    oatPills.forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    setOATUnit(btn.dataset.tunit);
  });
});

// init (respect any pre-marked .active pill)
setOATUnit(document.querySelector('#A_UNIT_PILLS .active')?.dataset.tunit || 'C');

function wireAltitudes(){
  // (Re)grab elements AFTER DOM is present
  ALT = {
    IND:    document.getElementById('A_IND'),
    FLD:    document.getElementById('A_FLD'),
    ALTSET: document.getElementById('A_ALTSET'),
    OAT:    document.getElementById('A_OAT'),
    PA:     document.getElementById('A_PA'),
    DA:     document.getElementById('A_DA'),
    TA:     document.getElementById('A_TA'),
    clear:  document.getElementById('clear-alt')
  };

  // Inputs that trigger recompute
  const recompute = ()=>{ updateAltInputVisibility(); computeAltitudes(); };
  ['input','change'].forEach(ev=>{
    [
      ALT.IND, ALT.FLD, ALT.ALTSET, ALT.OAT,
      document.getElementById('A_SRC'),
      document.getElementById('A_PA_IN')
    ].forEach(el => el?.addEventListener(ev, recompute));
  });

  // Pill groups
  const altuGroup  = document.getElementById('A_ALTU_PILLS');
  const tunitGroup = document.getElementById('A_UNIT_PILLS');

  altuGroup?.addEventListener('click', (e)=>{
    const btn = e.target.closest('button.btn.secondary[data-altu]');
    if(!btn) return;
    A_ALTU = btn.getAttribute('data-altu');   // 'inHg' | 'hPa'
    setPillActive(altuGroup, 'data-altu', A_ALTU);
    computeAltitudes();
  });

  tunitGroup?.addEventListener('click', (e)=>{
    const btn = e.target.closest('button.btn.secondary[data-tunit]');
    if(!btn) return;
    A_TUNIT = btn.getAttribute('data-tunit'); // 'C' | 'F'
    setPillActive(tunitGroup, 'data-tunit', A_TUNIT);
    computeAltitudes();
  });

  // Clear button — also reset pills
  ALT.clear?.addEventListener('click', ()=>{
    [ALT.IND, ALT.FLD, ALT.ALTSET, ALT.OAT, document.getElementById('A_PA_IN')]
      .forEach(el => { if(el) el.value=''; });

    // reset pill defaults
    A_TUNIT = 'C';
    A_ALTU  = 'inHg';
    setPillActive(tunitGroup, 'data-tunit', A_TUNIT);
    setPillActive(altuGroup,  'data-altu',  A_ALTU);

    const srcSel = document.getElementById('A_SRC');
    if (srcSel) srcSel.value = 'alt';

    recompute();
  });

  // Initial sync (show/hide PA input + compute once)
  setPillActive(tunitGroup, 'data-tunit', A_TUNIT);
  setPillActive(altuGroup,  'data-altu',  A_ALTU);
  updateAltInputVisibility();
  computeAltitudes();
}

// Run AFTER DOM is ready so elements exist
if (document.readyState === 'loading'){
  document.addEventListener('DOMContentLoaded', wireAltitudes);
} else {
  wireAltitudes();
}

/* ===== IFR FPM • ft/nm • Angle • TOD ===== */
(function(){
  const $ = (id) => document.getElementById(id);

  // Short helpers
  const FT_PER_NM = 6076.12;
  const tan = Math.tan, atan = Math.atan;

  function fpnmFromAngleDeg(deg){
    if(!Number.isFinite(deg)) return NaN;
    return FT_PER_NM * tan(toRad(deg));
  }
  function angleFromFpnm(fpnm){
    if(!Number.isFinite(fpnm)) return NaN;
    return toDeg(atan(fpnm / FT_PER_NM));
  }
  function fpmFromFpnmGs(fpnm, gs){
    if(!Number.isFinite(fpnm) || !Number.isFinite(gs) || gs<=0) return NaN;
    return fpnm * (gs/60);
  }
  function fpnmFromFpmGs(fpm, gs){
    if(!Number.isFinite(fpm) || !Number.isFinite(gs) || gs<=0) return NaN;
    return (60 * fpm) / gs;
  }
  function pctFromAngleDeg(deg){
    if(!Number.isFinite(deg)) return NaN;
    return Math.tan(toRad(deg)) * 100;
  }
  function pctFromFpnm(fpnm){
    if(!Number.isFinite(fpnm)) return NaN;
    return (fpnm / FT_PER_NM) * 100;
  }

  // === A) Core conversions ===
  const A = {
    gs: $('FPM_GS'),
    ang: $('FPM_ANGLE'),
    fpnm: $('FPM_FPNM'),
    out_fpm: $('FPM_OUT_FPM'),
    out_fpnm: $('FPM_OUT_FPNM'),
    out_ang: $('FPM_OUT_ANGLE'),
    out_pct: $('FPM_OUT_PCT'),
  };
  let A_last = 'ang'; // track which of angle vs fpnm user edited last

  function solveA(){
    const gs = numStrict(A.gs.value);
    let ang = numStrict(A.ang.value);
    let fnm = numStrict(A.fpnm.value);

    // pick source based on last edit
    if(Number.isFinite(ang) && (!Number.isFinite(fnm) || A_last==='ang')){
      fnm = fpnmFromAngleDeg(ang);
    } else if (Number.isFinite(fnm)){
      ang = angleFromFpnm(fnm);
    } else {
      // neither given → just clear outputs
      A.out_fpm.textContent = 'VSI (FPM): —';
      A.out_fpnm.textContent = 'ft / nm: —';
      A.out_ang.textContent = 'Angle: — °';
      A.out_pct.textContent = 'Gradient: — %';
      return;
    }

    const fpm = fpmFromFpnmGs(fnm, gs);
    const pct = pctFromFpnm(fnm);

    A.out_fpm.textContent  = `VSI (FPM): ${fmt(fpm,0)}`;
    A.out_fpnm.textContent = `ft / nm: ${fmt(fnm,1)}`;
    A.out_ang.textContent  = `Angle: ${fmt(ang,2)} °`;
    A.out_pct.textContent  = `Gradient: ${fmt(pct,2)} %`;
  }

  ['input','change'].forEach(ev=>{
    [A.gs, A.ang, A.fpnm].forEach(el=> el?.addEventListener(ev, solveA));
  });
  A.ang?.addEventListener('input', ()=>{ A_last='ang'; });
  A.fpnm?.addEventListener('input', ()=>{ A_last='fpnm'; });

  // === B) Required restriction ===
  const R = {
    gs: $('FPM_REQ_GS'),
    dnm: $('FPM_REQ_D'),
    dh: $('FPM_REQ_DH'),
    a0: $('FPM_REQ_ALT_CURR'),
    ax: $('FPM_REQ_ALT_XING'),
    cap: $('FPM_REQ_CAP'),
    dir: $('FPM_REQ_DIR'),
    out_fpnm: $('FPM_REQ_OUT_FPNM'),
    out_fpm: $('FPM_REQ_OUT_FPM'),
    out_ang: $('FPM_REQ_OUT_ANGLE'),
    out_pct: $('FPM_REQ_OUT_PCT'),
    pass: $('FPM_REQ_PASS'),
  };

  // === B) Required restriction ===
// (Keep your existing R = { ... } map)

function solveR(){
  // If outputs aren’t in the DOM yet, bail quietly
  if (![R.dir, R.out_fpnm, R.out_fpm, R.out_ang, R.out_pct, R.pass].every(Boolean)) return;

  // Read inputs safely (nodes might be null on first paint)
  const gs  = numStrict(R.gs?.value);
  const dnm = numStrict(R.dnm?.value);
  let   dh  = numStrict(R.dh?.value);
  const a0  = numStrict(R.a0?.value);
  const ax  = numStrict(R.ax?.value);
  const cap = numStrict(R.cap?.value);

  // override dh if both altitudes provided
  if (Number.isFinite(a0) && Number.isFinite(ax)){
    dh = a0 - ax; // positive = DESCEND
  }

  // guard
  if (!Number.isFinite(gs) || !Number.isFinite(dnm) || dnm <= 0 || !Number.isFinite(dh)){
    R.dir.textContent      = 'Direction: —';
    R.out_fpnm.textContent = 'ft / nm: —';
    R.out_fpm.textContent  = 'VSI (FPM): —';
    R.out_ang.textContent  = 'Angle: — °';
    R.out_pct.textContent  = 'Gradient: — %';
    R.pass.textContent     = 'Capability check: —';
    R.pass.style.color     = '';
    return;
  }

  const needDesc = dh > 0;
  const reqFpnm  = Math.abs(dh) / dnm;
  const reqFpm   = fpmFromFpnmGs(reqFpnm, gs);
  const reqAng   = angleFromFpnm(reqFpnm);
  const reqPct   = pctFromFpnm(reqFpnm);

  R.dir.textContent      = `Direction: ${needDesc ? 'DESCEND' : 'CLIMB'}`;
  R.out_fpnm.textContent = `ft / nm: ${fmt(reqFpnm,1)}`;
  R.out_fpm.textContent  = `VSI (FPM): ${fmt(reqFpm,0)}`;
  R.out_ang.textContent  = `Angle: ${fmt(reqAng,2)} °`;
  R.out_pct.textContent  = `Gradient: ${fmt(reqPct,2)} %`;

  if (Number.isFinite(cap)){
    const ok = cap >= reqFpm - 1e-9;
    R.pass.textContent = `Capability check: ${ok ? 'OK (meets/exceeds)' : 'INSUFFICIENT'}`;
    R.pass.style.color = ok ? '' : '#d70015';
  } else {
    R.pass.textContent = 'Capability check: —';
    R.pass.style.color = '';
  }
}

// Safe listeners (nodes may be null on first render)
['input','change'].forEach(ev=>{
  [R.gs, R.dnm, R.dh, R.a0, R.ax, R.cap].forEach(el => el?.addEventListener(ev, solveR));
});

// Initial paint
solveR();

  ['input','change'].forEach(ev=>{
    [R.gs,R.dnm,R.dh,R.a0,R.ax,R.cap].forEach(el=> el?.addEventListener(ev, solveR));
  });

  // === C) TOD ===
  const T = {
    a0: $('FPM_TOD_CURR'),
    at: $('FPM_TOD_TGT'),
    gs: $('FPM_TOD_GS'),
    ang: $('FPM_TOD_ANGLE'),
    fpnm: $('FPM_TOD_FPNM'),
    outD: $('FPM_TOD_DIST'),
    outT: $('FPM_TOD_TIME'),
  };
  let T_last = 'ang';

  function solveT(){
  // If T or the outputs aren't ready yet, bail quietly
  if (!T) return;
  const outputsReady = [T.dir, T.out_fpnm, T.out_fpm, T.out_ang, T.out_pct, T.pass].every(Boolean);

  // Read inputs safely (the nodes may not exist yet)
  const a0  = numStrict(T.a0?.value);
  const at  = numStrict(T.at?.value);
  let   ang = numStrict(T.ang?.value);
  let   fnm = numStrict(T.fpnm?.value);
  const gs  = numStrict(T.gs?.value);

  // If we can’t even show placeholders (no outputs), stop here
  if (!outputsReady) return;

  // Basic guard — if nothing usable, show dashes
  const anyUsable =
    Number.isFinite(a0) || Number.isFinite(at) ||
    Number.isFinite(ang) || Number.isFinite(fnm) || Number.isFinite(gs);

  if (!anyUsable){
    T.dir.textContent      = 'Direction: —';
    T.out_fpnm.textContent = 'ft / nm: —';
    T.out_fpm.textContent  = 'VSI (FPM): —';
    T.out_ang.textContent  = 'Angle: — °';
    T.out_pct.textContent  = 'Gradient: — %';
    T.pass.textContent     = 'Capability check: —';
    T.pass.style.color     = '';
    return;
  }

  // >>> Your existing math/logic stays the same below <<<
  // (Use your helpers like angleFromFpnm, pctFromFpnm, fpmFromFpnmGs, etc.)
  // Make sure to guard each branch with Number.isFinite(...) before computing.
}

  ['input','change'].forEach(ev=>{
    [T.a0,T.at,T.gs,T.ang,T.fpnm].forEach(el=> el?.addEventListener(ev, solveT));
  });
  T.ang?.addEventListener('input', ()=>{ T_last='ang'; });
  T.fpnm?.addEventListener('input', ()=>{ T_last='fpnm'; });
  document.querySelectorAll('[data-tod-angle]').forEach(b=>{
    b.addEventListener('click', ()=>{
      if(!T.ang) return;
      T.ang.value = b.getAttribute('data-tod-angle');
      T_last='ang';
      solveT();
    });
  });

  // === D) Inline GS helper ===
  const GH = {
    tas: $('FPM_H_TAS'),
    tc:  $('FPM_H_TC'),
    wf:  $('FPM_H_WDIR'),
    w:   $('FPM_H_WSPD'),
    out: $('FPM_H_GS_OUT'),
    apply: $('FPM_H_APPLY'),
  };
  function solveGH(){
    const tas = numStrict(GH.tas.value);
    const tc  = clamp360(numStrict(GH.tc.value));
    const wf  = clamp360(numStrict(GH.wf.value));
    const w   = numStrict(GH.w.value);
    if(!Number.isFinite(tas)||!Number.isFinite(tc)||!Number.isFinite(wf)||!Number.isFinite(w)){
      GH.out.textContent = 'GS: — kt';
      return;
    }
    const sol = windSolve(tas, tc, wf, w);
    GH.out.textContent = `GS: ${fmt(sol?.GS,1)} kt`;
    return sol?.GS;
  }
  ['input','change'].forEach(ev=>{
    [GH.tas,GH.tc,GH.wf,GH.w].forEach(el=> el?.addEventListener(ev, solveGH));
  });
  GH.apply?.addEventListener('click', ()=>{
    const gs = solveGH();
    if(Number.isFinite(gs)){
      if(A.gs) A.gs.value = gs.toFixed(1);
      if(R.gs) R.gs.value = gs.toFixed(1);
      if(T.gs) T.gs.value = gs.toFixed(1);
      solveA(); solveR(); solveT();
    }
  });

  // Clear
  $('clear-fpm')?.addEventListener('click', ()=>{
    ['FPM_GS','FPM_ANGLE','FPM_FPNM',
     'FPM_REQ_GS','FPM_REQ_D','FPM_REQ_DH','FPM_REQ_ALT_CURR','FPM_REQ_ALT_XING','FPM_REQ_CAP',
     'FPM_TOD_CURR','FPM_TOD_TGT','FPM_TOD_GS','FPM_TOD_ANGLE','FPM_TOD_FPNM',
     'FPM_H_TAS','FPM_H_TC','FPM_H_WDIR','FPM_H_WSPD'
    ].forEach(id=>{ const el=$(id); if(el) el.value=''; });

    // reset outputs
    solveA(); solveR(); solveT(); solveGH();
  });

    // === Local Time auto-colon (Time & Time Zones) ===
const TZ_LOCAL = document.querySelector('[data-tz="local"]');

TZ_LOCAL?.setAttribute('inputmode','numeric');
TZ_LOCAL?.setAttribute('placeholder','HH:MM');
TZ_LOCAL?.setAttribute('maxlength','5'); // "12:34"

TZ_LOCAL?.addEventListener('input', () => {
  // keep only digits, limit to 4 (HHMM)
  let d = (TZ_LOCAL.value || '').replace(/\D/g, '').slice(0, 4);
  // insert ":" after HH if we have minutes
  if (d.length > 2) d = d.slice(0,2) + ':' + d.slice(2);
  TZ_LOCAL.value = d;
});

TZ_LOCAL?.addEventListener('blur', () => {
  // tidy: "123" -> "12:03", "12" -> "12:00"
  const m = /^(\d{1,2})(?::?(\d{1,2}))?$/.exec(TZ_LOCAL.value || '');
  if (!m) return;
  let hh = m[1], mm = m[2] ?? '';
  if (mm.length === 1) mm = '0' + mm;
  if (mm.length === 0 && (TZ_LOCAL.value || '').length >= 2) mm = '00';
  TZ_LOCAL.value = mm ? `${hh}:${mm}` : hh;
});

  // Initial paint
  solveA(); solveR(); solveT(); solveGH();
})();

/* ===== ETP / PNR ===== */
const etpIds = ['D_nm','GS_out','GS_ret','Endurance'];
const etpInputs = Object.fromEntries(etpIds.map(id=>[id, document.getElementById(id)]));
const etpOut = {
  dist: document.getElementById('etpDist'),
  time: document.getElementById('etpTime'),
  pnrD: document.getElementById('pnrDist'),
  pnrT: document.getElementById('pnrTime'),
  etpLeg: document.getElementById('etpLeg'),   // NEW: single line for time from ETP
};

function computeETPPNR(){
  const D   = numStrict(etpInputs.D_nm.value);
  const GSo = numStrict(etpInputs.GS_out.value); // A→B GS
  const GSr = numStrict(etpInputs.GS_ret.value); // B→A GS
  const E   = parseEndurance(etpInputs.Endurance.value);

  let ETPd = NaN, ETPt = NaN, PNRt = NaN, PNRd = NaN, ETPlegT = NaN;

  // ETP (from A)
  if (Number.isFinite(D) && Number.isFinite(GSo) && Number.isFinite(GSr) && (GSo+GSr) > 0){
    ETPd   = D * (GSr / (GSo + GSr)); // distance A→ETP
    ETPt   = ETPd / GSo;               // time A→ETP
    ETPlegT = ETPd / GSr;              // time from ETP back to A, same as forward to B
  }

  // PNR (from A)
  if (Number.isFinite(E) && Number.isFinite(GSo) && Number.isFinite(GSr) && (GSo+GSr) > 0){
    PNRt = E * (GSr / (GSo + GSr));
    PNRd = PNRt * GSo;
  }

  etpOut.dist.textContent = `Dist: ${fmt(ETPd,1)} nm`;
  etpOut.time.textContent = `Time: ${hhmm(ETPt)}`;
  etpOut.pnrD.textContent = `Dist: ${fmt(PNRd,1)} nm`;
  etpOut.pnrT.textContent = `Time: ${hhmm(PNRt)}`;
  if (etpOut.etpLeg) etpOut.etpLeg.textContent = `Time from ETP: ${hhmm(ETPlegT)}`;
}

Object.values(etpInputs).forEach(el=>el.addEventListener('input', computeETPPNR));

document.getElementById('swap-etp').addEventListener('click', ()=>{
  const a = etpInputs.GS_out.value;
  etpInputs.GS_out.value = etpInputs.GS_ret.value;
  etpInputs.GS_ret.value = a;
  computeETPPNR();
});

document.getElementById('clear-etp').addEventListener('click', () => {
  // 1) Clear core ETP/PNR inputs
  Object.values(etpInputs).forEach(el => { el.value = ''; });

  // 2) Clear Groundspeed Helper inputs (TAS, TC, wind, optional return TAS)
  [gsEls.TAS, gsEls.TC, gsEls.WF, gsEls.W, gsEls.TASr].forEach(el => {
    if (el) el.value = '';
  });

  // 3) Reset Groundspeed Helper readouts (so user sees it cleared immediately)
  if (gsEls.GSout)  gsEls.GSout.textContent  = 'GS: — kt';
  if (gsEls.WCAout) gsEls.WCAout.textContent = 'WCA: — ° (R+ / L–)';
  if (gsEls.HDGout) gsEls.HDGout.textContent = 'Suggested HDG: — °';
  if (gsEls.GSret)  gsEls.GSret.textContent  = 'GS: — kt';
  if (gsEls.WCAret) gsEls.WCAret.textContent = 'WCA: — ° (R+ / L–)';
  if (gsEls.HDGret) gsEls.HDGret.textContent = 'Suggested HDG: — °';

  // 4) Recompute to clear the ETP/PNR outputs and redraw the visuals
  computeGSHelper();
  computeETPPNR();
});

computeETPPNR();

/* Groundspeed helper (auto-fill GS A→B and B→A) */
const gsEls = {
  TAS:  document.getElementById('TAS_helper'),
  TC:   document.getElementById('TC_out'),
  WF:   document.getElementById('WindFrom'),
  W:    document.getElementById('WindSpeed'),
  TASr: document.getElementById('TAS_ret_helper'),

  GSout:  document.getElementById('GS_out_calc'),
  WCAout: document.getElementById('WCA_out_calc'),
  HDGout: document.getElementById('HDG_out_calc'),
  GSret:  document.getElementById('GS_ret_calc'),
  WCAret: document.getElementById('WCA_ret_calc'),
  HDGret: document.getElementById('HDG_ret_calc'),

  apply:  document.getElementById('apply_gs'),       // may exist in your HTML
  reset:  document.getElementById('clear_gs_helper') // reset button
};

function computeGSHelper(){
  const TAS = numStrict(gsEls.TAS.value);
  const TC  = clamp360(numStrict(gsEls.TC.value));
  const WF  = clamp360(numStrict(gsEls.WF.value));
  const W   = numStrict(gsEls.W.value);
  const TASrStr = (gsEls.TASr?.value ?? '').trim();

  // If inputs are incomplete, show placeholders and don't overwrite main GS fields
  if(!Number.isFinite(TAS) || !Number.isFinite(TC) || !Number.isFinite(WF) || !Number.isFinite(W)){
    gsEls.GSout.textContent  = 'GS: — kt';
    gsEls.WCAout.textContent = 'WCA: — ° (R+ / L–)';
    gsEls.HDGout.textContent = 'Suggested HDG: — °';
    gsEls.GSret.textContent  = 'GS: — kt';
    gsEls.WCAret.textContent = 'WCA: — ° (R+ / L–)';
    gsEls.HDGret.textContent = 'Suggested HDG: — °';
    return;
  }

  // Solve outbound and reciprocal
  const out = windSolve(TAS, TC, WF, W);
  const TASret = (TASrStr === '') ? TAS : numStrict(TASrStr);
  const ret = windSolve(TASret, clamp360(TC + 180), WF, W);

  // Update helper readouts
  gsEls.GSout.textContent  = `GS: ${fmt(out?.GS,1)} kt`;
  gsEls.WCAout.textContent = `WCA: ${fmt(out?.WCA,1)} ° (R+ / L–)`;
  gsEls.HDGout.textContent = `Suggested HDG: ${fmt(out?.HDG,1)} °`;
  gsEls.GSret.textContent  = `GS: ${fmt(ret?.GS,1)} kt`;
  gsEls.WCAret.textContent = `WCA: ${fmt(ret?.WCA,1)} ° (R+ / L–)`;
  gsEls.HDGret.textContent = `Suggested HDG: ${fmt(ret?.HDG,1)} °`;

  // AUTO-FILL main GS fields when valid
  if (out && Number.isFinite(out.GS))  etpInputs.GS_out.value = out.GS.toFixed(1);
  if (ret && Number.isFinite(ret.GS))  etpInputs.GS_ret.value = ret.GS.toFixed(1);

  // Recompute ETP/PNR since GS fields just updated
  computeETPPNR();
}

// Recalculate on any helper input change
['input','change'].forEach(ev=>{
  [gsEls.TAS, gsEls.TC, gsEls.WF, gsEls.W, gsEls.TASr].forEach(el=>{
    if (el) el.addEventListener(ev, computeGSHelper);
  });
});

// Optional: hide the old "Fill GS fields above" button if it exists
if (gsEls.apply) gsEls.apply.style.display = 'none';

// Reset button keeps working
if (gsEls.reset) {
  gsEls.reset.addEventListener('click', ()=>{
    [gsEls.TAS, gsEls.TC, gsEls.WF, gsEls.W, gsEls.TASr].forEach(el=>{ if(el) el.value=''; });
    computeGSHelper();
  });
}

// Initial compute
computeGSHelper();

/* ===== Meetpoint ===== */
const M = {
  D:  document.getElementById('M_D'),
  TC: document.getElementById('M_TC'),
  WF: document.getElementById('M_WF'),
  W:  document.getElementById('M_W'),
  TAS_A: document.getElementById('M_TAS_A'),
  GS_A:  document.getElementById('M_GS_A'),
  TAS_B: document.getElementById('M_TAS_B'),
  GS_B:  document.getElementById('M_GS_B'),
  outGSA: document.getElementById('M_GS_A_out'),
  outGSB: document.getElementById('M_GS_B_out'),
  intoA:  document.getElementById('M_into_A'),
  intoB:  document.getElementById('M_into_B'),
  time:   document.getElementById('M_time'),
  clear:  document.getElementById('clear-meet'),
};
function computeMeet(){
  const D = numStrict(M.D.value);
  const TC = clamp360(numStrict(M.TC.value));
  if(!Number.isFinite(D) || !Number.isFinite(TC)){
    M.outGSA.textContent='A GS: — kt';
    M.outGSB.textContent='B GS: — kt';
    M.intoA.textContent='Distance into A: — nm';
    M.intoB.textContent='Distance into B: — nm';
    M.time.textContent='Time to meet: — hh:mm';
    return;
  }
  // GS A
  let GSa = numStrict(M.GS_A.value);
  let GSb = numStrict(M.GS_B.value);
  const WF = numStrict(M.WF.value);
  const W  = numStrict(M.W.value);

  if(!Number.isFinite(GSa) && Number.isFinite(WF) && Number.isFinite(W)){
    const a = windSolve(numStrict(M.TAS_A.value), TC, WF, W);
    if(a) GSa = a.GS;
  }
  if(!Number.isFinite(GSb) && Number.isFinite(WF) && Number.isFinite(W)){
    const b = windSolve(numStrict(M.TAS_B.value), clamp360(TC+180), WF, W);
    if(b) GSb = b.GS;
  }
  M.outGSA.textContent = `A GS: ${fmt(GSa,1)} kt`;
  M.outGSB.textContent = `B GS: ${fmt(GSb,1)} kt`;

  if(Number.isFinite(GSa) && Number.isFinite(GSb) && (GSa+GSb)>0){
    const intoA = D * (GSa/(GSa+GSb));
    const intoB = D - intoA;
    const t = intoA / GSa; // hours
    M.intoA.textContent = `Distance into A: ${fmt(intoA,2)} nm`;
    M.intoB.textContent = `Distance into B: ${fmt(intoB,2)} nm`;
    M.time.textContent = `Time to meet: ${hhmm(t)}`;
  } else {
    M.intoA.textContent = 'Distance into A: — nm';
    M.intoB.textContent = 'Distance into B: — nm';
    M.time.textContent = 'Time to meet: — hh:mm';
  }
}
['input','change'].forEach(ev=>{
  [M.D,M.TC,M.WF,M.W,M.TAS_A,M.GS_A,M.TAS_B,M.GS_B].forEach(el=>el.addEventListener(ev, computeMeet));
});
M.clear.addEventListener('click', ()=>{
  [M.D,M.TC,M.WF,M.W,M.TAS_A,M.GS_A,M.TAS_B,M.GS_B].forEach(el=>el.value='');
  computeMeet();
});
computeMeet();

/* ===== VOR Triangle ===== */
const VT = {
  AB: document.getElementById('VT_AB'),
  RA: document.getElementById('VT_R_A'),
  RB: document.getElementById('VT_R_B'),
  TC: document.getElementById('VT_TC'),
  outA: document.getElementById('VT_A'),
  outB: document.getElementById('VT_B'),
  angs: document.getElementById('VT_angles'),
  courseB: document.getElementById('VT_courseB'),
  clear: document.getElementById('clear-vor'),
  // optional time
  GS_B: document.getElementById('VT_GS_B'),
  TAS_B: document.getElementById('VT_TAS_B'),
  WF: document.getElementById('VT_WF'),
  W:  document.getElementById('VT_W'),
  time: document.getElementById('VT_time'),
  gsused: document.getElementById('VT_GS_used'),
};
function computeVOR(){
  const c = numStrict(VT.AB.value);
  const RA = clamp360(numStrict(VT.RA.value));
  const RB = clamp360(numStrict(VT.RB.value));
  const TC = clamp360(numStrict(VT.TC.value));
  if(!Number.isFinite(c) || !Number.isFinite(RA) || !Number.isFinite(RB) || !Number.isFinite(TC)){
    VT.outA.textContent = 'VOR→A: — nm';
    VT.outB.textContent = 'VOR→B: — nm';
    VT.angs.textContent = 'Angles A / VOR / B: — / — / — °';
    VT.courseB.textContent = 'Course B→VOR: — °';
    VT.time.textContent = 'Time: — hh:mm';
    VT.gsused.textContent = 'GS used: — kt (course B→VOR shown below)';
    return;
  }
  const inboundA = clamp360(RA + 180);
  const inboundB = clamp360(RB + 180);
  const TC_BA = clamp360(TC + 180);
  const angleA = Math.min(Math.abs(clamp360(inboundA - TC)), 360 - Math.abs(clamp360(inboundA - TC)));
  const angleB = Math.min(Math.abs(clamp360(inboundB - TC_BA)), 360 - Math.abs(clamp360(inboundB - TC_BA)));
  const angleV = Math.min(Math.abs(clamp360(RB - RA)), 360 - Math.abs(clamp360(RB - RA)));
  const sum = angleA + angleB + angleV;
  // Law of sines for sides opposite angles A,B,V (with c opposite V known)
  const a = c * Math.sin(toRad(angleA)) / Math.sin(toRad(angleV)); // side a = VOR→B
  const b = c * Math.sin(toRad(angleB)) / Math.sin(toRad(angleV)); // side b = VOR→A

  VT.outA.textContent = `VOR→A: ${fmt(b,2)} nm`;
  VT.outB.textContent = `VOR→B: ${fmt(a,2)} nm`;
  VT.angs.textContent = `Angles A / VOR / B: ${fmt(angleA,1)} / ${fmt(angleV,1)} / ${fmt(angleB,1)} °`;
  const courseBtoVOR = inboundB; // inbound to VOR from B
  VT.courseB.textContent = `Course B→VOR: ${fmt(courseBtoVOR,1)} °`;

  // Optional time using GS override or TAS+wind
  let GSb = numStrict(VT.GS_B.value);
  if(!Number.isFinite(GSb)){
    const tasb = numStrict(VT.TAS_B.value);
    const wf = numStrict(VT.WF.value);
    const w = numStrict(VT.W.value);
    const sol = windSolve(tasb, courseBtoVOR, wf, w);
    if(sol) GSb = sol.GS;
  }
  if(Number.isFinite(GSb) && Number.isFinite(a) && GSb>0){
    const t = (a/GSb);
    VT.time.textContent = `Time: ${hhmm(t)}`;
    VT.gsused.textContent = `GS used: ${fmt(GSb,1)} kt (course B→VOR above)`;
  } else {
    VT.time.textContent = 'Time: — hh:mm';
    VT.gsused.textContent = 'GS used: — kt (course B→VOR shown below)';
  }
}
['input','change'].forEach(ev=>{
  [VT.AB,VT.RA,VT.RB,VT.TC,VT.GS_B,VT.TAS_B,VT.WF,VT.W].forEach(el=>el.addEventListener(ev, computeVOR));
});
VT.clear.addEventListener('click', ()=>{
  [VT.AB,VT.RA,VT.RB,VT.TC,VT.GS_B,VT.TAS_B,VT.WF,VT.W].forEach(el=>el.value='');
  computeVOR();
});
computeVOR();

/* ===== Great Circle ===== */
const gc = {
  lat1: document.getElementById('lat1'),
  lon1: document.getElementById('lon1'),
  lat2: document.getElementById('lat2'),
  lon2: document.getElementById('lon2'),
  dist: document.getElementById('gcDist'),
  bear: document.getElementById('gcBear'),
};

const hemiSel = {
  lat1: 'N', lon1: 'W',
  lat2: 'N', lon2: 'W'
};

function showSegments(){
  const modeSel = document.getElementById('gcFormat');
  const mode = modeSel?.value || 'decimal';
  const useSeg = (mode === 'dm' || mode === 'dms');

  const pairs = [
    { raw: gc.lat1, seg: document.getElementById('seg-lat1'), id:'lat1' },
    { raw: gc.lon1, seg: document.getElementById('seg-lon1'), id:'lon1' },
    { raw: gc.lat2, seg: document.getElementById('seg-lat2'), id:'lat2' },
    { raw: gc.lon2, seg: document.getElementById('seg-lon2'), id:'lon2' },
  ];

  pairs.forEach(p=>{
    if (!p.seg || !p.raw) return;
    if (useSeg){
      p.seg.hidden = false;
      p.raw.style.display = 'none';
      // SS visible only in DMS
      const needSS = (mode === 'dms');
      const ss = p.seg.querySelector('.ss');
      const ssSep = document.getElementById(p.id + '_ss_sep');
      if (ss){ ss.hidden = !needSS; }
      if (ssSep){ ssSep.hidden = !needSS; }
    } else {
      p.seg.hidden = true;
      p.raw.style.display = '';   // show the single decimal box
    }
  });
}

function segToDecimal(prefix, isLat){
  // read fields
  let dd = Number(document.getElementById(prefix+'_dd')?.value || '0');
  let mm = Number(document.getElementById(prefix+'_mm')?.value || '0');
  let ss = Number(document.getElementById(prefix+'_ss')?.value || '0');

  if (!Number.isFinite(dd) || !Number.isFinite(mm) || !Number.isFinite(ss)) return NaN;

  // magnitude from absolute values (we control sign from hemisphere)
  const mag = Math.abs(dd) + (mm/60) + (ss/3600);

  // hemisphere from toggle (fallbacks keep things sane)
  const hemi = hemiSel[prefix] || (isLat ? 'N' : 'E');
  let sign = 1;
  if (isLat) sign = (hemi === 'S') ? -1 : 1;
  else       sign = (hemi === 'W') ? -1 : 1;

  let val = sign * mag;

  // clamp like before
  if (isLat){
    val = Math.max(-90, Math.min(90, val));
  } else {
    // normalize to [-180,180)
    val = ((val + 180) % 360 + 360) % 360 - 180;
  }
  return val;
}

function readLatLon(){
  return {
    lat1: segToDecimal('lat1', true),
    lon1: segToDecimal('lon1', false),
    lat2: segToDecimal('lat2', true),
    lon2: segToDecimal('lon2', false),
  };
}

function wireAutoAdvance(){
  const groups = ['lat1','lon1','lat2','lon2'];
  groups.forEach((prefix, gi)=>{
    const dd = document.getElementById(prefix+'_dd');
    const mm = document.getElementById(prefix+'_mm');
    const ss = document.getElementById(prefix+'_ss');

    [dd, mm, ss].forEach((el, i, arr)=>{
      el.addEventListener('input', ()=>{
        let max = Number(el.getAttribute('maxlength')||'2');

        // --- Special case: degrees field ---
        if (el === dd){
          const v = el.value;
          if (prefix.startsWith('lon')) {
            // Longitude: 3 digits only if it starts with '1'
            if (v.length === 2 && parseInt(v[0]) >= 2) {
              max = 2;
            } else if (v.length === 3) {
              max = 3;
            }
          } else {
            // Latitude: max 2 digits (00-90)
            max = 2;
          }
        }

        if (el.value.length >= max){
          if (i < arr.length-1){
            arr[i+1].focus();
          } else {
            const nextGroup = groups[gi+1];
            if (nextGroup){
              document.getElementById(nextGroup+'_dd').focus();
            }
          }
        }
        computeGC();
      });
      el.addEventListener('change', computeGC);
      el.addEventListener('blur', computeGC);
    });
  });
}

['lat1','lon1','lat2','lon2'].forEach(prefix=>{
  document.getElementById('clear-'+prefix).addEventListener('click', ()=>{
    document.getElementById(prefix+'_dd').value = '';
    document.getElementById(prefix+'_mm').value = '';
    document.getElementById(prefix+'_ss').value = '';
    computeGC();
  });
});

document.addEventListener('click', (e)=>{
  const btn = e.target.closest('.hemi-btn');
  if(!btn) return;

  const tgt  = btn.getAttribute('data-target');   // lat1 / lon1 / lat2 / lon2
  const axis = btn.getAttribute('data-axis');     // 'lat' or 'lon'
  const val  = btn.getAttribute('data-val');      // 'N'/'S' or 'E'/'W'

  // update model
  hemiSel[tgt] = val;

  // toggle pressed state within this small group
  const group = btn.parentElement.querySelectorAll('.hemi-btn');
  group.forEach(b => b.setAttribute('aria-pressed', String(b===btn)));

  // recompute bearing/distance
  computeGC();
});

// Init
computeGC();
wireAutoAdvance();

// Hook format changes
document.getElementById('gcFormat')?.addEventListener('change', ()=>{
  showSegments(true);
  computeGC();
});

// Initial setup
showSegments(true);
wireAutoAdvance();

// --- Coordinate parsing supporting multiple formats ---
function clampLon(lon){ // normalize to [-180,180)
  lon = ((lon + 180) % 360 + 360) % 360 - 180;
  return lon;
}
function clampLat(lat){ // keep within [-90,90], caller responsible for realistic inputs
  return Math.max(-90, Math.min(90, lat));
}

/**
 * Parses latitude/longitude according to a 'mode'.
 * Accepts optional separators and symbols; whitespace ignored.
 * Modes:
 *  - decimal : ±DD.dddd
 *  - dm      : DD°MM.m (sign on degrees)
 *  - dms     : DD°MM′SS″ (sign on degrees)
 *  - hem_dm  : DD°MM.m + N/S/E/W (hemisphere sets sign)
 *  - hem_dms : DD°MM′SS″ + N/S/E/W
 */
function parseCoordByMode(str, mode, isLat){
  if (!str) return NaN;
  let s = str.trim().toUpperCase().replace(/\s+/g,'');
  // Allow plain 'N','S','E','W' suffix or prefix (prefix rare but tolerate)
  let hemi = null;
  const hemiMatch = s.match(/^([NSEW])/);
  if (hemiMatch) { hemi = hemiMatch[1]; s = s.slice(1); }
  const hemiMatch2 = s.match(/([NSEW])$/);
  if (hemiMatch2){ hemi = hemiMatch2[1]; s = s.slice(0,-1); }

  // Helpers
  const applyHemisphere = (degSigned)=>{
    if (hemi){
      if (hemi === 'S' || hemi === 'W') return -Math.abs(degSigned);
      if (hemi === 'N' || hemi === 'E') return  Math.abs(degSigned);
    }
    return degSigned;
  };

  // Accept compact notations like DDMM.m or DDMMSS as a fallback for dm/dms modes
  const dmCompact = /^(-?\d{1,3})(\d{2}(?:\.\d+)?)$/;        // e.g., 3720.5
  const dmsCompact = /^(-?\d{1,3})(\d{2})(\d{2}(?:\.\d+)?)$/; // e.g., 372030 or 372030.5

  // Generic extractors (with symbols optional)
  const dmRegex  = /^(-?\d{1,3})[°:]?(\d{1,2}(?:\.\d+)?)'?$/;                 // 37°20.5 or 37:20.5 or 37 20.5
  const dmsRegex = /^(-?\d{1,3})[°:]?(\d{1,2})['′:]?(\d{1,2}(?:\.\d+)?)["″]?$/; // 37°20′30″ / 37:20:30

  const asDecimal = (x)=>{
    const n = Number(x);
    if (!Number.isFinite(n)) return NaN;
    return n;
  };

  let deg, min, sec;

  switch(mode){
    case 'decimal': {
      let val = asDecimal(s);
      if (!Number.isFinite(val)) return NaN;
      // Hemisphere (if present) overrides sign
      val = applyHemisphere(val);
      return isLat ? clampLat(val) : clampLon(val);
    }

    case 'dm':
    case 'hem_dm': {
      let m = s.match(dmRegex);
      if (!m){
        m = s.match(dmCompact); // try compact DDMM.m
        if (m) {
          deg = Number(m[1]); min = Number(m[2]);
        }
      } else {
        deg = Number(m[1]); min = Number(m[2]);
      }
      if (deg === undefined || !Number.isFinite(min)) return NaN;
      let sign = deg < 0 ? -1 : 1;
      let val = Math.abs(deg) + (min/60);
      val = sign * val;
      if (mode === 'hem_dm') val = applyHemisphere(val);
      return isLat ? clampLat(val) : clampLon(val);
    }

    case 'dms':
    case 'hem_dms': {
      let m = s.match(dmsRegex);
      if (!m){
        m = s.match(dmsCompact); // try compact DDMMSS(.s)
        if (m) {
          deg = Number(m[1]); min = Number(m[2]); sec = Number(m[3]);
        }
      } else {
        deg = Number(m[1]); min = Number(m[2]); sec = Number(m[3]);
      }
      if (deg === undefined || !Number.isFinite(min) || !Number.isFinite(sec)) return NaN;
      let sign = deg < 0 ? -1 : 1;
      let val = Math.abs(deg) + (min/60) + (sec/3600);
      val = sign * val;
      if (mode === 'hem_dms') val = applyHemisphere(val);
      return isLat ? clampLat(val) : clampLon(val);
    }
  }
  return NaN;
}

// Update placeholders + mobile keyboard based on format
function updateGCInputsForMode(){
  const modeSel = document.getElementById('gcFormat');
  if (!modeSel) return;
  const mode = modeSel.value;

  const latPH = {
    decimal:  'e.g., 37.3333',
    dm:       'e.g., 37°20.5',
    dms:      'e.g., 37°20′30″',
    hem_dm:   'e.g., 37°20.5N',
    hem_dms:  'e.g., 37°20′30″N',
  }[mode];

  const lonPH = {
    decimal:  'e.g., -79.2000',
    dm:       'e.g., 079°12.0',
    dms:      'e.g., 079°12′00″',
    hem_dm:   'e.g., 079°12.0W',
    hem_dms:  'e.g., 079°12′00″W',
  }[mode];

  const latInputs = [gc.lat1, gc.lat2];
  const lonInputs = [gc.lon1, gc.lon2];

  // If mode has letters/symbols, use text keypad; else decimal keypad
  const isTexty = (mode !== 'decimal');

  [...latInputs, ...lonInputs].forEach(el=>{
    if (!el) return;
    el.placeholder = (latInputs.includes(el) ? latPH : lonPH);
    el.setAttribute('autocomplete','off');
    el.setAttribute('enterkeyhint','done');
    if (isTexty){
      el.setAttribute('inputmode','text');
      el.removeAttribute('pattern');
    } else {
      el.setAttribute('inputmode','decimal');
      el.setAttribute('pattern','-?[0-9]*\\.?[0-9]*');
    }
  });
  // Recompute with new interpretation
  computeGC();
}
document.getElementById('gcFormat')?.addEventListener('change', updateGCInputsForMode);

function computeGC(){
  const { lat1, lon1, lat2, lon2 } = readLatLon();

  const φ1 = toRad(lat1);
  const λ1 = toRad(lon1);
  const φ2 = toRad(lat2);
  const λ2 = toRad(lon2);

  if ([φ1, λ1, φ2, λ2].some(v => Number.isNaN(v))) {
    gc.dist.textContent = 'Distance: — nm';
    gc.bear.textContent = 'True course: — °';
    return;
  }

  const dφ = φ2 - φ1;
  const dλ = λ2 - λ1;
  const a = Math.sin(dφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(dλ/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  const Rnmi = 3440.065;
  const d_nm = Rnmi * c;

  const y = Math.sin(dλ)*Math.cos(φ2);
  const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(dλ);
  let θ = Math.atan2(y, x);
  θ = (toDeg(θ)+360)%360;

  gc.dist.textContent = `Distance: ${fmt(d_nm,1)} nm`;
  gc.bear.textContent = `True course: ${fmt(θ,1)} °`;
}   // <<< END OF computeGC

// Event wiring: recompute as user types (guard against nulls)
['input','change'].forEach(ev=>{
  [gc.lat1,gc.lon1,gc.lat2,gc.lon2].forEach(el=>{
    if (el) el.addEventListener(ev, computeGC);
  });
});

// CLEAR ALL within the Lat/Long tile
document.getElementById('clear-gc').addEventListener('click', ()=>{
  // 1) Clear all segment inputs (DD, MM, SS)
  ['lat1','lon1','lat2','lon2'].forEach(prefix=>{
    const dd = document.getElementById(prefix+'_dd');
    const mm = document.getElementById(prefix+'_mm');
    const ss = document.getElementById(prefix+'_ss');
    if (dd) dd.value = '';
    if (mm) mm.value = '';
    if (ss) ss.value = '';
  });

  // 2) Clear any raw decimal boxes if you add them later (currently none exist)
  [gc.lat1, gc.lon1, gc.lat2, gc.lon2].forEach(el=>{
    if (el) el.value = '';
  });

  // 3) Reset hemisphere toggles to defaults (N for lats, W for lons)
  hemiSel.lat1 = 'N'; hemiSel.lon1 = 'W';
  hemiSel.lat2 = 'N'; hemiSel.lon2 = 'W';

  // Update the aria-pressed states in the UI
  ['lat1','lon1','lat2','lon2'].forEach(tgt=>{
    const buttons = document.querySelectorAll(`.hemi-btn[data-target="${tgt}"]`);
    buttons.forEach(b => b.setAttribute('aria-pressed','false'));
    const want = tgt.startsWith('lat') ? 'N' : 'W';
    const btn = document.querySelector(`.hemi-btn[data-target="${tgt}"][data-val="${want}"]`);
    if (btn) btn.setAttribute('aria-pressed','true');
  });

  // 4) Refresh outputs
  computeGC();
});

// Init
computeGC();
updateGCInputsForMode();
showSegments();      // don’t force it, just respect the dropdown
wireAutoAdvance();

/* ===== TAS (simplified) ===== */
const tas = {
  cas: document.getElementById('cas'),
  palt: document.getElementById('palt'),
  oatc: document.getElementById('oatc'),
  comp: document.getElementById('compress'),
  out: document.getElementById('tasOut'),
};
function sigmaAtPAandTemp(pa_ft, oatC){
  const T0 = 288.15; const p0 = 101325; const Lm = 0.0065; const R = 287.058; const g = 9.80665;
  const h = pa_ft*0.3048; const T = (oatC+273.15);
  const p = p0 * Math.pow(1 - (Lm*h)/T0, g/(R*Lm));
  const rho = p/(R*T); const rho0 = 1.225;
  return rho/rho0;
}
function computeTAS(){
  const cas = numStrict(tas.cas.value);
  const pa  = numStrict(tas.palt.value);
  const oat = numStrict(tas.oatc.value);
  if(!Number.isFinite(cas)||!Number.isFinite(pa)||!Number.isFinite(oat)){
    tas.out.textContent = 'TAS: — kt';
    return;
  }
  let EAS = cas;
  if(tas.comp.checked){
    const a = Math.sqrt(1.4*287*(oat+273.15));
    const cas_ms = cas*0.514444;
    const M = cas_ms / a;
    EAS = cas / (1 + 0.2*Math.max(0, M*M));
  }
  const sigma = sigmaAtPAandTemp(pa, oat);
  const TASv = EAS / Math.sqrt(sigma);
  tas.out.textContent = `TAS: ${fmt(TASv,1)} kt`; 
}
[tas.cas,tas.palt,tas.oatc,tas.comp].forEach(el=>el.addEventListener('input', computeTAS));
document.getElementById('clear-tas').addEventListener('click', ()=>{
  [tas.cas,tas.palt,tas.oatc].forEach(el=>el.value=''); tas.comp.checked=false; computeTAS();
});
computeTAS();

(function(){
  const oat = document.getElementById('oatc');
  if(!oat) return;
  oat.setAttribute('inputmode','decimal');
  oat.setAttribute('pattern','[0-9]*\\.?[0-9]*'); // digits + optional dot
})();

</script>

<script>
// ===== SDT (Universal) =====
(function(){
  // Unit selects
  const uV = document.getElementById('SDT_u_v');
  const uD = document.getElementById('SDT_u_d');
  const uT = document.getElementById('SDT_u_t');

  // Single-leg
  const v = document.getElementById('SDT_v');
  const d = document.getElementById('SDT_d');
  const t = document.getElementById('SDT_t');
  const vOut = document.getElementById('SDT_v_out');
  const dOut = document.getElementById('SDT_d_out');
  const tOut = document.getElementById('SDT_t_out');

  // Multi-leg
  const d1 = document.getElementById('SDT_d1'), t1 = document.getElementById('SDT_t1');
  const d2 = document.getElementById('SDT_d2'), t2 = document.getElementById('SDT_t2');
  const d3 = document.getElementById('SDT_d3'), t3 = document.getElementById('SDT_t3');
  const totD = document.getElementById('SDT_tot_d');
  const totT = document.getElementById('SDT_tot_t');
  const avgV = document.getElementById('SDT_avg_v');

  // Relative motion
  const mode = document.getElementById('SDT_mode');
  const sep  = document.getElementById('SDT_sep');
  const va   = document.getElementById('SDT_va');
  const vb   = document.getElementById('SDT_vb');
  const rmT  = document.getElementById('SDT_rm_t');
  const rmDA = document.getElementById('SDT_rm_da');
  const rmDB = document.getElementById('SDT_rm_db');

  // Clear
  const clr = document.getElementById('clear-sdt');

  // ----- Unit conversions: internal canonical units are kt / nm / hours -----
  function vToCanon(x){ // speed → kt
    const n = numStrict(x); if(!Number.isFinite(n)) return NaN;
    switch(uV.value){
      case 'kt': return n;
      case 'mph': return n * 0.868976;    // mph → kt
      case 'mps': return n * 1.94384;     // m/s → kt
    }
  }
  function vFromCanon(kt){
    if(!Number.isFinite(kt)) return NaN;
    switch(uV.value){
      case 'kt': return kt;
      case 'mph': return kt / 0.868976;
      case 'mps': return kt / 1.94384;
    }
  }
  function dToCanon(x){ // distance → nm
    const n = numStrict(x); if(!Number.isFinite(n)) return NaN;
    switch(uD.value){
      case 'nm': return n;
      case 'sm': return n * 0.868976; // statute → nm
      case 'km': return n * 0.539957; // km → nm
    }
  }
  function dFromCanon(nm){
    if(!Number.isFinite(nm)) return NaN;
    switch(uD.value){
      case 'nm': return nm;
      case 'sm': return nm / 0.868976;
      case 'km': return nm / 0.539957;
    }
  }
  function tToHours(x){
    const s = (x??'').toString().trim();
    if(s==='') return NaN;
    if(uT.value === 'hhmm' || s.includes(':')) return parseEndurance(s);
    const n = Number(s); return Number.isFinite(n) ? n : NaN;
  }
  function tFromHours(h){
    if(!Number.isFinite(h)) return NaN;
    return (uT.value==='hhmm') ? hhmm(h) : h.toFixed(2);
  }

  // ----- Single leg solver (enter any 2) -----
  function solveSingle(){
    const vK = vToCanon(v.value);
    const dN = dToCanon(d.value);
    const tH = tToHours(t.value);

    let vRes = vK, dRes = dN, tRes = tH;

    const haveV = Number.isFinite(vK);
    const haveD = Number.isFinite(dN);
    const haveT = Number.isFinite(tH);

    if(haveD && haveT && !haveV && tH>0) vRes = dN / tH;
    if(haveV && haveT && !haveD) dRes = vK * tH;
    if(haveV && haveD && !haveT && vK>0) tRes = dN / vK;

    vOut.textContent = `Speed: ${Number.isFinite(vRes)? fmt(vFromCanon(vRes),1)+' '+uV.value : '—'}`;
    dOut.textContent = `Distance: ${Number.isFinite(dRes)? fmt(dFromCanon(dRes),2)+' '+uD.value : '—'}`;
    tOut.textContent = `Time: ${Number.isFinite(tRes)? tFromHours(tRes) : '—'}`;
  }

  // ----- Multi-leg average -----
  function parseLeg(distEl, timeEl){
    const dN = dToCanon(distEl.value);
    const tH = tToHours(timeEl.value);
    return {
      dN: Number.isFinite(dN) ? dN : 0,
      tH: Number.isFinite(tH) ? tH : 0
    };
  }
  function solveAverage(){
    const L = [parseLeg(d1,t1), parseLeg(d2,t2), parseLeg(d3,t3)];
    const Dsum = L.reduce((s,x)=>s+x.dN,0);
    const Tsum = L.reduce((s,x)=>s+x.tH,0);

    totD.textContent = `Total distance: ${fmt(dFromCanon(Dsum),2)} ${uD.value}`;
    totT.textContent = `Total time: ${Number.isFinite(Tsum)? tFromHours(Tsum) : '—'}`;
    const vAvg = (Tsum>0)? (Dsum/Tsum) : NaN;
    avgV.textContent = `Average speed: ${Number.isFinite(vAvg)? fmt(vFromCanon(vAvg),1)+' '+uV.value : '—'}`;
  }

  // ----- Relative motion -----
  function solveRelative(){
    const m = mode.value;
    const sN = dToCanon(sep.value);
    const vA = vToCanon(va.value);
    const vB = vToCanon(vb.value);

    let tMeet = NaN, dA = NaN, dB = NaN;
    if(Number.isFinite(sN) && Number.isFinite(vA) && Number.isFinite(vB)){
      if(m==='headon'){
        const vClose = vA + vB;
        if(vClose>0){ tMeet = sN / vClose; dA = vA*tMeet; dB = vB*tMeet; }
      } else { // chase
        const vRel = Math.abs(vA - vB);
        const vFast = Math.max(vA,vB), vSlow = Math.min(vA,vB);
        if(vRel>0){
          tMeet = sN / vRel;
          // Who is faster?
          if(vA>=vB){ dA = vA*tMeet; dB = vB*tMeet; }
          else { dA = vA*tMeet; dB = vB*tMeet; }
        }
      }
    }
    rmT.textContent  = `Time to meet/catch: ${formatTimeWithUnits(tMeet)}`;
    rmDA.textContent = `Distance A travels: ${Number.isFinite(dA)? fmt(dFromCanon(dA),2)+' '+uD.value : '—'}`;
    rmDB.textContent = `Distance B travels: ${Number.isFinite(dB)? fmt(dFromCanon(dB),2)+' '+uD.value : '—'}`;
  }

  // ----- Wire events -----
  const inputs = [uV,uD,uT, v,d,t, d1,t1,d2,t2,d3,t3, mode,sep,va,vb].filter(Boolean);
  inputs.forEach(el=>{
    ['input','change'].forEach(ev=>el.addEventListener(ev, ()=>{
      solveSingle(); solveAverage(); solveRelative();
    }));
  });

  // Clear button
  if (clr){
    clr.addEventListener('click', ()=>{
      [v,d,t, d1,t1,d2,t2,d3,t3, sep,va,vb].forEach(el=>{ if(el) el.value=''; });
      solveSingle(); solveAverage(); solveRelative();
    });
  }

    // ===== Speed of Sound / ISA ΔT / Mach =====
    const SSA = {
    pa: document.getElementById('SSA_pa'),
    oat: document.getElementById('SSA_oat'),
    tu:  document.getElementById('SSA_tu'),
    tas: document.getElementById('SSA_tas'),
    machIn: document.getElementById('SSA_mach'),

    Tisa: document.getElementById('SSA_Tisa'),
    dT:   document.getElementById('SSA_dT'),
    a_kt:  document.getElementById('SSA_a_kt'),
    a_mph: document.getElementById('SSA_a_mph'),   // ← add this
    a_kmh: document.getElementById('SSA_a_kmh'),
    a_ms:  document.getElementById('SSA_a_ms'),
    machOut: document.getElementById('SSA_mach_out'),
    tasOut:  document.getElementById('SSA_tas_out'),

    clearBtn: document.getElementById('clear-ssa'),
  };

  // Helpers
  function CtoK(c){ return c + 273.15; }
  function FtoC(f){ return (f - 32) * (5/9); }
  function CtoF(c){ return (c * 9/5) + 32; }

  // ISA temp at pressure altitude (simple model):
  // up to 36,089 ft (11 km): T = 15 - 1.98*(ft/1000) °C; above: -56.5 °C
  function isaTempC(alt_ft){
    const a = numStrict(alt_ft);
    if(!Number.isFinite(a)) return NaN;
    // Exact ISA lapse you requested: 2.0 °C per 1000 ft.
    // Works for negative altitudes (below sea level) as well.
    const T = 15 - 2.0 * (a/1000);
    // Keep ISA plateau above ~36,089 ft (optional). Remove the ternary if you want pure linear.
    return (a <= 36089) ? T : -56.5;
  }

  function formatTimeWithUnits(h){
    if(!Number.isFinite(h)) return '—';
    const totalSec = h * 3600;

    if (totalSec < 60) {
      return fmt(totalSec,0) + ' sec';
    } else if (totalSec < 3600) {
      return fmt(totalSec/60,1) + ' min';
    } else {
      return fmt(h,2) + ' hr';
    }
  }

  function parseOAT_C(){
    const s = SSA.oat?.value ?? '';
    if(s==='') return NaN;
    const raw = numStrict(s);
    if(!Number.isFinite(raw)) return NaN;
    return (SSA.tu?.value === 'F') ? FtoC(raw) : raw; // internal °C
  }

  function speedOfSound_ms(Tk){
    // a = sqrt(gamma * R * T)
    if(!Number.isFinite(Tk)) return NaN;
    const gamma = 1.4;
    const R = 287.05; // J/kg-K
    return Math.sqrt(gamma * R * Tk);
  }

  function solveSSA(){
    const pa_ft = numStrict(SSA.pa?.value);
    const oat_C  = parseOAT_C();
    const TisaC  = isaTempC(pa_ft);
    const TisaK  = Number.isFinite(TisaC) ? CtoK(TisaC) : NaN;
    const ToatK  = Number.isFinite(oat_C) ? CtoK(oat_C) : NaN;

    // Outputs: ISA temp and deviation
    if(Number.isFinite(TisaC)){
      const showC = `${fmt(TisaC,1)} °C`;
      const showF = `${fmt(CtoF(TisaC),1)} °F`;
      SSA.Tisa.textContent = `ISA temp: ${showC} / ${showF}`;
    } else {
      SSA.Tisa.textContent = 'ISA temp: —';
    }

    if(Number.isFinite(oat_C) && Number.isFinite(TisaC)){
      const dT = oat_C - TisaC;
      const sign = dT>0 ? '+' : (dT<0 ? '−' : '±');
      SSA.dT.textContent = `ISA deviation (ΔT): ${sign}${fmt(Math.abs(dT),1)} °C`;
    } else {
      SSA.dT.textContent = 'ISA deviation (ΔT): —';
    }

    // Speed of sound from OAT (static air temp)
    const a_ms  = speedOfSound_ms(ToatK);
    const a_kt  = Number.isFinite(a_ms) ? a_ms * 1.94384 : NaN;
    const a_kmh = Number.isFinite(a_ms) ? a_ms * 3.6     : NaN;
    const a_mph = Number.isFinite(a_ms) ? a_ms * 2.23694 : NaN;

    SSA.a_kt.textContent  = `kt: ${Number.isFinite(a_kt)  ? fmt(a_kt,1)  : '—'}`;
    SSA.a_mph.textContent = `mph: ${Number.isFinite(a_mph) ? fmt(a_mph,1) : '—'}`;
    SSA.a_kmh.textContent = `km/h: ${Number.isFinite(a_kmh) ? fmt(a_kmh,1) : '—'}`;
    SSA.a_ms.textContent  = `m/s: ${Number.isFinite(a_ms)  ? fmt(a_ms,1)  : '—'}`;

    // Mach from TAS (if TAS given)
    const tas_kt = numStrict(SSA.tas?.value);
    let M_from_TAS = NaN;
    if(Number.isFinite(tas_kt) && Number.isFinite(a_kt) && a_kt>0){
      M_from_TAS = tas_kt / a_kt;
    }
    SSA.machOut.textContent = `Mach (from TAS): ${Number.isFinite(M_from_TAS) ? fmt(M_from_TAS,3) : '—'}`;

    // TAS from Mach (if Mach given)
    const M_in = numStrict(SSA.machIn?.value);
    let TAS_from_M = NaN;
    if(Number.isFinite(M_in) && Number.isFinite(a_kt)){
      TAS_from_M = M_in * a_kt;
    }
    SSA.tasOut.textContent = `TAS (from Mach): ${Number.isFinite(TAS_from_M) ? fmt(TAS_from_M,1)+' kt' : '—'}`;
  }

  // Wire into the shared inputs list so a single change triggers all solves
  const ssaInputs = [SSA.pa, SSA.oat, SSA.tu, SSA.tas, SSA.machIn].filter(Boolean);
  ssaInputs.forEach(el=>{
    ['input','change'].forEach(ev=>el.addEventListener(ev, ()=>{
      solveSSA(); // run SoS/Mach section
    }));
  });

  if(SSA.clearBtn){
    SSA.clearBtn.addEventListener('click', ()=>{
      [SSA.pa,SSA.oat,SSA.tas,SSA.machIn].forEach(el=>{ if(el) el.value=''; });
      if(SSA.tu) SSA.tu.value = 'C';
      solveSSA();
    });
  }

  // Run once so outputs render clean
  solveSSA();

    // OAT keypad-friendly
  if (SSA.oat){
    SSA.oat.setAttribute('inputmode','text');                  // allow minus on mobile
    SSA.oat.setAttribute('pattern','-?[0-9]*\\.?[0-9]*');      // optional - and decimal
    SSA.oat.setAttribute('autocomplete','off');
    SSA.oat.setAttribute('enterkeyhint','done');
  }

  // OAT controls
  const OAT_MINUS = document.getElementById('SSA_oat_minus');
  const OAT_PLUS  = document.getElementById('SSA_oat_plus');
  const OAT_STD   = document.getElementById('SSA_oat_std');

  function setOATtoISA(){
    const pa_ft = numStrict(SSA.pa?.value);
    const TisaC = isaTempC(pa_ft);
    if (!Number.isFinite(TisaC)) return; // need a valid PA
    const useF = (SSA.tu?.value === 'F');
    const val  = useF ? (TisaC * 9/5 + 32) : TisaC;
    SSA.oat.value = fmt(val, 1);   // 1-decimal nice display
    solveSSA();
  }

  function bumpOAT(delta){
    const raw = numStrict(SSA.oat?.value);
    let val = Number.isFinite(raw) ? raw : 0;
    // delta is in CURRENT unit (°C or °F)
    val += delta;
    // snap to 1-decimal to avoid 0.3000004 cases
    SSA.oat.value = (+val.toFixed(1)).toString();
    solveSSA();
  }

  if (OAT_STD)   OAT_STD.addEventListener('click',  setOATtoISA);
  if (OAT_MINUS) OAT_MINUS.addEventListener('click', ()=>bumpOAT(-1));
  if (OAT_PLUS)  OAT_PLUS.addEventListener('click',  ()=>bumpOAT(1));

  // Initial compute
  solveSingle(); solveAverage(); solveRelative();
})();
</script>

<script>
/* Mobile numeric keypads (iOS/Android friendly) */
(function () {
  // Integers only (° headings, radials, etc.)
  const INT_IDS = [
    'TC_out','WindFrom','WindSpeed',
    'M_TC','M_WF','M_W',
    'VT_R_A','VT_R_B','VT_TC',
    'palt' // pressure altitude usually integer
  ];

  // Decimals allowed (nm, kt, lat/lon, temps, etc.)
  const DEC_IDS = [
    'D_nm','GS_out','GS_ret',
    'TAS_helper','TAS_ret_helper',
    'M_D','M_TAS_A','M_GS_A','M_TAS_B','M_GS_B',
    'VT_AB','VT_GS_B','VT_TAS_B',
    'lat1','lon1','lat2','lon2',
    'cas','oatc' // allow decimals if you ever need .5
  ];

  // NOTE: We intentionally **do not** force keypad for Endurance (hh:mm),
  // because the numeric keypad hides the ":" on iOS.
  // If you later force hours-only, add 'Endurance' to DEC_IDS.

  INT_IDS.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.setAttribute('inputmode','numeric');   // 0–9 keypad
    el.setAttribute('pattern','[0-9]*');      // hint for Android/Chrome
    el.setAttribute('autocomplete','off');
    el.setAttribute('enterkeyhint','done');
  });

  DEC_IDS.forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.setAttribute('inputmode','decimal');   // keypad with dot
    el.setAttribute('autocomplete','off');
    el.setAttribute('enterkeyhint','done');
  });
})();
</script>

<script>
(function(){
  function setAttrs(el, mode){
    if(!el) return;
    if(mode === 'numeric'){
      el.setAttribute('inputmode','numeric');   // iOS PIN pad (digits)
      el.setAttribute('pattern','[0-9]*');      // Android hint
    } else if (mode === 'decimal'){
      el.setAttribute('inputmode','decimal');   // digits + dot
      el.removeAttribute('pattern');
    }
    el.setAttribute('autocomplete','off');
    el.setAttribute('enterkeyhint','done');
  }

  // Integers only (no dot/no minus): headings, radials, runways, etc.
const NUMERIC = [
  // ETP helper
  'TC_out','WindFrom',

  // Meetpoint
  'M_TC',

  // VOR triangle
  'VT_R_A','VT_R_B','VT_TC',

  // Wind • Angles (enroute + runway)
  'W_COURSE','W_WINDDIR','W_RWY','W_WF2',

  // Altitudes
  'A_IND','A_FLD','A_PA_IN',

  // TAS tile
  'palt',

  // NEW: IFR Gradients (GS helper course)
  'FPM_H_TC'
];

// Decimals allowed (dot ok): speeds, distances, gradients, temps, pressures, etc.
const DECIMAL = [
  // ETP/PNR + helper
  'D_nm','GS_out','GS_ret','TAS_helper','TAS_ret_helper','WindSpeed',

  // Meetpoint
  'M_D','M_W','M_TAS_A','M_GS_A','M_TAS_B','M_GS_B',

  // VOR triangle
  'VT_AB','VT_GS_B','VT_TAS_B','VT_W',

  // TAS tile
  'cas','oatc',

  // Wind • Angles (enroute + runway)
  'W_TAS','W_WINDSPEED','W_VAR',
  'W_W2','W_MAXX','W_VAR2',

  // Altitudes
  'A_ALTSET','A_OAT',

  // SDT (universal)
  'SDT_v','SDT_d','SDT_sep','SDT_va','SDT_vb','SDT_d1','SDT_d2','SDT_d3',

  // Speed of Sound / Mach
  'SSA_pa','SSA_oat','SSA_tas','SSA_mach',

  // NEW: IFR Gradients (all fields)
  'FPM_GS','FPM_ANGLE','FPM_FPNM',
  'FPM_REQ_GS','FPM_REQ_D','FPM_REQ_DH','FPM_REQ_ALT_CURR','FPM_REQ_ALT_XING','FPM_REQ_CAP',
  'FPM_TOD_CURR','FPM_TOD_TGT','FPM_TOD_GS','FPM_TOD_ANGLE','FPM_TOD_FPNM',
  'FPM_H_TAS','FPM_H_WDIR','FPM_H_WSPD'
];

  // Apply attributes
  NUMERIC.forEach(id => setAttrs(document.getElementById(id), 'numeric'));
  DECIMAL.forEach(id => setAttrs(document.getElementById(id), 'decimal'));

  // --- Time fields: only use pin pad when style is "hours.decimal" (no colon needed) ---
  const timeIds = ['SDT_t','SDT_t1','SDT_t2','SDT_t3'];
  const timeStyleSel = document.getElementById('SDT_u_t');
  function applyTimeKeypad(){
    const style = timeStyleSel?.value || 'hhmm';
    timeIds.forEach(id=>{
      const el = document.getElementById(id);
      if(!el) return;
      if(style === 'hours'){
        setAttrs(el,'decimal');      // pin pad
      } else {
        // hh:mm needs ":" → don’t force pin pad
        el.removeAttribute('inputmode');
        el.removeAttribute('pattern');
        el.setAttribute('autocomplete','off');
        el.setAttribute('enterkeyhint','done');
      }
    });
  }
  if (timeStyleSel){
    timeStyleSel.addEventListener('change', applyTimeKeypad);
    applyTimeKeypad();
  }

  // --- Add ± toggles so signed fields can still use pin pads ---
  function addSignToggle(inputId){
    const input = document.getElementById(inputId);
    if(!input) return;
    if(input.dataset.signToggleAttached) return;

    const field = input.closest('.field') || input.parentElement;
    if (field) field.style.position = 'relative';

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'oat-sign-btn';  // you already have styles for this class
    btn.textContent = '±';
    btn.title = 'Toggle sign';
    (field || input.parentElement).appendChild(btn);

    btn.addEventListener('click', ()=>{
      const v = (input.value || '').trim();
      input.value = v.startsWith('-') ? v.slice(1) : ('-' + v);
      input.dispatchEvent(new Event('input', {bubbles:true}));
      input.dispatchEvent(new Event('change', {bubbles:true}));
    });

    input.dataset.signToggleAttached = '1';
  }

  // Variation and OAT can be negative (skip if a proper .oat-sign-btn already exists)
  ['W_VAR','W_VAR2'].forEach(id => {
    const input = document.getElementById(id);
    if (!input) return;
    const hasBtn =
      input.closest('.field')?.querySelector('.oat-sign-btn') ||
      input.parentElement?.querySelector('.oat-sign-btn');
    if (hasBtn) return; // already using the standard affix button
    addSignToggle(id);
  });

})();
</script>

<script>
  /* ===== Inline POH JSON (short-field) ===== */
  window.C172_POH = {
    "aircraft":"C172 short-field",
    "weights_lb":[2200,2400,2550],
    "pa_ft":[0,1000,2000,3000,4000,5000,6000,7000,8000],
    "oat_c":[0,10,20,30,40],
    "takeoff":{"short_flaps_10":{
      "ground_roll_ft":[
        [[610,745,860],[655,800,925],[705,860,995],[760,925,1070],[815,995,1150]],
        [[665,810,940],[720,875,1010],[770,940,1090],[830,1010,1170],[890,1085,1260]],
        [[725,885,1025],[785,955,1110],[845,1030,1195],[905,1110,1285],[975,1190,1380]],
        [[795,970,1125],[860,1050,1215],[925,1130,1310],[995,1215,1410],[1065,1305,1515]],
        [[870,1065,1235],[940,1150,1335],[1010,1240,1440],[1090,1335,1550],[1165,1430,1660]],
        [[955,1170,1355],[1030,1265,1465],[1110,1360,1585],[1195,1465,1705],[1275,1570,1825]],
        [[1050,1285,1495],[1130,1390,1615],[1220,1500,1745],[1310,1610,1875],[1400,1725,2010]],
        [[1150,1415,1645],[1245,1530,1785],[1340,1650,1920],[1435,1770,2065],[1540,1900,2215]],
        [[1270,1560,1820],[1370,1690,1970],[1475,1815,2120],[1580,1950,2280],[1695,2095,2450]]
      ],
      "over_50_ft":[
        [[1055,1275,1465],[1130,1370,1575],[1205,1470,1690],[1290,1570,1810],[1380,1685,1945]],
        [[1145,1390,1600],[1230,1495,1720],[1315,1605,1850],[1410,1720,1990],[1505,1845,2135]],
        [[1250,1520,1755],[1340,1635,1890],[1435,1760,2035],[1540,1890,2190],[1650,2030,2355]],
        [[1365,1665,1925],[1465,1795,2080],[1570,1930,2240],[1685,2080,2420],[1805,2230,2605]],
        [[1490,1830,2120],[1605,1975,2295],[1725,2130,2480],[1855,2295,2685],[1975,2455,2880]],
        [[1635,2015,2345],[1765,2180,2545],[1900,2355,2755],[2035,2530,2975],[2175,2715,3205]],
        [[1800,2230,2605],[1940,2410,2830],[2090,2610,3075],[2240,2805,3320],[2395,3015,3585]],
        [[1985,2470,2910],[2145,2685,3170],[2305,2900,3440],[2475,3125,3730],[2650,3370,4045]],
        [[2195,2755,3265],[2375,3000,3575],[2555,3240,3880],[2745,3500,4225],[2950,3790,4615]]
      ]
    }},
    "landing":{"short_full":{
      "ground_roll_ft":[
        [545,565,585,605,625],[565,585,605,625,650],[585,610,630,650,670],
        [610,630,655,675,695],[630,655,675,700,725],[655,680,705,725,750],
        [680,705,730,755,780],[705,730,760,785,810],[735,760,790,815,840]
      ],
      "over_50_ft":[
        [1290,1320,1350,1380,1415],[1320,1350,1385,1420,1450],[1355,1385,1420,1455,1490],
        [1385,1425,1460,1495,1530],[1425,1460,1495,1535,1570],[1460,1500,1535,1575,1615],
        [1500,1540,1580,1620,1660],[1545,1585,1625,1665,1705],[1585,1630,1670,1715,1755]
      ],
      "weight_lb":2550
    }},
    "adjustments":{
      "headwind_per10kt_pct":-10,
      "tailwind_per2kt_pct":10,
      "grass_takeoff_pct":15,
      "grass_landing_pct":45,
      "wet_pct":12,
      "slope_per1pct_pct":10,
      "headwind_unit_kt":9,
      "tailwind_unit_kt":2
    }
  };

  /* ===== C172S — Short-Field Only (Takeoff + Landing) ===== */
  (function(){
    const $ = s => document.querySelector(s);
    // If you added the "Landing flaps" select earlier, keep LD_FLAPS in this list:
    const ids = [
      'F_ELEV','F_ELEV_CR','F_ALT','F_OAT','F_OAT_CR','RWY_HDG','WIND_AT','RWY_SURF','AC_WT','RWY_SLOPE','LD_FLAPS',
      'ST_CG','ST_FLAPS','ST_BANK','AC_SRC','AC_FLAPS','AC_KIAS','CR_RPM'
    ];
    // helpers
    const fmt = (x,dp=0)=> Number.isFinite(x) ? Number(x).toFixed(dp) : '—';
    const clamp360 = a => { a=a%360; return a<0?a+360:a; };
    const toRad = d => d*Math.PI/180;
    const numStrict = v => { const s=(v??'').toString().trim(); if(s==='') return NaN; const n=Number(s); return Number.isFinite(n)?n:NaN; };

    function hhmmFromHours(h){
      if (!Number.isFinite(h) || h <= 0) return '—';
      const totalMin = Math.round(h * 60);           // nearest minute
      const hh = Math.floor(totalMin / 60);
      const mm = totalMin % 60;
      return `${hh}h ${mm}m`;
    }
    function numOr(v, fallback){ return Number.isFinite(v) ? v : fallback; }
    
    function formatMinSec(mins){
      if (!Number.isFinite(mins)) return '—';
      const total = Math.round(mins * 60);
      const mm = Math.floor(total / 60);
      const ss = total % 60;
      return `${mm}:${ss.toString().padStart(2,'0')}`;
    }

    function parseWindAt(s){
      if (!s) return {dir:NaN, spd:NaN};
      const m = String(s).trim().match(/^\s*(\d{1,3})\s*@\s*(\d{1,3})(?:\.\d+)?\s*$/);
      if (!m) return {dir:NaN, spd:NaN};
      const d = Number(m[1]); const v = Number(m[2]);
      return {dir: (d%360+360)%360, spd: v};
    }
    function pressureAltitude(elev_ft, alt_inHg){
      const E=numStrict(elev_ft), A=numStrict(alt_inHg);
      if(!Number.isFinite(E)||!Number.isFinite(A)) return NaN;
      return E + (29.92 - A) * 1000;
    }
    function isaTempAtPA(pa_ft){ if(!Number.isFinite(pa_ft)) return NaN; return 15 - 1.98*(pa_ft/1000); }
    function densityAltitude(pa_ft,oat_c){
      const Tisa=isaTempAtPA(pa_ft);
      if(!Number.isFinite(Tisa)||!Number.isFinite(oat_c)) return NaN;
      return pa_ft + 120*(oat_c - Tisa);
    }
    function windComponents(rwy, wfrom, wspd){
      const RWY=clamp360(numStrict(rwy)), WF=clamp360(numStrict(wfrom)), W=numStrict(wspd);
      if(![RWY,WF,W].every(Number.isFinite)) return null;
      const rel=clamp360(WF-RWY);
      return { headwind: W*Math.cos(toRad(rel)), crosswind: W*Math.sin(toRad(rel)) };
    }

    // interpolation
    function idx(grid, x){
      if (x<=grid[0]) return [0,0,0];
      if (x>=grid[grid.length-1]){ const i=grid.length-1; return [i,i,1]; }
      for(let i=0;i<grid.length-1;i++) if (x>=grid[i] && x<=grid[i+1]) return [i,i+1,(x-grid[i])/(grid[i+1]-grid[i])];
      return [0,0,0];
    }
    function trilinear(Pgrid,Tgrid,Wgrid,data,pa,oat,wt){
      const [iP,jP,tP]=idx(Pgrid,pa), [iT,jT,tT]=idx(Tgrid,oat), [iW,jW,tW]=idx(Wgrid,wt);
      const c00 = lerp(data[iP][iT][iW], data[iP][iT][jW], tW);
      const c01 = lerp(data[iP][jT][iW], data[iP][jT][jW], tW);
      const c10 = lerp(data[jP][iT][iW], data[jP][iT][jW], tW);
      const c11 = lerp(data[jP][jT][iW], data[jP][jT][jW], tW);
      const b0 = lerp(c00, c01, tT);
      const b1 = lerp(c10, c11, tT);
      return lerp(b0, b1, tP);
    }
    function bilinear(Pgrid, Tgrid, data2d, pa, oat){
      function _idx(grid, x){
        if (x<=grid[0]) return [0,0,0];
        if (x>=grid[grid.length-1]){ const i = grid.length-1; return [i,i,1]; }
        for (let i=0;i<grid.length-1;i++){
          if (x>=grid[i] && x<=grid[i+1]) return [i,i+1,(x-grid[i])/(grid[i+1]-grid[i])];
        }
        return [0,0,0];
      }
      const [iP,jP,tP] = _idx(Pgrid, pa);
      const [iT,jT,tT] = _idx(Tgrid, oat);
      const c00 = data2d[iP][iT], c01 = data2d[iP][jT];
      const c10 = data2d[jP][iT], c11 = data2d[jP][jT];
      const b0  = lerp(c00, c01, tT);
      const b1  = lerp(c10, c11, tT);
      return lerp(b0, b1, tP);
    }

    // === Adjustment helpers ===

    // Apply ONLY wind, wet, slope (NOT grass).
    // Uses rule: headwind −10% per 9 kt; tailwind +10% per 2 kt.
    function applyOtherFactors(val, hw_kt, surface, slope_pct){
      if(!Number.isFinite(val)) return NaN;
      let out = val;

      const adj = (window.C172_POH && C172_POH.adjustments) || {
        headwind_per10kt_pct:-10, tailwind_per2kt_pct:+10,
        grass_takeoff_pct:15, grass_landing_pct:45,
        wet_pct:12, slope_per1pct_pct:10,
        headwind_unit_kt:9, tailwind_unit_kt:2
      };

      const headUnit = adj.headwind_unit_kt ?? 9;
      const tailUnit = adj.tailwind_unit_kt ?? 2;

      if (Number.isFinite(hw_kt)){
        if (hw_kt >= 0){
          out *= (1 + (adj.headwind_per10kt_pct/100) * (hw_kt / headUnit));
        } else {
          out *= (1 + (adj.tailwind_per2kt_pct/100) * (Math.abs(hw_kt) / tailUnit));
        }
      }

      if (surface === 'paved_wet') out *= (1 + adj.wet_pct/100);
      if (Number.isFinite(slope_pct)) out *= (1 + adj.slope_per1pct_pct/100 * (slope_pct/1));
      return out;
    }

    // Grass only affects GR; add GR delta to the 50-ft result.
    function adjustPairWithGrassDelta(base_gr, base_o50, hw_kt, surface, slope_pct, mode='takeoff'){
      const adj = (window.C172_POH && C172_POH.adjustments) || {
        headwind_per10kt_pct:-10, tailwind_per2kt_pct:+10,
        grass_takeoff_pct:15, grass_landing_pct:45,
        wet_pct:12, slope_per1pct_pct:10
      };

      const gr_other  = applyOtherFactors(base_gr,  hw_kt, surface, slope_pct);
      const o50_other = applyOtherFactors(base_o50, hw_kt, surface, slope_pct);

      if (surface === 'grass'){
        const grass_pct = (mode === 'landing' ? adj.grass_landing_pct : adj.grass_takeoff_pct) / 100;
        const gr_with_grass = gr_other * (1 + grass_pct);
        const delta = gr_with_grass - gr_other;
        return { gr: gr_with_grass, o50: o50_other + delta };
      }
      return { gr: gr_other, o50: o50_other };
    }

    // data (already inlined)
    let POH = window.C172_POH || null;

    // ===== POH-derived tables from your images =====

    // Stall speeds at 2550 lb; values include both KIAS and KCAS for each bank.
    // Tables in the POH show the same numbers for "most rearward" and "most forward" CG.
    const STALL_2550 = {
      rear: {
        up:   { 0:{ias:48, kcas:53}, 30:{ias:52, kcas:57}, 45:{ias:62, kcas:63}, 60:{ias:76, kcas:75} },
        '10': { 0:{ias:42, kcas:50}, 30:{ias:45, kcas:54}, 45:{ias:54, kcas:59}, 60:{ias:70, kcas:71} },
        full: { 0:{ias:40, kcas:48}, 30:{ias:43, kcas:52}, 45:{ias:52, kcas:57}, 60:{ias:65, kcas:68} },
      },
      forward: {
        up:   { 0:{ias:48, kcas:53}, 30:{ias:52, kcas:57}, 45:{ias:61, kcas:63}, 60:{ias:76, kcas:75} },
        '10': { 0:{ias:43, kcas:51}, 30:{ias:46, kcas:55}, 45:{ias:56, kcas:61}, 60:{ias:71, kcas:72} },
        full: { 0:{ias:40, kcas:48}, 30:{ias:43, kcas:52}, 45:{ias:52, kcas:57}, 60:{ias:65, kcas:68} },
      }
    };

    // Airspeed calibration: KIAS -> KCAS (normal static)
    const CAL_NORMAL = {
      up:   { x:[50,60,70,80,90,100,110,120,130,140,150,160], y:[56,62,70,78,87,97,107,117,127,137,147,157] },
      '10': { x:[40,50,60,70,80,90,100,110],                   y:[51,57,63,71,80,89,99,109] },
      full: { x:[40,50,60,70,80,85],                            y:[50,56,63,72,81,86] }
    };

    // Airspeed calibration: KIAS -> ALT KIAS (alternate static source)
    const CAL_ALT = {
      up:   { x:[50,60,70,80,90,100,110,120,130,140,150,160], y:[50,60,73,82,92,102,112,122,132,143,153,163] },
      '10': { x:[40,50,60,70,80,90,100,110],                   y:[40,54,64,73,83,93,103,114] },
      full: { x:[40,50,60,70,80,85],                            y:[42,53,63,73,83,88] }
    };

    // ===== MAX RATE OF CLIMB @ 2550 lb (from your POH image) =====
    // Grids
    const ROC_PA  = [   0, 2000, 4000, 6000, 8000, 10000, 12000 ]; // ft
    const ROC_OAT = [ -20,     0,    20,    40 ];                  // °C

    // Climb speed (KIAS) vs PA (constant across temps in this table)
    const ROC_KIAS = [ 74, 73, 73, 73, 72, 72, 72 ];

    // Rate of climb (FPM) table: rows=PA, cols=OAT (-20, 0, 20, 40)
    // NOTE: 12,000 @ 40°C is blank in the POH; we leave as NaN and handle gracefully.
    const ROC_FPM = [
      [ 855, 785, 710, 645 ],  // SL
      [ 760, 695, 625, 560 ],  // 2k
      [ 685, 620, 555, 495 ],  // 4k
      [ 575, 515, 450, 390 ],  // 6k
      [ 465, 405, 345, 285 ],  // 8k
      [ 360, 300, 240, 180 ],  // 10k
      [ 255, 195, 135,  NaN ]  // 12k
    ];

    // ===== TIME, FUEL & DISTANCE TO CLIMB @ 2550 lb (from POH) =====
    // Cumulative FROM SEA LEVEL under ISA (°C shown in POH for reference)
    const CL_PA   = [   0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000,  9000, 10000, 11000, 12000 ];
    const CL_TIME = [   0,     1,     3,     4,     6,     8,    10,    12,    14,    17,     20,     24,     28 ]; // minutes
    const CL_FUEL = [ 0.0,   0.4,   0.8,   1.2,   1.5,   1.9,   2.2,   2.6,   3.0,   3.4,    3.9,    4.4,    5.0 ]; // gallons
    const CL_DIST = [   0,     2,     4,     6,     8,    10,    13,    16,    19,    22,     27,     32,     38 ]; // NM

    // Interpolate cumulative from sea level
    function climbCum(arr, pa){
      return interp1(CL_PA, arr, pa);
    }

    // From ground PA to cruise PA (difference of cumulative values)
    function climbDelta(pa_g, pa_cr){
      if(![pa_g, pa_cr].every(Number.isFinite)) return {t:NaN, f:NaN, d:NaN};
      const a = Math.max(0, Math.min(pa_g,  CL_PA[CL_PA.length-1]));
      const b = Math.max(0, Math.min(pa_cr, CL_PA[CL_PA.length-1]));
      if (b <= a) return {t:0, f:0, d:0};
      return {
        t: climbCum(CL_TIME,b) - climbCum(CL_TIME,a),
        f: climbCum(CL_FUEL,b) - climbCum(CL_FUEL,a),
        d: climbCum(CL_DIST,b) - climbCum(CL_DIST,a)
      };
    }

    // 1D interpolate for KIAS vs PA (re-uses your interp1 helper)
    function rocClimbSpeedKIAS(pa){
      return interp1(ROC_PA, ROC_KIAS, pa);
    }

    // 2D interpolate for FPM vs (PA,OAT) (re-uses your bilinear helper)
    function rocRateFpm(pa, oat){
      let val = bilinear(ROC_PA, ROC_OAT, ROC_FPM, pa, oat);
      if (!Number.isFinite(val)) {
        // POH leaves 12,000 @ 40°C blank. Clamp OAT to the next valid column.
        const safeOAT = Math.min(oat, 20);
        val = bilinear(ROC_PA, ROC_OAT, ROC_FPM, pa, safeOAT);
      }
      return val;
    }

    // simple linear interpolation on monotonic arrays
    function interp1(xs, ys, x){
      if(!Number.isFinite(x) || !xs?.length || xs.length!==ys.length) return NaN;
      if (x<=xs[0]) return ys[0];
      if (x>=xs[xs.length-1]) return ys[ys.length-1];
      for (let i=0;i<xs.length-1;i++){
        if (x>=xs[i] && x<=xs[i+1]){
          const t=(x-xs[i])/(xs[i+1]-xs[i]);
          return ys[i] + t*(ys[i+1]-ys[i]);
        }
      }
      return NaN;
    }

    // Auto-format altimeter input (e.g., 2992 → 29.92)
    const altInput = document.getElementById('F_ALT');
    if (altInput) {
      altInput.addEventListener('input', (e) => {
        let val = e.target.value.replace(/\D/g, '');
        if (val.length > 4) val = val.slice(0, 4);
        if (val.length > 2) val = val.slice(0, 2) + '.' + val.slice(2);
        e.target.value = val;
      });
    }

    const windAtInput = document.getElementById('WIND_AT');
    if (windAtInput){
      windAtInput.addEventListener('input', (e)=>{
        let raw = e.target.value.replace(/[^0-9]/g,''); // keep digits only
        let v = '';

        if (raw.length > 3){
          // dir + speed
          const dir = raw.slice(0,3);
          const spd = raw.slice(3);
          v = dir + '@' + spd;
        } else if (raw.length === 3){
          // auto-insert @ after 3 digits
          v = raw + '@';
        } else {
          // less than 3 digits: just digits
          v = raw;
        }

        e.target.value = v;
      });

      windAtInput.addEventListener('keydown',(e)=>{
        if(e.key === 'Backspace'){
          // If cursor is right after '@', remove the @ first
          const val = e.target.value;
          const pos = e.target.selectionStart;
          if (val.includes('@') && pos === val.indexOf('@')+1){
            e.preventDefault();
            e.target.value = val.replace('@','');
            // set caret correctly
            e.target.setSelectionRange(pos-1,pos-1);
          }
        }
      });
    }

    // === CRUISE POH DATA ===
    const CRUISE = {
      2000: {
        rpm:[2550,2500,2400,2300,2200,2100],
        mcp:{"-20":[83,78,69,61,53,47],"0":[77,73,64,57,50,44],"20":[72,68,60,53,47,42]},
        ktas:{"-20":[117,115,111,105,99,92],"0":[118,115,110,104,97,90],"20":[117,115,109,102,95,89]},
        gph:{"-20":[11.1,10.6,9.6,8.6,7.7,6.9],"0":[10.5,9.9,9.0,8.1,7.3,6.6],"20":[9.9,9.4,8.5,7.7,6.9,6.3]}
      },
      4000:{
        rpm:[2600,2550,2500,2400,2300,2200,2100],
        mcp:{"-20":[83,79,74,65,58,51,45],"0":[77,73,69,61,54,48,42],"20":[72,68,64,57,51,45,40]},
        ktas:{"-20":[120,118,115,110,104,98,91],"0":[120,117,115,109,102,96,89],"20":[119,117,114,107,101,94,87]},
        gph:{"-20":[11.1,10.6,10.1,9.1,8.2,7.4,6.6],"0":[10.4,9.9,9.5,8.5,7.7,7.0,6.4],"20":[9.8,9.4,8.9,8.1,7.3,6.7,6.1]}
      },
      6000:{
        rpm:[2650,2600,2500,2400,2300,2200],
        mcp:{"-20":[83,78,70,62,54,48],"0":[77,73,65,57,51,45],"20":[72,68,60,54,48,43]},
        ktas:{"-20":[122,120,115,109,103,96],"0":[122,119,114,108,101,94],"20":[121,118,112,106,99,92]},
        gph:{"-20":[11.1,10.6,9.6,8.6,7.8,7.1],"0":[10.4,9.9,9.0,8.2,7.4,6.7],"20":[9.8,9.4,8.5,7.7,7.0,6.4]}
      },
      8000:{
        rpm:[2700,2650,2600,2500,2400,2300,2200],
        mcp:{"-20":[83,78,74,65,58,52,46],"0":[77,72,68,61,54,48,43],"20":[71,67,64,57,51,46,41]},
        ktas:{"-20":[125,122,120,114,108,101,94],"0":[124,122,119,112,106,99,92],"20":[123,120,117,111,104,97,90]},
        gph:{"-20":[11.1,10.5,10.0,9.1,8.2,7.5,6.8],"0":[10.4,9.9,9.4,8.6,7.8,7.1,6.5],"20":[9.7,9.3,8.9,8.1,7.4,6.8,6.2]}
      },
      10000:{
        rpm:[2700,2650,2600,2500,2400,2300],
        mcp:{"-20":[78,73,69,62,55,49],"0":[72,68,64,57,51,46],"20":[67,63,60,54,49,44]},
        ktas:{"-20":[124,122,119,113,106,100],"0":[123,120,117,111,104,97],"20":[122,119,115,109,102,95]},
        gph:{"-20":[10.5,10.0,9.5,8.7,7.9,7.2],"0":[9.8,9.4,9.0,8.2,7.5,6.8],"20":[9.3,8.9,8.5,7.8,7.1,6.5]}
      },
      12000:{
        rpm:[2650,2600,2500,2400,2300],
        mcp:{"-20":[69,65,58,52,47],"0":[64,61,54,49,44],"20":[60,57,51,46,41]},
        ktas:{"-20":[121,118,111,105,98],"0":[119,116,109,102,95],"20":[117,114,107,100,92]},
        gph:{"-20":[9.5,9.1,8.3,7.5,6.9],"0":[8.9,8.5,7.8,7.1,6.6],"20":[8.5,8.1,7.4,6.8,6.3]}
      }
    };

    // helpers
    const TGRID = [-20, 0, 20];                       // temp columns in POH
    function lerp(a,b,t){ return a+(b-a)*t; }
    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

    // drop-in replacement
    function interp1Pair(xs, ys, x){
      if (!xs || !ys || xs.length !== ys.length || !Number.isFinite(x)) return NaN;

      // ensure ascending order for interpolation
      let X = xs, Y = ys;
      if (xs[0] > xs[xs.length - 1]) {
        X = xs.slice().reverse();
        Y = ys.slice().reverse();
      }

      if (x <= X[0]) return Y[0];
      if (x >= X[X.length - 1]) return Y[Y.length - 1];

      for (let i = 0; i < X.length - 1; i++) {
        if (x >= X[i] && x <= X[i + 1]) {
          const t = (x - X[i]) / (X[i + 1] - X[i]);
          return Y[i] + t * (Y[i + 1] - Y[i]);
        }
      }
      return NaN;
    }

    function valAtPA(node, rpm, dT, key){
      // key = "mcp" | "ktas" | "gph"
      const rgrid = node.rpm;
      // temp factor: between -20, 0, +20 (clamped)
      const tt = clamp(dT, TGRID[0], TGRID[TGRID.length-1]);
      let lowT, hiT, tFac;
      if (tt <= 0){
        lowT = "-20"; hiT = "0";  tFac = (tt - (-20)) / 20;   // -20..0
      } else {
        lowT = "0";   hiT = "20"; tFac = tt / 20;             // 0..+20
      }
      // RPM interpolation at the two temp columns
      const yL = interp1Pair(rgrid, node[key][lowT], rpm);
      const yH = interp1Pair(rgrid, node[key][hiT],  rpm);
      return lerp(yL, yH, tFac);
    }

    // Tri-linear across PA (between PA pages), RPM (within page), and temp (between -20/0/+20)
    function calcCruise(pa_ft, rpm, dT_c){
      // find bracketing PA pages that exist in CRUISE
      const pages = Object.keys(CRUISE).map(n=>Number(n)).sort((a,b)=>a-b);
      if (!pages.length) return null;

      // clamp to bounds
      if (pa_ft <= pages[0]){
        const n = CRUISE[pages[0]];
        return {
          mcp: valAtPA(n, rpm, dT_c, "mcp"),
          ktas: valAtPA(n, rpm, dT_c, "ktas"),
          gph: valAtPA(n, rpm, dT_c, "gph")
        };
      }
      if (pa_ft >= pages[pages.length-1]){
        const n = CRUISE[pages[pages.length-1]];
        return {
          mcp: valAtPA(n, rpm, dT_c, "mcp"),
          ktas: valAtPA(n, rpm, dT_c, "ktas"),
          gph: valAtPA(n, rpm, dT_c, "gph")
        };
      }

      // blend between nearest PA pages
      let i=0; while (i<pages.length-1 && !(pa_ft>=pages[i] && pa_ft<=pages[i+1])) i++;
      const pa0 = pages[i], pa1 = pages[i+1];
      const t = (pa_ft - pa0) / (pa1 - pa0);

      const n0 = CRUISE[pa0], n1 = CRUISE[pa1];
      const m0 = valAtPA(n0, rpm, dT_c, "mcp");
      const k0 = valAtPA(n0, rpm, dT_c, "ktas");
      const g0 = valAtPA(n0, rpm, dT_c, "gph");
      const m1 = valAtPA(n1, rpm, dT_c, "mcp");
      const k1 = valAtPA(n1, rpm, dT_c, "ktas");
      const g1 = valAtPA(n1, rpm, dT_c, "gph");

      return {
        mcp: lerp(m0, m1, t),
        ktas: lerp(k0, k1, t),
        gph: lerp(g0, g1, t)
      };
    }

    // === MCP→RPM helper (uses published table entries only; no interpolation) ===
    function nearestCruiseAltitude(pa){
      const alts = Object.keys(CRUISE).map(Number);
      return alts.reduce((best, a) => Math.abs(a - pa) < Math.abs(best - pa) ? a : best, alts[0]);
    }
    function nearestTempKey(dT){
      const opts = [-20, 0, 20];
      const v = Number.isFinite(dT) ? dT : 0;
      let best = opts[0], bestDiff = Math.abs(v - opts[0]);
      for (let i = 1; i < opts.length; i++){
        const d = Math.abs(v - opts[i]);
        if (d < bestDiff){ best = opts[i]; bestDiff = d; }
      }
      return String(best);
    }
    /** Find a published RPM whose MCP is <= target (default 75%), choosing the highest MCP that doesn't exceed target. */
    function findRpmForMcpTarget(pa, dT, target = 75){
      if (!Number.isFinite(pa)) return NaN;
      const alt = nearestCruiseAltitude(pa);
      const tKey = nearestTempKey(dT);
      const rpm = CRUISE[alt].rpm;            // NOTE: descending order in your data
      const mcpRow = CRUISE[alt].mcp[tKey];   // same indexing as rpm

      // Scan from high RPM → low RPM; pick first MCP <= target
      for (let i = 0; i < rpm.length; i++){
        const m = mcpRow[i];
        if (Number.isFinite(m) && m <= target) return rpm[i];
      }
      // If all are > target, fall back to lowest RPM (last entry)
      return rpm[rpm.length - 1];
    }

    function recalc(){
      const elev  = numStrict($('#F_ELEV')?.value);
      const alt   = numStrict($('#F_ALT')?.value);
      const oat   = numStrict($('#F_OAT')?.value);
      const rwy   = numStrict($('#RWY_HDG')?.value);

      const windRaw = $('#WIND_AT')?.value || '';
      const { dir: wdir, spd: wspd } = parseWindAt(windRaw);

      const surf  = $('#RWY_SURF')?.value;
      const slope = numStrict($('#RWY_SLOPE')?.value);
      const wt    = numStrict($('#AC_WT')?.value);

      const pa = pressureAltitude(elev,alt);
      const isa= isaTempAtPA(pa);
      const da = densityAltitude(pa,oat);

      $('#OUT_PA').textContent  = 'PA: ' + (Number.isFinite(pa)? pa.toFixed(0)+' ft':'—');
      $('#OUT_DA').textContent  = 'DA: ' + (Number.isFinite(da)? da.toFixed(0)+' ft':'—');
      $('#OUT_ISA').textContent = 'ISA at PA: ' + (Number.isFinite(isa)? isa.toFixed(1)+' °C':'—');

      const wind = windComponents(rwy,wdir,wspd);

      // --- Tailwind > 10 kt CAUTION targets
      const toWarnEl = document.getElementById('TO_TW_WARN');
      const ldWarnEl = document.getElementById('LD_TW_WARN');

      if (wind){
        // UI: show components
        document.getElementById('OUT_HW').textContent =
          (wind.headwind>=0 ? 'Headwind: ' : 'Tailwind: ') + Math.abs(wind.headwind).toFixed(0) + ' kt';
        document.getElementById('OUT_XW').textContent =
          'Crosswind: ' + Math.abs(wind.crosswind).toFixed(0) + ' kt ' + (wind.crosswind>=0?'(R)':'(L)');

        // CAUTION if tailwind magnitude > 10 kt
        const tailKts = Math.max(0, -wind.headwind);
        const msg = (tailKts > 10)
          ? `CAUTION: Tailwind ${tailKts.toFixed(0)} kt exceeds 10 kt — beyond POH short-field limits.`
          : '';

        if (toWarnEl) toWarnEl.textContent = msg;
        if (ldWarnEl) ldWarnEl.textContent = msg;
      } else {
        // No valid wind: clear displays + warnings
        document.getElementById('OUT_HW').textContent = 'Head/Tailwind: — kt';
        document.getElementById('OUT_XW').textContent = 'Crosswind: — kt (R/L)';
        if (toWarnEl) toWarnEl.textContent = '';
        if (ldWarnEl) ldWarnEl.textContent = '';
      }

      // Guard for interpolation
      if (!POH) {
        $('#TOS_GR').textContent='Ground roll: —';
        $('#TOS_50').textContent='Over 50 ft: —';
        $('#LDS_GR').textContent='Ground roll: —';
        $('#LDS_50').textContent='Over 50 ft: —';
        const noteEl = document.getElementById('LD_NOTE'); if (noteEl) noteEl.textContent='';
        return;
      }

      // ===== TAKEOFF (short-field, flaps 10°)
      const haveTO = [pa,oat,wt].every(Number.isFinite)
                  && POH.takeoff && POH.takeoff.short_flaps_10;

      if (haveTO){
        const P=POH.pa_ft, T=POH.oat_c, W=POH.weights_lb;
        const base_gr  = trilinear(P,T,W, POH.takeoff.short_flaps_10.ground_roll_ft, pa,oat,wt);
        const base_o50 = trilinear(P,T,W, POH.takeoff.short_flaps_10.over_50_ft,   pa,oat,wt);

        const pair = adjustPairWithGrassDelta(base_gr, base_o50, wind?wind.headwind:NaN, surf, slope, 'takeoff');

        $('#TOS_GR').textContent = 'Ground roll: ' + (Number.isFinite(pair.gr)?  fmt(pair.gr,0)+' ft':'—');
        $('#TOS_50').textContent = 'Over 50 ft: ' + (Number.isFinite(pair.o50)? fmt(pair.o50,0)+' ft':'—');
      } else {
        $('#TOS_GR').textContent='Ground roll: —';
        $('#TOS_50').textContent='Over 50 ft: —';
      }

      // ===== LANDING (short-field, full; can set flaps UP)
      const haveLD = [pa,oat].every(Number.isFinite)
                  && POH.landing && POH.landing.short_full;

      if (haveLD){
        const P = POH.pa_ft, T = POH.oat_c;
        const base_gr  = bilinear(P, T, POH.landing.short_full.ground_roll_ft, pa, oat);
        const base_o50 = bilinear(P, T, POH.landing.short_full.over_50_ft,     pa, oat);

        let pair = adjustPairWithGrassDelta(base_gr, base_o50, wind?wind.headwind:NaN, surf, slope, 'landing');

        // Landing flaps control (optional; requires #LD_FLAPS and #LD_NOTE in HTML)
        const flaps = document.getElementById('LD_FLAPS')?.value || 'full';
        const noteEl = document.getElementById('LD_NOTE');
        if (flaps === 'up'){
          pair = { gr: pair.gr * 1.35, o50: pair.o50 * 1.35 }; // +35% distances
          if (noteEl) noteEl.textContent = 'Flaps UP: +9 KIAS approach; +35% distance applied.';
        } else {
          if (noteEl) noteEl.textContent = '';
        }

        $('#LDS_GR').textContent = 'Ground roll: ' + (Number.isFinite(pair.gr)?  fmt(pair.gr,0)+' ft':'—');
        $('#LDS_50').textContent = 'Over 50 ft: ' + (Number.isFinite(pair.o50)? fmt(pair.o50,0)+' ft':'—');
      } else {
        $('#LDS_GR').textContent='Ground roll: —';
        $('#LDS_50').textContent='Over 50 ft: —';
        const noteEl = document.getElementById('LD_NOTE'); if (noteEl) noteEl.textContent='';
      }

      // ===== MAX ROC (2550 lb) =====
      (function(){
        const pa_ok  = Number.isFinite(pa);
        const oat_ok = Number.isFinite(oat);

        const spdEl = document.getElementById('ROC_SPD');
        const fpmEl = document.getElementById('ROC_FPM');

        if (pa_ok && oat_ok){
          const kias = rocClimbSpeedKIAS(pa);
          const fpm  = rocRateFpm(pa, oat);

          spdEl.textContent = Number.isFinite(kias)
            ? `Climb speed: ${kias.toFixed(0)} KIAS`
            : 'Climb speed: — KIAS';

          fpmEl.textContent = Number.isFinite(fpm)
            ? `Rate of climb: ${fpm.toFixed(0)} fpm`
            : 'Rate of climb: — fpm';

          // Calculate and display average climb rate using ground + cruise temps
          const oat_g  = numStrict(document.getElementById('F_OAT')?.value);
          const oat_cr = numStrict(document.getElementById('F_OAT_CR')?.value);
          const elev_g = numStrict(document.getElementById('F_ELEV')?.value);
          const elev_cr = numStrict(document.getElementById('F_ELEV_CR')?.value);
          const avgEl  = document.getElementById('ROC_AVG_FPM');

          if (Number.isFinite(oat_g) && Number.isFinite(oat_cr) && Number.isFinite(elev_g) && Number.isFinite(elev_cr)) {
            const pa_g  = pressureAltitude(elev_g, alt);  // use altimeter setting already in code
            const pa_cr = pressureAltitude(elev_cr, alt);
            const f1 = rocRateFpm(pa_g, oat_g);
            const f2 = rocRateFpm(pa_cr, oat_cr);
            const avg = (Number.isFinite(f1) && Number.isFinite(f2)) ? (f1 + f2) / 2 : NaN;
            avgEl.textContent = Number.isFinite(avg)
              ? `Avg climb rate: ${avg.toFixed(0)} fpm`
              : 'Avg climb rate: — fpm';
          } else {
            avgEl.textContent = 'Avg climb rate: — fpm';
          }
        } else {
          spdEl.textContent = 'Climb speed: — KIAS';
          fpmEl.textContent = 'Rate of climb: — fpm';
        }
      })();

      // ===== TIME/FUEL/DISTANCE TO CLIMB (2550 lb) =====
      (function(){
        const oat_g   = numStrict(document.getElementById('F_OAT')?.value);      // ground OAT (°C)
        const oat_cr  = numStrict(document.getElementById('F_OAT_CR')?.value);   // cruise OAT (°C)
        const elev_g  = numStrict(document.getElementById('F_ELEV')?.value);     // ground field elev (ft)
        const elev_cr = numStrict(document.getElementById('F_ELEV_CR')?.value);  // cruise altitude (ft)
        const alt     = numStrict(document.getElementById('F_ALT')?.value);      // altimeter (inHg)

        const timeEl = document.getElementById('CL_TIME');
        const fuelEl = document.getElementById('CL_FUEL');
        const distEl = document.getElementById('CL_DIST');
        const noteEl = document.getElementById('CL_NOTE');

        // guard
        if (![oat_g,oat_cr,elev_g,elev_cr,alt].every(Number.isFinite)) {
          timeEl.textContent = 'Time to climb: —';
          fuelEl.textContent = 'Fuel used: —';
          distEl.textContent = 'Distance: —';
          if (noteEl) noteEl.textContent = '';
          return;
        }

        // Convert to Pressure Altitudes
        const pa_g  = pressureAltitude(elev_g,  alt);
        const pa_cr = pressureAltitude(elev_cr, alt);
        if (!Number.isFinite(pa_g) || !Number.isFinite(pa_cr) || pa_cr <= pa_g) {
          timeEl.textContent = 'Time to climb: 0:00';
          fuelEl.textContent = 'Fuel used: 0.0 gal';
          distEl.textContent = 'Distance: 0.0 NM';
          if (noteEl) noteEl.textContent = '';
          return;
        }

        // Segment the climb every 1000 ft grid (matching POH table nodes), with partial first/last segments.
        const grid = CL_PA; // [0,1000,2000,...,12000]
        const nodes = [];
        // include endpoints inside [pa_g, pa_cr], snapping to grid where it lands
        nodes.push(pa_g);
        for (let i=0;i<grid.length;i++){
          const a = grid[i];
          if (a > pa_g && a < pa_cr) nodes.push(a);
        }
        nodes.push(pa_cr);
        nodes.sort((a,b)=>a-b);

        let tSum = 0, fSum = 0, dSum = 0;

        for (let i=0;i<nodes.length-1;i++){
          const a = nodes[i];
          const b = nodes[i+1];

          // baseline (ISA) segment deltas from cumulative curves
          const segT = climbCum(CL_TIME,b) - climbCum(CL_TIME,a);
          const segF = climbCum(CL_FUEL,b) - climbCum(CL_FUEL,a);
          const segD = climbCum(CL_DIST,b) - climbCum(CL_DIST,a);

          // midpoint PA for ISA temperature
          const midPA = (a + b) / 2;

          // linearly blend OAT from ground to cruise as altitude increases
          const frac = (midPA - pa_g) / (pa_cr - pa_g);            // 0..1
          const oatMid = oat_g + (oat_cr - oat_g) * frac;

          // ISA at midpoint PA
          const isaMid = isaTempAtPA(midPA);                       // °C
          const dT = (oatMid - isaMid);                            // allow negative (below ISA)

          // precise factor: ±1% per °C relative to ISA
          const factor = 1 + 0.01 * dT;

          tSum += segT * factor;
          fSum += segF * factor;
          dSum += segD * factor;
        }

        // format (mm:ss and 1 decimal NM)
        function formatMinSec(mins){
          if (!Number.isFinite(mins)) return '—';
          const total = Math.round(mins * 60);
          const mm = Math.floor(total / 60);
          const ss = total % 60;
          return `${mm}:${ss.toString().padStart(2,'0')}`;
        }

        timeEl.textContent = Number.isFinite(tSum) ? `Time to climb: ${formatMinSec(tSum)}` : 'Time to climb: —';
        fuelEl.textContent = Number.isFinite(fSum) ? `Fuel used: ${fSum.toFixed(1)} gal`    : 'Fuel used: —';
        distEl.textContent = Number.isFinite(dSum) ? `Distance: ${dSum.toFixed(1)} NM`      : 'Distance: —';

        if (noteEl){
          noteEl.innerHTML =
            'Applies <b>±1% per °C</b> relative to ISA across the climb (segment-by-segment). ' +
            'Add <b>1.4 gal</b> for start/taxi/takeoff. Values assume zero wind.';
        }
      })();

      // ===== CRUISE PERFORMANCE (2550 lb) =====
      (function(){
        const elev_cr = numStrict(document.getElementById('F_ELEV_CR')?.value);   // cruise altitude (ft)
        const alt     = numStrict(document.getElementById('F_ALT')?.value);       // altimeter (inHg)
        const oat_cr  = numStrict(document.getElementById('F_OAT_CR')?.value);    // cruise OAT (°C)
        const rpm     = numStrict(document.getElementById('CR_RPM')?.value);      // selected RPM

        const outM = document.getElementById('CR_OUT_MCP');
        const outK = document.getElementById('CR_OUT_KTAS');
        const outG = document.getElementById('CR_OUT_GPH');

        // guards
        if (![elev_cr,alt,oat_cr,rpm].every(Number.isFinite)){
          outM.textContent = `% MCP: —`;
          outK.textContent = `KTAS: —`;
          outG.textContent = `GPH: —`;
          return;
        }

        // cruise pressure altitude + ISA deviation at cruise
        const pa_cr = pressureAltitude(elev_cr, alt);    // ft
        const isa   = isaTempAtPA(pa_cr);                // °C
        const dT    = oat_cr - isa;                      // °C relative to ISA (can be negative)

        // If cruise tables/lookup aren't loaded, don't crash the whole recalc
        if (typeof calcCruise !== 'function') {
          outM.textContent = `% MCP: —`;
          outK.textContent = `KTAS: —`;
          outG.textContent = `GPH: —`;
          return;
        }

        // Use your existing cruise interpolation (POH grid at -20/0/+20 °C and RPM points)
        // calcCruise(pa, rpm, dT) should do tri-linear interp over PA, RPM, and temp bucket.
        const res = calcCruise(pa_cr, rpm, dT);

        if (res && Number.isFinite(res.mcp) && Number.isFinite(res.ktas) && Number.isFinite(res.gph)){
          // Existing three outputs
          outM.textContent = `% MCP: ${res.mcp.toFixed(0)}`;

          let ktas = res.ktas;
          const noFairings = document.getElementById('FAIRING_CB')?.checked; // default true
          if (noFairings) ktas = Math.max(0, ktas - 2);
          outK.textContent = `KTAS: ${ktas.toFixed(0)}`;
          outG.textContent = `GPH: ${res.gph.toFixed(1)}`;

          // --- NEW: Total Range (no wind) using POH profile logic ---
          // Assumptions per POH Range Profile page:
          const USABLE_GAL   = 53;
          const RESERVE_MIN  = 45;
          // Use your climb tables @ 2550 lb (cumulative from sea level)
          const paGrid   = (typeof CL_PA   !== 'undefined')   ? CL_PA   : [];
          const fuelGrid = (typeof CL_FUEL !== 'undefined')   ? CL_FUEL : [];
          const timeGrid = (typeof CL_TIME !== 'undefined')   ? CL_TIME : [];

          // Interpolate climb fuel/time to the target cruise PA
          function interpAsc(xs, ys, x){
            if (!xs.length || xs.length !== ys.length || !Number.isFinite(x)) return NaN;
            if (x <= xs[0]) return ys[0];
            if (x >= xs[xs.length - 1]) return ys[ys.length - 1];
            for (let i = 0; i < xs.length - 1; i++){
              const x0 = xs[i], x1 = xs[i+1];
              if (x >= x0 && x <= x1){
                const t = (x - x0) / (x1 - x0);
                return ys[i] + t*(ys[i+1] - ys[i]);
              }
            }
            return NaN;
          }

          let climbGal = 0, climbMin = 0;
          if (paGrid.length && fuelGrid.length && timeGrid.length){
            climbGal = interpAsc(paGrid, fuelGrid, pa_cr);   // gal to climb to cruise PA
            climbMin = interpAsc(paGrid, timeGrid, pa_cr);   // minutes to climb to cruise PA
          }

          // Subtract climb fuel, then subtract reserve (both at your current cruise flow)
          const reserveGal = res.gph * (RESERVE_MIN / 60);
          const cruiseGal  = Math.max(0, USABLE_GAL - climbGal - reserveGal);

          // Cruise endurance (hours) and cruise distance
          const enduranceH     = cruiseGal / res.gph;
          const cruiseDistance = Math.max(0, ktas * enduranceH);

          // Add distance covered during climb (use an average climb TAS ~ 90 KTAS)
          const AVG_CLIMB_TAS = 90; // tweak if you prefer
          const climbDistance  = Number.isFinite(climbMin) ? (AVG_CLIMB_TAS * (climbMin / 60)) : 0;

          const totalRange = cruiseDistance + climbDistance;

          // Output
          const outRng = document.getElementById('CR_OUT_RANGE');
          if (outRng) outRng.textContent = `Total Range: ${Number.isFinite(totalRange) && totalRange>0 ? totalRange.toFixed(0)+' NM' : '—'}`;
        }
      })();

      // ===== ENDURANCE (POH — bilinear in Altitude & Power) =====
      (function () {
        const enduranceEl  = document.getElementById('CR_OUT_ENDURANCE');
        const pa   = pressureAltitude(numStrict(document.getElementById('F_ELEV_CR')?.value),
                                      numStrict(document.getElementById('F_ALT')?.value));
        const rpm  = numStrict(document.getElementById('CR_RPM')?.value);
        const oatC = numStrict(document.getElementById('F_OAT_CR')?.value);
        const isaC = isaTempAtPA(pa);
        const dT   = (Number.isFinite(oatC) && Number.isFinite(isaC)) ? (oatC - isaC) : 0;

        if (!Number.isFinite(pa) || !Number.isFinite(rpm)) {
          if (enduranceEl) enduranceEl.textContent = 'Endurance: — hrs';
          return;
        }

        // Your corrected endurance data (hours) at key pressure-altitude points
        const ENDURANCE = {
          75: { 0:4.30, 2000:4.30, 4000:4.30, 6000:4.27, 8000:4.25, 8500:4.25, 10000:4.50, 12000:4.85 },
          65: { 0:4.95, 2000:4.90, 4000:4.90, 6000:4.87, 8000:4.85, 10000:4.85, 12000:4.85 },
          55: { 0:5.80, 2000:5.75, 4000:5.70, 6000:5.68, 8000:5.65, 10000:5.63, 12000:5.63 },
          45: { 0:7.00, 2000:6.90, 4000:6.85, 6000:6.80, 8000:6.75, 10000:6.72, 12000:6.70 }
        };
        const POWERS = [45, 55, 65, 75];

        // 1D interpolate endurance vs altitude for a single power curve
        function interpAlt(tableObj, paFt) {
          const alts = Object.keys(tableObj).map(Number).sort((a,b)=>a-b);
          if (paFt <= alts[0]) return tableObj[alts[0]];
          if (paFt >= alts[alts.length-1]) return tableObj[alts[alts.length-1]];
          for (let i=0;i<alts.length-1;i++){
            const a = alts[i], b = alts[i+1];
            if (paFt >= a && paFt <= b){
              const t = (paFt - a) / (b - a);
              return tableObj[a] + t * (tableObj[b] - tableObj[a]);
            }
          }
          return NaN;
        }

        // Get MCP from your existing cruise model
        const cruise = calcCruise(pa, rpm, dT);
        if (!cruise || !Number.isFinite(cruise.mcp)) {
          if (enduranceEl) enduranceEl.textContent = 'Endurance: — hrs';
          return;
        }

        // Clamp MCP to the table bounds (45..75), then interpolate between curves
        const m = Math.max(POWERS[0], Math.min(POWERS[POWERS.length-1], cruise.mcp));

        // Find power bracket [pLo, pHi]
        let pLo = POWERS[0], pHi = POWERS[POWERS.length-1];
        for (let i=0;i<POWERS.length-1;i++){
          if (m >= POWERS[i] && m <= POWERS[i+1]) { pLo = POWERS[i]; pHi = POWERS[i+1]; break; }
        }
        const tP = (m - pLo) / (pHi - pLo); // 0..1 between the two power lines

        // Interpolate altitude on each bracket curve, then blend across power
        const eLo = interpAlt(ENDURANCE[pLo], pa);
        const eHi = interpAlt(ENDURANCE[pHi], pa);
        const endurance = eLo + tP * (eHi - eLo);

        if (enduranceEl) enduranceEl.textContent = Number.isFinite(endurance)
          ? `Endurance: ${endurance.toFixed(2)} hrs`
          : 'Endurance: — hrs';
      })();

      // ===== STALL SPEEDS (2550 lb, power IDLE) =====
      (function(){
        const cg = document.getElementById('ST_CG')?.value || 'rear';
        const fl = document.getElementById('ST_FLAPS')?.value || 'full';
        const bk = Number(document.getElementById('ST_BANK')?.value || 0);
        const node = STALL_2550?.[cg]?.[fl]?.[bk];
        const kiasEl = document.getElementById('ST_OUT_KIAS');
        const kcasEl = document.getElementById('ST_OUT_KCAS');
        if (node){
          if (kiasEl) kiasEl.textContent = `KIAS: ${node.ias}`;
          if (kcasEl) kcasEl.textContent = `KCAS: ${node.kcas}`;
        } else {
          if (kiasEl) kiasEl.textContent = 'KIAS: —';
          if (kcasEl) kcasEl.textContent = 'KCAS: —';
        }
      })();

      // ===== AIRSPEED CALIBRATION =====
      (function(){
        const src   = document.getElementById('AC_SRC')?.value || 'normal';
        const flaps = document.getElementById('AC_FLAPS')?.value || 'up';
        const kias  = numStrict(document.getElementById('AC_KIAS')?.value);
        const hdr   = document.getElementById('AC_OUT_HDR');
        const out   = document.getElementById('AC_OUT_VAL');

        if (hdr){
          hdr.textContent = (src==='alternate')
            ? 'Equivalent indicated on Alternate Static (ALT KIAS)'
            : 'Calibrated airspeed (KCAS)';
        }

        let table = (src==='alternate') ? CAL_ALT?.[flaps] : CAL_NORMAL?.[flaps];

        if (table && Number.isFinite(kias)){
          const y = interp1(table.x, table.y, kias);
          out.textContent = Number.isFinite(y) ? `${y.toFixed(0)} kt` : '—';
        } else {
          out.textContent = '—';
        }
      })();
    }

    // events
    ids.forEach(id => document.getElementById(id)?.addEventListener('input', recalc));

    ['CR_FUEL','CR_RES_MIN'].forEach(id => {
      document.getElementById(id)?.addEventListener('input', () => {
        // call whatever you use to re-run the cruise recalc:
        document.getElementById('CR_RPM')?.dispatchEvent(new Event('input', { bubbles:true }));
      });
    });

    // Wire the ≤75% button to auto-fill RPM
    document.getElementById('CR_FIND_75')?.addEventListener('click', () => {
      // read cruise PA + ΔT using your existing inputs
      const elev_cr = numStrict(document.getElementById('F_ELEV_CR')?.value); // cruise altitude (ft)
      const alt_inHg = numStrict(document.getElementById('F_ALT')?.value);    // altimeter (inHg)
      const oat_cr = numStrict(document.getElementById('F_OAT_CR')?.value);   // cruise OAT (°C)

      const pa_cr = pressureAltitude(elev_cr, alt_inHg);                      // PA at cruise
      const isa_cr = isaTempAtPA(pa_cr);                                      // ISA at that PA
      const dT = Number.isFinite(oat_cr) && Number.isFinite(isa_cr) ? (oat_cr - isa_cr) : 0;

      // find published RPM with MCP <= 75% (no interpolation)
      const rpm = findRpmForMcpTarget(pa_cr, dT, 75);

      // write it into the RPM input for clear feedback + trigger recompute
      const rpmEl = document.getElementById('CR_RPM');
      if (rpmEl && Number.isFinite(rpm)) {
        rpmEl.value = String(rpm);
        rpmEl.dispatchEvent(new Event('input', { bubbles: true }));
        // optional tiny visual nudge
        rpmEl.style.boxShadow = '0 0 0 8px var(--ring)';
        setTimeout(() => rpmEl.style.boxShadow = '', 180);
      }
    });

    // Wire once at startup (NOT inside Clear)
    document.querySelectorAll('button[data-rpm]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const rpmEl = document.getElementById('CR_RPM');
        if (rpmEl){
          rpmEl.value = btn.dataset.rpm;
          rpmEl.dispatchEvent(new Event('input', { bubbles: true })); // keep any input logic in sync
        }
        recalc();
      });
    });

    document.getElementById('FAIRING_CB')?.addEventListener('change', recalc);

    // Clear handler: only reset values, don't attach listeners here
    document.getElementById('C172_CLEAR')?.addEventListener('click', ()=>{
      ['F_ELEV','F_ELEV_CR','F_ALT','F_OAT','F_OAT_CR','RWY_HDG','WIND_AT','AC_WT','RWY_SLOPE','CR_RPM']
        .forEach(id=>{
          const el = document.getElementById(id);
          if (el) el.value = '';
        });

      const s = document.getElementById('RWY_SURF'); if (s) s.selectedIndex = 0;
      const f = document.getElementById('LD_FLAPS'); if (f) f.value = 'full';

      // reset note + fairings checkbox default
      const noteEl = document.getElementById('LD_NOTE'); if (noteEl) noteEl.textContent = '';
      const fair = document.getElementById('FAIRING_CB'); if (fair) fair.checked = true;

      recalc();
    });

    recalc();
  })();
  </script>

  <script>
/* Arrow Up/Down focus navigation within the open panel (skips buttons) */
(function enableArrowNav(){
  function focusables(root){
    return Array.from(
      root.querySelectorAll('input:not([type=button]):not([type=checkbox]):not([type=radio]), select, textarea')
    ).filter(el => !el.disabled && el.offsetParent !== null);
  }

  document.addEventListener('keydown', (e) => {
    if (e.key !== 'ArrowDown' && e.key !== 'ArrowUp' && e.key !== 'Enter') return;
    const panel = e.target.closest('.panel');
    if (!panel) return;

    const list = focusables(panel);
    const i = list.indexOf(e.target);
    if (i === -1) return;

    // Prevent the cursor from just moving inside the same field
    e.preventDefault();

    const next = (e.key === 'ArrowUp') ? list[i - 1] : list[i + 1];
    if (next) next.focus();
  }, true); // capture = true so it beats any inner handlers
})();
</script>

<script>
/* compact + scoped logic */
(function(){
  const root=document.getElementById('av-conversions'); if(!root) return;
  const num=v=>{if(v==null) return NaN; const x=parseFloat(String(v).replace(/[^0-9eE+.\-]/g,'')); return isFinite(x)?x:NaN};
  const fmt=v=>!isFinite(v)?'':(Math.abs(v)>=100?v.toFixed(0):Math.abs(v)>=10?v.toFixed(1):v.toFixed(2));
  let lock=false;

  // --- Accordion: when one details opens, close the rest
  const allDetails = [...root.querySelectorAll('details[data-sec]')];
  allDetails.forEach(d=>{
    d.addEventListener('toggle',()=>{ if(d.open){ allDetails.forEach(o=>{ if(o!==d) o.open=false; }); } });
  });

  // --- Clear button: show if any input/select has a value; clears that section
  function updateClearButton(sec){
    const btn = sec.querySelector('.clear-btn'); if (!btn) return;
    const hasInput = [...sec.querySelectorAll('input')].some(el => el.value && el.value.trim() !== '');
    const hasSelectChange = [...sec.querySelectorAll('select')].some(s => s.dataset.userChanged === '1');
    btn.style.display = (hasInput || hasSelectChange) ? 'inline-block' : 'none';
  }

    function bindSectionClear(sec){
    const btn=sec.querySelector('.clear-btn'); if(!btn) return;

    // Mark selects only after user changes them (so defaults don't show Clear)
    sec.querySelectorAll('select').forEach(s=>{
        s.addEventListener('change',()=>{
        s.dataset.userChanged='1';
        updateClearButton(sec);
        });
    });

    // Inputs toggle Clear visibility as you type
    sec.addEventListener('input',()=>updateClearButton(sec));
    sec.addEventListener('change',()=>updateClearButton(sec));

    btn.addEventListener('click',()=>{
        // Clear inputs
        sec.querySelectorAll('input').forEach(i=>i.value='');

        // Reset selects: keep Fuel Type = 6.00 (default), others to first option
        sec.querySelectorAll('select').forEach(s=>{
        if(s.id==='CNV_FUEL_TYPE'){ s.value='6.00'; } else { s.selectedIndex=0; }
        delete s.dataset.userChanged;  // back to "unchanged" state
        });

        // Fuel custom density resets + disabled
        const dens=document.getElementById('CNV_FUEL_DENS');
        if(dens){ dens.value=''; dens.disabled=true; }

        updateClearButton(sec); // hide the Clear button
    });

    // Initial state: hidden
    updateClearButton(sec);
    }
  allDetails.forEach(d=>bindSectionClear(d));

  // Fuel type → only show custom density when "custom" is selected
  const FUEL_TYPE   = document.getElementById('CNV_FUEL_TYPE');
  const DENS_FIELD  = document.getElementById('CNV_FUEL_DENS_FIELD');
  const DENS_INPUT  = document.getElementById('CNV_FUEL_DENS');

  function syncFuelDensityUI(){
    const isCustom = FUEL_TYPE?.value === 'custom';
    if (!DENS_FIELD || !DENS_INPUT) return;
    DENS_FIELD.style.display = isCustom ? '' : 'none';
    DENS_INPUT.disabled = !isCustom;
    if (!isCustom) DENS_INPUT.value = ''; // optional: clear when hiding
  }

  FUEL_TYPE?.addEventListener('change', syncFuelDensityUI);
  syncFuelDensityUI(); // run once on load


  // --- linear groups (factor -> base)
  function bindLinear(grid){
    const map=JSON.parse(grid.dataset.map||'{}'), inputs=[...grid.querySelectorAll('input[data-unit]')];
    inputs.forEach(inp=>inp.addEventListener('input',()=>{ if(lock) return; const v=num(inp.value);
      if(!isFinite(v)){inputs.forEach(i=>{if(i!==inp)i.value=''}); return;}
      lock=true; const base=v*map[inp.dataset.unit]; inputs.forEach(o=>{ if(o!==inp){ o.value=fmt(base/map[o.dataset.unit]); } }); lock=false;
    }));
  }

    // --- speed (kt/mph/kmh/mps + Mach using OAT)
    function bindSpeed(grid){
        const get = k => grid.querySelector(`input[data-speed="${k}"]`);
        const KT = get('kt'), MPH = get('mph'), KMH = get('kmh'), MPS = get('mps'), MACH = get('mach');
        const OAT = root.querySelector('#CNV_OAT');

        const KTS_TO_MPS = 0.514444444;
        const MPH_TO_MPS = 0.44704;
        const KMH_TO_MPS = 0.277777778;

        const gamma = 1.4;          // air specific heat ratio
        const R = 287.05287;        // J/(kg·K)
        const mpsToKt = v => v / KTS_TO_MPS;
        const mpsToMph = v => v / MPH_TO_MPS;
        const mpsToKmh = v => v / KMH_TO_MPS;

        const num = v => { if(v==null) return NaN; const x=parseFloat(String(v).replace(/[^0-9eE+.\-]/g,'')); return isFinite(x)?x:NaN; };

        function speedOfSoundMps(){
        const tC = num(OAT?.value);
        if (!isFinite(tC)) return NaN; // No temperature → no Mach calculation
        const T = tC + 273.15;
        return Math.sqrt(gamma * R * T);
        }

        let lock=false;

        function fromMPS(v){
        if(!isFinite(v)){ [KT,MPH,KMH,MACH].forEach(i=>{ if(i) i.value=''; }); return; }
        const a = speedOfSoundMps();
        lock=true;
        if(document.activeElement!==MPS)  MPS.value = fmt(v);
        if(document.activeElement!==KT)   KT.value  = fmt(mpsToKt(v));
        if(document.activeElement!==MPH)  MPH.value = fmt(mpsToMph(v));
        if(document.activeElement!==KMH)  KMH.value = fmt(mpsToKmh(v));
        if(document.activeElement!==MACH){
        MACH.value = isFinite(a) ? fmt(v / a) : ''; // Clear Mach if OAT missing
        }
        lock=false;
        }

        function fromKT(v){ fromMPS(v * KTS_TO_MPS); }
        function fromMPH(v){ fromMPS(v * MPH_TO_MPS); }
        function fromKMH(v){ fromMPS(v * KMH_TO_MPS); }
        function fromMach(m){
            const a = speedOfSoundMps();
            if(!isFinite(a)){ // No OAT
                [KT,MPH,KMH,MPS].forEach(i => { if(i) i.value=''; });
                return;
            }
            fromMPS(m * a);
            }

        [[KT,fromKT],[MPH,fromMPH],[KMH,fromKMH],[MPS,fromMPS],[MACH,fromMach]].forEach(([el,fn])=>{
        el && el.addEventListener('input',()=>{
            if(lock) return;
            const v = num(el.value);
            if(isFinite(v)) fn(v);
            else { [KT,MPH,KMH,MPS,MACH].forEach(i=>{ if(i!==el && i) i.value=''; }); }
        });
        });

        // Recompute Mach conversions if OAT changes and any field is populated
        OAT && OAT.addEventListener('input', ()=>{
        const values=[KT,MPH,KMH,MPS,MACH].map(i=>num(i?.value));
        const any = values.find(isFinite);
        if(!isFinite(any)) return;
        if(isFinite(num(MPS?.value))) fromMPS(num(MPS.value));
        else if(isFinite(num(KT?.value))) fromKT(num(KT.value));
        else if(isFinite(num(MPH?.value))) fromMPH(num(MPH.value));
        else if(isFinite(num(KMH?.value))) fromKMH(num(KMH.value));
        else if(isFinite(num(MACH?.value))) fromMach(num(MACH.value));
        });
    }

  // --- temperature (fixed)
  function bindTemp(grid){
    const C=grid.querySelector('input[data-unit="C"]'),
          F=grid.querySelector('input[data-unit="F"]'),
          K=grid.querySelector('input[data-unit="K"]');
    function fromC(v){ lock=true; F.value=fmt(v*9/5+32); K.value=fmt(v+273.15); lock=false; }
    function fromF(v){ const c=(v-32)*5/9; lock=true; C.value=fmt(c); K.value=fmt(c+273.15); lock=false; }
    function fromK(v){ const c=v-273.15; lock=true; C.value=fmt(c); F.value=fmt(c*9/5+32); lock=false; }
    [[C,fromC],[F,fromF],[K,fromK]].forEach(([el,fn])=>{
      el.addEventListener('input',()=>{ if(lock) return; const v=num(el.value);
        if(!isFinite(v)){ [C,F,K].forEach(i=>{if(i!==el)i.value=''}); return; } fn(v);
      });
    });
  }

  // --- fuel density helpers (fixed)
  const selFuel=root.querySelector('#CNV_FUEL_TYPE'), densIn=root.querySelector('#CNV_FUEL_DENS');
  if(selFuel){
    selFuel.addEventListener('change',()=>{ const custom=selFuel.value==='custom'; if(densIn){ densIn.disabled=!custom; if(!custom) densIn.value=''; }});
  }
  const fuelDensityLbGal=()=>{ const v=(selFuel&&selFuel.value==='custom')?num(densIn?.value):num(selFuel?.value||'6.00'); return isFinite(v)&&v>0?v:6.00; };
  const kgPerL=()=>fuelDensityLbGal()*0.45359237/3.785411784;

  // --- fuel volumes/mass (fixed)
  function bindFuel(grid){
    const get=k=>grid.querySelector(`input[data-fuel="${k}"]`);
    const GAL=get('galUS'), L=get('L'), IGL=get('galImp'), LB=get('lb'), KG=get('kg');
    function toAllFromVol(l){ const kg=l*kgPerL(); lock=true;
      if(document.activeElement!==L) L.value=fmt(l);
      if(document.activeElement!==GAL) GAL.value=fmt(l/3.785411784);
      if(document.activeElement!==IGL) IGL.value=fmt(l/4.54609);
      if(document.activeElement!==KG) KG.value=fmt(kg);
      if(document.activeElement!==LB) LB.value=fmt(kg/0.45359237);
      lock=false;
    }
    function toAllFromMass(kg){ const l=kg/kgPerL(); lock=true;
      if(document.activeElement!==KG) KG.value=fmt(kg);
      if(document.activeElement!==LB) LB.value=fmt(kg/0.45359237);
      if(document.activeElement!==L) L.value=fmt(l);
      if(document.activeElement!==GAL) GAL.value=fmt(l/3.785411784);
      if(document.activeElement!==IGL) IGL.value=fmt(l/4.54609);
      lock=false;
    }
    ;[GAL,L,IGL,LB,KG].forEach(inp=>inp.addEventListener('input',()=>{ if(lock) return; const v=num(inp.value);
      if(!isFinite(v)){[GAL,L,IGL,LB,KG].forEach(i=>{if(i!==inp)i.value=''}); return;}
      if(inp===GAL) toAllFromVol(v*3.785411784);
      if(inp===L)   toAllFromVol(v);
      if(inp===IGL) toAllFromVol(v*4.54609);
      if(inp===LB)  toAllFromMass(v*0.45359237);
      if(inp===KG)  toAllFromMass(v);
    }));
    [selFuel,densIn].forEach(el=>el&&el.addEventListener('input',()=>{ // recompute using filled field, if any
      const values=[GAL,L,IGL,LB,KG].map(i=>num(i.value)); const any=values.find(v=>isFinite(v));
      if(!isFinite(any)) return;
      if(isFinite(num(GAL.value))) toAllFromVol(num(GAL.value)*3.785411784);
      else if(isFinite(num(L.value))) toAllFromVol(num(L.value));
      else if(isFinite(num(IGL.value))) toAllFromVol(num(IGL.value)*4.54609);
      else if(isFinite(num(KG.value))) toAllFromMass(num(KG.value));
      else if(isFinite(num(LB.value))) toAllFromMass(num(LB.value)*0.45359237);
    }));
  }

  // --- fuel flow (fixed)
  function bindFuelFlow(grid){
    const gph=grid.querySelector('input[data-flow="gph"]'),
          lph=grid.querySelector('input[data-flow="lph"]'),
          pph=grid.querySelector('input[data-flow="pph"]'),
          kgh=grid.querySelector('input[data-flow="kgh"]');
    function fromGPH(v){ const kgph=v*3.785411784*kgPerL(); lock=true;
      if(document.activeElement!==gph) gph.value=fmt(v);
      if(document.activeElement!==lph) lph.value=fmt(v*3.785411784);
      if(document.activeElement!==kgh) kgh.value=fmt(kgph);
      if(document.activeElement!==pph) pph.value=fmt(kgph/0.45359237);
      lock=false;
    }
    function fromLPH(v){ fromGPH(v/3.785411784); }
    function fromKGH(v){ const g=v/(3.785411784*kgPerL()); lock=true;
      if(document.activeElement!==kgh) kgh.value=fmt(v);
      if(document.activeElement!==pph) pph.value=fmt(v/0.45359237);
      if(document.activeElement!==lph) lph.value=fmt(g*3.785411784);
      if(document.activeElement!==gph) gph.value=fmt(g);
      lock=false;
    }
    function fromPPH(v){ fromKGH(v*0.45359237); }
    [[gph,fromGPH],[lph,fromLPH],[kgh,fromKGH],[pph,fromPPH]].forEach(([el,fn])=>{
      el.addEventListener('input',()=>{ if(lock) return; const v=num(el.value);
        if(!isFinite(v)){[gph,lph,kgh,pph].forEach(i=>{if(i!==el)i.value=''}); return;} fn(v);
      });
    });
    [selFuel,densIn].forEach(el=>el&&el.addEventListener('input',()=>{ // recalc on density change
      if(isFinite(num(gph.value))) fromGPH(num(gph.value));
      else if(isFinite(num(lph.value))) fromLPH(num(lph.value));
      else if(isFinite(num(kgh.value))) fromKGH(num(kgh.value));
      else if(isFinite(num(pph.value))) fromPPH(num(pph.value));
    }));
  }

    // --- gradient (now includes Degrees)
    function bindGradient(grid){
        const pct = grid.querySelector('input[data-grad="pct"]'),
            ftnm= grid.querySelector('input[data-grad="ftnm"]'),
            mkm = grid.querySelector('input[data-grad="mkm"]'),
            fpm = grid.querySelector('input[data-grad="fpm"]'),
            deg = grid.querySelector('input[data-grad="deg"]'),
            gs  = root.querySelector('#CNV_GS');

        const FPNM_PER_PCT = 60.761154905;
        const toDeg = p => Math.atan(p/100) * (180/Math.PI);
        const fromDegToPct = d => Math.tan(d * Math.PI/180) * 100;

        function fromPct(p){
        const fpnm = p * FPNM_PER_PCT, mk = p * 10, kt = num(gs?.value);
        lock = true;
        if(document.activeElement!==pct)  pct.value  = fmt(p);
        if(document.activeElement!==ftnm) ftnm.value = fmt(fpnm);
        if(document.activeElement!==mkm)  mkm.value  = fmt(mk);
        if(document.activeElement!==deg)  deg.value  = fmt(toDeg(p));
        if(document.activeElement!==fpm)  fpm.value  = (isFinite(kt)&&kt>0)? fmt(fpnm*(kt/60)) : '';
        lock = false;
        }
        function fromFPNM(v){ fromPct(v / FPNM_PER_PCT); }
        function fromMKM(v){  fromPct(v / 10); }
        function fromFPM(v){
        const kt = num(gs?.value);
        if(!isFinite(kt)||kt<=0){ lock=true; [pct,ftnm,mkm,deg].forEach(i=>{ if(i) i.value=''; }); lock=false; return; }
        fromFPNM(v * 60 / kt);
        }
        function fromDeg(d){ fromPct(fromDegToPct(d)); }

        [[pct,fromPct],[ftnm,fromFPNM],[mkm,fromMKM],[fpm,fromFPM],[deg,fromDeg]].forEach(([el,fn])=>{
        el && el.addEventListener('input',()=>{
            if(lock) return;
            const v = num(el.value);
            if(!isFinite(v)){ [pct,ftnm,mkm,fpm,deg].forEach(i=>{ if(i!==el && i) i.value=''; }); return; }
            fn(v);
        });
        });

        gs?.addEventListener('input',()=>{ // recompute fpm when GS changes
        const p=num(pct?.value), f=num(ftnm?.value), m=num(mkm?.value), fp=num(fpm?.value), d=num(deg?.value);
        if(isFinite(p)) fromPct(p);
        else if(isFinite(f)) fromFPNM(f);
        else if(isFinite(m)) fromMKM(m);
        else if(isFinite(d)) fromDeg(d);
        else if(isFinite(fp)) fromFPM(fp);
        });
    }

  // --- weight/mass/force (fixed)
  function bindWeight(grid){
    const lb=grid.querySelector('input[data-weight="lb"]'),
          kg=grid.querySelector('input[data-weight="kg"]'),
          N =grid.querySelector('input[data-weight="N"]');
    function fromLB(v){ const k=v*0.45359237; lock=true; if(document.activeElement!==kg) kg.value=fmt(k); if(document.activeElement!==N) N.value=fmt(k*9.80665); lock=false; }
    function fromKG(v){ lock=true; if(document.activeElement!==lb) lb.value=fmt(v/0.45359237); if(document.activeElement!==N) N.value=fmt(v*9.80665); lock=false; }
    function fromN (v){ const k=v/9.80665; lock=true; if(document.activeElement!==kg) kg.value=fmt(k); if(document.activeElement!==lb) lb.value=fmt(k/0.45359237); lock=false; }
    [[lb,fromLB],[kg,fromKG],[N,fromN]].forEach(([el,fn])=>el.addEventListener('input',()=>{ if(lock) return; const v=num(el.value);
      if(!isFinite(v)){[lb,kg,N].forEach(i=>{if(i!==el)i.value=''}); return;} fn(v);
    }));
  }

    (function(){
    const root=document.getElementById('av-conversions'); if(!root) return;
    const num=v=>{if(v==null)return NaN;const x=parseFloat(String(v).replace(/[^0-9eE+.\-]/g,''));return isFinite(x)?x:NaN};
    const pad2=n=>String(Math.floor(Math.abs(n))).padStart(2,'0');
    const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

    // ---------- A) Decimal Time binders ----------
    function bindTime(grid){
        const decH=grid.querySelector('input[data-time="decH"]');
        const hhmm=grid.querySelector('input[data-time="hhmm"]');
        const decM=grid.querySelector('input[data-time="decM"]');
        const mmss=grid.querySelector('input[data-time="mmss"]');
        let lock=false;

        function fromDecH(v){ if(lock) return; lock=true;
        const h=Math.floor(v), m=Math.round((v-h)*60);
        if(document.activeElement!==hhmm) hhmm.value=`${h}:${pad2(m)}`;
        if(document.activeElement!==decM) decM.value=(v*60).toFixed(2).replace(/\.00$/,'');
        if(document.activeElement!==mmss){ const mm=Math.floor(v*60), ss=Math.round((v*3600)%60); mmss.value=`${mm}:${pad2(ss)}`;}
        lock=false;
        }
        function fromHHMM(txt){ if(lock) return; lock=true;
        const m=String(txt||'').match(/^(-?\d{1,3}):(\d{1,2})$/); if(!m){ if(document.activeElement!==decH) decH.value=''; lock=false; return; }
        const h=parseInt(m[1],10), min=clamp(parseInt(m[2],10),0,59); const v=h+(min/60);
        if(document.activeElement!==decH) decH.value=v.toFixed(2).replace(/\.00$/,'');
        if(document.activeElement!==decM) decM.value=(v*60).toFixed(2).replace(/\.00$/,'');
        if(document.activeElement!==mmss){ const mm=h*60+min, ss=0; mmss.value=`${mm}:${pad2(ss)}`; }
        lock=false;
        }
        function fromDecM(v){ if(lock) return; lock=true;
        const mm=Math.floor(v), ss=Math.round((v-mm)*60);
        if(document.activeElement!==mmss) mmss.value=`${mm}:${pad2(ss)}`;
        if(document.activeElement!==decH) decH.value=(v/60).toFixed(2).replace(/\.00$/,'');
        if(document.activeElement!==hhmm){ const h=Math.floor(v/60), m=Math.round(v%60); hhmm.value=`${h}:${pad2(m)}`; }
        lock=false;
        }
        function fromMMSS(txt){ if(lock) return; lock=true;
        const m=String(txt||'').match(/^(-?\d{1,5}):(\d{1,2})$/); if(!m){ if(document.activeElement!==decM) decM.value=''; lock=false; return; }
        const mm=parseInt(m[1],10), ss=clamp(parseInt(m[2],10),0,59); const v=mm+(ss/60);
        if(document.activeElement!==decM) decM.value=v.toFixed(2).replace(/\.00$/,'');
        if(document.activeElement!==decH) decH.value=(v/60).toFixed(2).replace(/\.00$/,'');
        if(document.activeElement!==hhmm){ const h=Math.floor(v/60), m2=Math.round(v%60); hhmm.value=`${h}:${pad2(m2)}`; }
        lock=false;
        }

        decH && decH.addEventListener('input',()=>{ const v=num(decH.value); if(isFinite(v)) fromDecH(v); else { if(hhmm) hhmm.value=''; if(decM) decM.value=''; if(mmss) mmss.value=''; }});
        hhmm && hhmm.addEventListener('input',()=>fromHHMM(hhmm.value));
        decM && decM.addEventListener('input',()=>{ const v=num(decM.value); if(isFinite(v)) fromDecM(v); else { if(mmss) mmss.value=''; if(decH) decH.value=''; if(hhmm) hhmm.value=''; }});
        mmss && mmss.addEventListener('input',()=>fromMMSS(mmss.value));
    }

    // ---------- B) Time Zone converter ----------
    // Zone dataset: key aviation/IANA representatives across ALL UTC offsets (−12..+14).
    // offset: minutes from UTC (standard, without DST). dst: 'yes'|'no'|'varies', note: concise rule hint.
    const ZONES=[
        {id:'UTC', name:'UTC (Zulu)', off:0, dst:'no', note:'No DST'},
        // UTC−12..−9
        {id:'Etc/GMT+12', name:'UTC−12', off:-12*60, dst:'no', note:'No DST'},
        {id:'Pacific/Pago_Pago', name:'Samoa (American)', off:-11*60, dst:'no', note:'No DST'},
        {id:'Pacific/Honolulu', name:'Hawaii', off:-10*60, dst:'no', note:'US HI no DST'},
        {id:'America/Anchorage', name:'Alaska', off:-9*60, dst:'yes', note:'US: Mar–Nov'},
        // UTC−8..−5
        {id:'America/Los_Angeles', name:'US Pacific', off:-8*60, dst:'yes', note:'US: Mar–Nov'},
        {id:'America/Phoenix', name:'US Arizona', off:-7*60, dst:'no', note:'No DST (most)'},
        {id:'America/Denver', name:'US Mountain', off:-7*60, dst:'yes', note:'US: Mar–Nov'},
        {id:'America/Chicago', name:'US Central', off:-6*60, dst:'yes', note:'US: Mar–Nov'},
        {id:'America/Mexico_City', name:'Mexico City', off:-6*60, dst:'no', note:'Most MX no DST (border varies)'},
        {id:'America/New_York', name:'US Eastern', off:-5*60, dst:'yes', note:'US: Mar–Nov'},
        // UTC−4..−2.5
        {id:'America/Halifax', name:'Canada Atlantic', off:-4*60, dst:'yes', note:'CA: Mar–Nov'},
        {id:'America/Caracas', name:'Venezuela', off:-4*60-30, dst:'no', note:'No DST'},
        {id:'America/Sao_Paulo', name:'Sao Paulo', off:-3*60, dst:'no', note:'No DST'},
        {id:'America/St_Johns', name:'Newfoundland', off:-3*60-30, dst:'yes', note:'CA: Mar–Nov'},
        // UTC−1..+1
        {id:'Atlantic/Azores', name:'Azores', off:-60, dst:'yes', note:'EU: Mar–Oct'},
        {id:'Atlantic/Cape_Verde', name:'Cape Verde', off:-60, dst:'no', note:'No DST'},
        {id:'Europe/London', name:'UK/Ireland (WET/BST)', off:0, dst:'yes', note:'EU: Mar–Oct'},
        {id:'Africa/Abidjan', name:'WET (no DST)', off:0, dst:'no', note:'No DST'},
        {id:'Europe/Paris', name:'CET (Paris/Berlin)', off:+60, dst:'yes', note:'EU: Mar–Oct'},
        // UTC+2..+5
        {id:'Europe/Athens', name:'EET (Athens)', off:+120, dst:'yes', note:'EU: Mar–Oct'},
        {id:'Africa/Johannesburg', name:'South Africa', off:+120, dst:'no', note:'No DST'},
        {id:'Europe/Istanbul', name:'Turkey (TRT)', off:+180, dst:'no', note:'Permanent UTC+3'},
        {id:'Asia/Jerusalem', name:'Israel', off:+120, dst:'yes', note:'Mar–Oct (varies)'},
        {id:'Asia/Dubai', name:'Gulf (GST)', off:+240, dst:'no', note:'No DST'},
        {id:'Asia/Tehran', name:'Iran', off:+210, dst:'no', note:'No DST'},
        {id:'Asia/Karachi', name:'Pakistan', off:+300, dst:'no', note:'No DST'},
        // UTC+5:30..+8
        {id:'Asia/Kolkata', name:'India (IST)', off:+330, dst:'no', note:'No DST'},
        {id:'Asia/Dhaka', name:'Bangladesh', off:+360, dst:'no', note:'No DST'},
        {id:'Asia/Bangkok', name:'Indochina', off:+420, dst:'no', note:'No DST'},
        {id:'Asia/Singapore', name:'Singapore', off:+480, dst:'no', note:'No DST'},
        {id:'Asia/Shanghai', name:'China', off:+480, dst:'no', note:'No DST'},
        {id:'Asia/Tokyo', name:'Japan', off:+540, dst:'no', note:'No DST'},
        {id:'Asia/Seoul', name:'Korea', off:+540, dst:'no', note:'No DST'},
        // UTC+8..+11
        {id:'Australia/Perth', name:'AWST (Perth)', off:+480, dst:'no', note:'No DST'},
        {id:'Australia/Darwin', name:'ACST (Darwin)', off:+570, dst:'no', note:'No DST'},
        {id:'Australia/Adelaide', name:'ACST/ACDT (Adelaide)', off:+570, dst:'yes', note:'Oct–Apr (state rules)'},
        {id:'Australia/Brisbane', name:'AEST (Brisbane)', off:+600, dst:'no', note:'No DST (QLD)'},
        {id:'Australia/Sydney', name:'AEST/AEDT (Sydney)', off:+600, dst:'yes', note:'Oct–Apr (AU)'},
        {id:'Pacific/Guam', name:'Guam/ChST', off:+600, dst:'no', note:'No DST'},
        {id:'Pacific/Noumea', name:'New Caledonia', off:+660, dst:'no', note:'No DST'},
        {id:'Pacific/Norfolk', name:'Norfolk Island', off:+660, dst:'yes', note:'Seasonal (varies)'},
        {id:'Pacific/Norfolk_old', name:'Lord Howe (HLT/HDT)', off:+630, dst:'yes', note:'+10:30 std, +11:00 dst'},
        {id:'Pacific/Guadalcanal', name:'Solomon Islands', off:+660, dst:'no', note:'No DST'},
        // UTC+12..+14
        {id:'Pacific/Auckland', name:'NZST/NZDT', off:+720, dst:'yes', note:'Sep–Apr (NZ)'},
        {id:'Pacific/Fiji', name:'Fiji', off:+720, dst:'yes', note:'Seasonal (varies)'},
        {id:'Pacific/Tarawa', name:'Kiribati (Gilbert)', off:+720, dst:'no', note:'No DST'},
        {id:'Pacific/Chatham', name:'Chatham Is.', off:+765, dst:'yes', note:'NZ rules (+45 min)'},
        {id:'Pacific/Tongatapu', name:'Tonga', off:+780, dst:'no', note:'No DST'},
        {id:'Pacific/Kiritimati', name:'Line Is. (UTC+14)', off:+840, dst:'no', note:'No DST'}
    ];

    function fillTZSelects(sec){
      const sFrom = sec.querySelector('select[data-tz="from"]');
      const sTo   = sec.querySelector('select[data-tz="to"]');
      if(!sFrom || !sTo) return;

      const mkOpt = z => {
        const o = document.createElement('option');
        o.value = z.id;
        const sign = z.off>=0 ? '+' : '';
        const hh = Math.trunc(Math.abs(z.off)/60), mm = Math.abs(z.off)%60;
        o.textContent = `${z.name} (UTC${sign}${hh}${mm?':'+String(mm).padStart(2,'0'):''})`;
        return o;
      };

      // (Re)build options
      sFrom.innerHTML = '';
      sTo.innerHTML = '';
      ZONES.forEach(z => {
        sFrom.appendChild(mkOpt(z));
        sTo.appendChild(mkOpt(z));
      });

      // Defaults: From stays UTC; To = system zone if found, else US/Eastern
      const localTZ = (Intl.DateTimeFormat().resolvedOptions().timeZone || '').trim();
      const hasLocal = ZONES.some(z => z.id === localTZ);

      sFrom.value = 'UTC';
      sTo.value   = hasLocal ? localTZ : 'America/New_York';
    }
    function findZone(id){ return ZONES.find(z=>z.id===id)||ZONES[0]; }
    function offWithDst(z, mode){
        // mode: 'auto'|'yes'|'no' ; auto => add 60 if zone observes DST (z.dst==='yes')
        const add = mode==='yes' ? 60 : (mode==='no' ? 0 : (z.dst==='yes' ? 60 : 0));
        return z.off + add;
    }
    function tzInfoString(z, mode){
        const sign=z.off>=0?'+':''; const hh=Math.trunc(Math.abs(z.off)/60), mm=Math.abs(z.off)%60;
        const base=`STD UTC${sign}${hh}${mm?':'+String(mm).padStart(2,'0'):''}`;
        const dstPart = (mode==='yes' || (mode==='auto' && z.dst==='yes')) ? ' +DST' : (z.dst==='yes'?' (DST avail)':'');
        return `${z.name}: ${base} • ${z.dst==='no'?'No DST':z.note}${dstPart}`;
        }

    function parseClockHHMM(txt){
        const m=String(txt||'').trim().match(/^(-?\d{1,3}):(\d{1,2})$/); if(!m) return NaN;
        const h=parseInt(m[1],10), mm=clamp(parseInt(m[2],10),0,59); return h*60+mm;
    }
    function fmtHHMM(totalMin){
        const neg=totalMin<0; let m=Math.abs(Math.round(totalMin));
        const h=Math.trunc(m/60), mm=m%60; return (neg?'-':'')+h+':'+String(mm).padStart(2,'0');
    }

    function bindTZ(grid){
      const inLocal = grid.querySelector('input[data-tz="local"]');
      const out     = grid.querySelector('input[data-tz="out"]');
      const sFrom   = grid.querySelector('select[data-tz="from"]');
      const sTo     = grid.querySelector('select[data-tz="to"]');
      const fromDst = grid.parentElement.querySelector('select[data-tz="fromDst"]');
      const toDst   = grid.parentElement.querySelector('select[data-tz="toDst"]');
      const swapBtn = grid.parentElement.querySelector('[data-tz="swap"]')
             || grid.querySelector('[data-tz="swap"]');

      // Support both the old inputs (data-tzinfo="from|to") and your new spans
      const infoFrom = grid.parentElement.querySelector('[data-tzinfo="from"]')
                    || grid.parentElement.querySelector('.tz-info-note [data-tz="from"]');
      const infoTo   = grid.parentElement.querySelector('[data-tzinfo="to"]')
                    || grid.parentElement.querySelector('.tz-info-note [data-tz="to"]');

      // write helper: input.value OR span.textContent
      const setInfo = (el, s) => {
        if (!el) return;
        if ('value' in el) el.value = s;
        else el.textContent = s;
      };

      function recalc(){
        if (!sFrom || !sTo || !fromDst || !toDst || !out) return;

        const zFrom = findZone(sFrom.value);
        const zTo   = findZone(sTo.value);

        const fMode = (fromDst.value || 'auto');
        const tMode = (toDst.value   || 'auto');

        setInfo(infoFrom, tzInfoString(zFrom, fMode));
        setInfo(infoTo,   tzInfoString(zTo,   tMode));

        const mins = parseClockHHMM(inLocal?.value || '');
        if (!isFinite(mins)){ out.value = ''; return; }

        const offFrom = offWithDst(zFrom, fMode);
        const offTo   = offWithDst(zTo,   tMode);

        const utcMins = mins - offFrom;   // local-from -> UTC
        const toMins  = utcMins + offTo;  // UTC -> local-to
        out.value = fmtHHMM(toMins);
      }

      [inLocal, sFrom, sTo, fromDst, toDst].forEach(el=>{
        if (!el) return;
        el.addEventListener('input',  recalc);
        el.addEventListener('change', recalc);
      });

      // populate selects (guard in case .content wrapper isn't present)
      const secRoot = grid.closest('.content') || grid;
      if (secRoot && typeof fillTZSelects === 'function') fillTZSelects(secRoot);

      if (swapBtn) {
        swapBtn.addEventListener('click', () => {
          if (!sFrom || !sTo) return;

          // swap zone selections
          const tmpZone = sFrom.value;
          sFrom.value = sTo.value;
          sTo.value   = tmpZone;

          // swap DST modes if present
          if (fromDst && toDst) {
            const tmpDst = fromDst.value;
            fromDst.value = toDst.value;
            toDst.value   = tmpDst;
          }

          // re-run conversion
          recalc();
        });
      }

      recalc();
    }

    // Hook up the new groups if present
    const timeGrid=root.querySelector('[data-group="time"]'); if(timeGrid) bindTime(timeGrid);
    const tzGrid=root.querySelector('[data-group="tz"]'); if(tzGrid) bindTZ(tzGrid);
    })();


  // --- bind all groups
  root.querySelectorAll('[data-group="linear"]').forEach(bindLinear);
  root.querySelectorAll('[data-group="temp"]').forEach(bindTemp);
  const fuelGrid=root.querySelector('[data-group="fuel"]'); if(fuelGrid) bindFuel(fuelGrid);
  const flowGrid=root.querySelector('[data-group="fuelflow"]'); if(flowGrid) bindFuelFlow(flowGrid);
  const gradGrid=root.querySelector('[data-group="gradient"]'); if(gradGrid) bindGradient(gradGrid);
  const wGrid=root.querySelector('[data-group="weight"]'); if(wGrid) bindWeight(wGrid);
  const spGrid=root.querySelector('[data-group="speed"]'); if(spGrid) bindSpeed(spGrid);
})();
</script>

<script>
// --- tiny 'fire' helper (if not already present)
function fire(el){
  try{
    el.dispatchEvent(new Event('input',{bubbles:true}));
    el.dispatchEvent(new Event('change',{bubbles:true}));
  }catch(_){}
}

// --- generic ± sign toggler (scoped to the nearest input-affix)
document.addEventListener('click', (ev) => {
  const btn = ev.target.closest('.oat-sign-btn');
  if (!btn) return;

  // 1) Prefer the input inside the same .input-affix group
  let input = btn.closest('.input-affix')?.querySelector('input, textarea') || null;

  // 2) Fallback: if the button sits right after the input, use the previous sibling
  if (!input) {
    const prev = btn.previousElementSibling;
    if (prev && (prev.tagName === 'INPUT' || prev.tagName === 'TEXTAREA')) {
      input = prev;
    }
  }

  // 3) Last resort: nearest .oat-wrap (may hit the first input—only used if the above fail)
  if (!input) {
    input = btn.closest('.oat-wrap')?.querySelector('input, textarea') || null;
  }

  if (!input) return;

  const raw = String(input.value ?? '');
  const leadWS = (raw.match(/^\s*/) || [''])[0];
  let rest = raw.slice(leadWS.length);

  if (!rest) {
    input.value = leadWS + '-'; // let user type digits next
  } else if (rest[0] === '-' || rest[0] === '\u2212') {
    input.value = leadWS + rest.slice(1);
  } else if (rest[0] === '+') {
    input.value = leadWS + '-' + rest.slice(1);
  } else {
    input.value = leadWS + '-' + rest;
  }

  // keep your calculators reactive
  if (typeof fire === 'function') fire(input);
  input.dispatchEvent(new Event('input', { bubbles: true }));
  input.dispatchEvent(new Event('change', { bubbles: true }));

  // optional: per-field recalc hook
  const fnName = input.dataset.recalc || btn.dataset.recalc;
  if (fnName && typeof window[fnName] === 'function') {
    try { window[fnName](); } catch (_) {}
  }

  input.focus({ preventScroll: true });
  const L = input.value.length;
  if (input.setSelectionRange) input.setSelectionRange(L, L);
});

</script>

<div id="PA_LIVE_OVERLAY" class="pa-live hidden" aria-hidden="true">
  <div class="pa-live-dialog" role="dialog" aria-modal="true">
    <div class="pa-live-top">
      <div class="pa-live-hdg">HDG: <span id="PA_LIVE_HDG">—°</span></div>
      <button class="pill action" id="PA_LIVE_CLOSE">Close</button>
    </div>

    <div class="pa-live-body">
      <div class="range-giant">
        <div class="label top">
          <div class="agl">Max: <strong class="num" id="PA_LIVE_MAX_AGL">—</strong> ft</div>
          <div class="msl" id="PA_LIVE_MAX_MSL">(— ft MSL)</div>
        </div>

        <div class="line" id="PA_LIVE_LINE">
          <div class="marker" id="PA_LIVE_MARKER"></div>
        </div>

        <div class="label bottom">
          <div class="msl" id="PA_LIVE_MIN_MSL">(— ft MSL)</div>
          <div class="agl">Min: <strong class="num" id="PA_LIVE_MIN_AGL">—</strong> ft</div>
        </div>
      </div>

      <div class="pa-live-number">
        <div class="pa-live-title">Pivotal Altitude</div>
        <!-- MSL big, AGL smaller (you already swapped) -->
        <div class="pa-live-msl" id="PA_LIVE_MSL">— ft MSL</div>
        <div class="pa-live-agl" id="PA_LIVE_AGL">— ft</div>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const $ = s => document.querySelector(s);
  const num = v => {
    const x = parseFloat(String(v||'').replace(/[^\-0-9.]/g,''));
    return Number.isFinite(x) ? x : NaN;
  };
  const setNum = (id, x, unit) => {
    const el = $(id);
    if(!el) return;
    if(!Number.isFinite(x)){ el.textContent = '—'; return; }
    const n = Math.round(x);
    el.textContent = unit === 'ft' ? n.toLocaleString() : String(n);
  };
  const setText = (id, txt) => { const el = $(id); if(el) el.textContent = txt; };

  // angles
  const norm360 = d => ((d % 360) + 360) % 360;
  const diffAngle = (a,b) => {
    const d = Math.abs(norm360(a) - norm360(b));
    return d > 180 ? 360 - d : d;
  };

  // wind along-heading (tailwind +)
  function tailwindComponentKt(headingDeg, windFromDeg, windSpeedKt){
    if(![headingDeg, windFromDeg, windSpeedKt].every(Number.isFinite)) return NaN;
    const windTo = norm360(windFromDeg + 180);
    const d = diffAngle(headingDeg, windTo);
    return windSpeedKt * Math.cos(d * Math.PI/180);
  }
  const pivAltFt = gs => Number.isFinite(gs) ? Math.max(0, (gs*gs)/11.3) : NaN;

  // DOM refs
  const I = {
    GS:   $('#PA_GS'),
    IAS:  $('#PA_IAS'),
    HDG:  $('#PA_HDG'),
    WF:   $('#PA_WIND_FROM'),
    W:    $('#PA_W'),
    GMSL: $('#PA_GROUND_MSL'),
    CLR:  $('#PA_CLEAR'),
    HDG_RECIP: $('#PA_HDG_RECIP'),
    IAS_PILLS: document.querySelectorAll('#panel-pivalt [data-ias]'),

    // Live controls
    LIVE_FIELD: $('#PA_LIVE_FIELD'),
    LIVE_OPEN:  $('#PA_LIVE_OPEN'),

    // Overlay els
    OVL:        $('#PA_LIVE_OVERLAY'),
    OVL_CLOSE:  $('#PA_LIVE_CLOSE'),
    OVL_HDG:    $('#PA_LIVE_HDG'),
    OVL_LINE:   $('#PA_LIVE_LINE'),
    OVL_MARK:   $('#PA_LIVE_MARKER'),
    OVL_AGL:    $('#PA_LIVE_AGL'),
    OVL_MSL:    $('#PA_LIVE_MSL'),
    OVL_MIN_AGL:$('#PA_LIVE_MIN_AGL'),
    OVL_MAX_AGL:$('#PA_LIVE_MAX_AGL'),
    OVL_MIN_MSL:$('#PA_LIVE_MIN_MSL'),
    OVL_MAX_MSL:$('#PA_LIVE_MAX_MSL')
  };

  // pills
  I.IAS_PILLS.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      if(I.IAS) I.IAS.value = btn.dataset.ias || '';
      recalc();
    });
  });

  // reciprocal
  I.HDG_RECIP?.addEventListener('click', ()=>{
    const h = num(I.HDG?.value);
    if(Number.isFinite(h)){
      let r = (h + 180) % 360; if(r < 0) r += 360;
      I.HDG.value = String(Math.round(r));
      recalc(); updateOverlayFromInputs(); // keep live in sync if open
    }
  });

  // clear
  I.CLR?.addEventListener('click', ()=>{
    ['PA_GS','PA_IAS','PA_HDG','PA_WIND_FROM','PA_W','PA_GROUND_MSL'].forEach(id=>{
      const e = document.getElementById(id);
      if(e) e.value = '';
    });
    recalc(); updateLiveButton(); updateOverlayFromInputs();
  });

  // input listeners
  [I.GS,I.IAS,I.HDG,I.WF,I.W,I.GMSL].forEach(el=>{
    el?.addEventListener('input', ()=>{ recalc(); updateLiveButton(); updateOverlayFromInputs(); });
    el?.addEventListener('change', ()=>{ recalc(); updateLiveButton(); updateOverlayFromInputs(); });
  });

  // ===== core math reused =====
  function computeWC(heading, wf, w){ return tailwindComponentKt(heading, wf, w); }
  function computeGSCalc(ias, wc){ return (Number.isFinite(ias) && Number.isFinite(wc)) ? (ias + wc) : NaN; }
  function computeGSUsed(gsDirect, gsCalc){ return Number.isFinite(gsDirect) ? gsDirect : gsCalc; }

  function computeMinMaxAGL(ias, w, gsDirect, wc){
    // Prefer IAS±W; else estimate base airspeed from GS and wc; else collapse.
    let baseAS = NaN;
    if (Number.isFinite(ias)) baseAS = ias;
    else if (Number.isFinite(gsDirect) && Number.isFinite(wc)) baseAS = gsDirect - wc;
    else if (Number.isFinite(gsDirect)) baseAS = gsDirect;

    if (Number.isFinite(baseAS) && Number.isFinite(w)) {
      const a = pivAltFt(baseAS - w);
      const b = pivAltFt(baseAS + w);
      return [Math.min(a,b), Math.max(a,b)];
    }
    // no wind / no base speed
    const p = pivAltFt(gsDirect);
    return [p, p];
  }

  // ===== panel recalc =====
  function recalc(){
    const gsDirect = num(I.GS?.value);
    const ias = num(I.IAS?.value);
    const hdg = num(I.HDG?.value);
    const wf  = num(I.WF?.value);
    const w   = num(I.W?.value);
    const gmsl= num(I.GMSL?.value);

    const wc = computeWC(hdg, wf, w);
    const gsCalc = computeGSCalc(ias, wc);
    const gsUsed = computeGSUsed(gsDirect, gsCalc);

    // Intermediates
    setNum('#PA_WC_NUM', wc, 'kt');
    setNum('#PA_GS_CALC_NUM', gsCalc, 'kt');
    setNum('#PA_GS_USED_NUM', gsUsed, 'kt');

    // Results
    const paAGL = pivAltFt(gsUsed);
    setNum('#PA_OUT_AGL_NUM', paAGL, 'ft');
    const targetMSL = (Number.isFinite(paAGL) && Number.isFinite(gmsl)) ? (paAGL + gmsl) : NaN;
    setNum('#PA_OUT_MSL_NUM', targetMSL, 'ft');

    // Mini column on panel
    const [minAGL, maxAGL] = computeMinMaxAGL(ias, w, gsDirect, wc);
    setNum('#PA_MIN_MINI_NUM', minAGL, 'ft');
    setNum('#PA_MAX_MINI_NUM', maxAGL, 'ft');

    // Mini column MSLs
    const minMSL = (Number.isFinite(minAGL) && Number.isFinite(gmsl)) ? (minAGL + gmsl) : NaN;
    const maxMSL = (Number.isFinite(maxAGL) && Number.isFinite(gmsl)) ? (maxAGL + gmsl) : NaN;
    setText('#PA_MIN_MSL', Number.isFinite(minMSL) ? `(${Math.round(minMSL).toLocaleString()} ft MSL)` : '(— ft MSL)');
    setText('#PA_MAX_MSL', Number.isFinite(maxMSL) ? `(${Math.round(maxMSL).toLocaleString()} ft MSL)` : '(— ft MSL)');
  }

  // ===== Live button visibility =====
  function updateLiveButton(){
    const haveSpeed = Number.isFinite(num(I.IAS?.value)) || Number.isFinite(num(I.GS?.value));
    const haveWind  = Number.isFinite(num(I.W?.value)) && Number.isFinite(num(I.WF?.value));
    const haveGMSL  = Number.isFinite(num(I.GMSL?.value));
    const show = haveSpeed && haveWind && haveGMSL;
    if(I.LIVE_FIELD) I.LIVE_FIELD.style.display = show ? '' : 'none';
  }

  // ===== Overlay logic =====
  let liveOn = false;
  let sensorActive = false;

  function openOverlay(){
    document.documentElement.classList.add('no-scroll'); document.body.classList.add('no-scroll');
    if(!I.OVL) return;
    I.OVL.classList.remove('hidden');
    I.OVL.setAttribute('aria-hidden','false');
    liveOn = true;
    startSensors();
    updateOverlayFromInputs();  // init with current inputs immediately
  }
  function closeOverlay(){
    document.documentElement.classList.remove('no-scroll'); document.body.classList.remove('no-scroll');
    liveOn = false;
    stopSensors();
    if(I.OVL){
      I.OVL.classList.add('hidden');
      I.OVL.setAttribute('aria-hidden','true');
    }
  }

  I.LIVE_OPEN?.addEventListener('click', openOverlay);
  I.OVL_CLOSE?.addEventListener('click', closeOverlay);

  // device orientation
  let onDO = null;
  function startSensors(){
    const go = ()=>{
      if(onDO) window.removeEventListener('deviceorientation', onDO);
      onDO = (ev)=>{
        if(!liveOn) return;
        let hdg = NaN;
        if(typeof ev.webkitCompassHeading === 'number') {
          hdg = ev.webkitCompassHeading; // iOS Safari
        } else if (typeof ev.alpha === 'number') {
          // fallback: try to convert alpha to compass-ish heading
          hdg = 360 - ev.alpha; // crude but workable in many cases
        }
        if(Number.isFinite(hdg)){
          hdg = norm360(hdg);
          I.OVL_HDG && (I.OVL_HDG.textContent = Math.round(hdg) + '°');
          // Also mirror into the HDG input so panel stays synced
          if(I.HDG) { I.HDG.value = String(Math.round(hdg)); }
          // update the overlay visuals
          updateOverlay(hdg);
        }
      };
      window.addEventListener('deviceorientation', onDO, { capture:false, passive:true });
      sensorActive = true;
    };

    // iOS permission dance
    try{
      if(window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function'){
        DeviceOrientationEvent.requestPermission().then(resp=>{
          if(resp === 'granted') go();
          else { sensorActive = false; updateOverlayFromInputs(); }
        }).catch(()=>{ sensorActive = false; updateOverlayFromInputs(); });
      } else {
        go(); // non-iOS or no permission model
      }
    } catch {
      sensorActive = false; updateOverlayFromInputs();
    }
  }
  function stopSensors(){
    if(onDO){
      window.removeEventListener('deviceorientation', onDO);
      onDO = null;
    }
    sensorActive = false;
  }

  // compute + paint overlay from current inputs (and optional heading)
  function updateOverlay(hdgOverride){
    if(!I.OVL) return;

    const gsDirect = num(I.GS?.value);
    const ias = num(I.IAS?.value);
    const wf  = num(I.WF?.value);
    const w   = num(I.W?.value);
    const gmsl= num(I.GMSL?.value);

    // heading: sensor if provided, else fall back to input
    const hdg = Number.isFinite(hdgOverride) ? hdgOverride : num(I.HDG?.value);

    // core pieces
    const wc = computeWC(hdg, wf, w);
    const gsCalc = computeGSCalc(ias, wc);
    const gsUsed = computeGSUsed(gsDirect, gsCalc);
    const paAGL = pivAltFt(gsUsed);
    const paMSL = (Number.isFinite(paAGL) && Number.isFinite(gmsl)) ? (paAGL + gmsl) : NaN;

    // min/max (AGL, MSL)
    const [minAGL, maxAGL] = computeMinMaxAGL(ias, w, gsDirect, wc);
    const minMSL = (Number.isFinite(minAGL) && Number.isFinite(gmsl)) ? (minAGL + gmsl) : NaN;
    const maxMSL = (Number.isFinite(maxAGL) && Number.isFinite(gmsl)) ? (maxAGL + gmsl) : NaN;

    // paint labels
    setNum('#PA_LIVE_MIN_AGL', minAGL, 'ft');
    setNum('#PA_LIVE_MAX_AGL', maxAGL, 'ft');
    setText('#PA_LIVE_MIN_MSL', Number.isFinite(minMSL) ? `(${Math.round(minMSL).toLocaleString()} ft MSL)` : '(— ft MSL)');
    setText('#PA_LIVE_MAX_MSL', Number.isFinite(maxMSL) ? `(${Math.round(maxMSL).toLocaleString()} ft MSL)` : '(— ft MSL)');
    setText('#PA_LIVE_AGL', Number.isFinite(paAGL) ? `${Math.round(paAGL).toLocaleString()} ft` : '— ft');
    setText('#PA_LIVE_MSL', Number.isFinite(paMSL) ? `${Math.round(paMSL).toLocaleString()} ft MSL` : '— ft MSL');

    // move marker
    if(I.OVL_LINE && I.OVL_MARK && Number.isFinite(minAGL) && Number.isFinite(maxAGL) && Number.isFinite(paAGL) && (maxAGL - minAGL) > 0.5){
      const h = I.OVL_LINE.clientHeight || 400;
      let t = (paAGL - minAGL) / (maxAGL - minAGL); // 0..1
      if (t < 0) t = 0; if (t > 1) t = 1;
      const y = (1 - t) * h;
      I.OVL_MARK.style.top = `${Math.round(y - 2)}px`;
      I.OVL_MARK.style.display = 'block';
    } else if (I.OVL_MARK) {
      I.OVL_MARK.style.display = 'none';
    }
  }

  // re-paint overlay (no new heading)
  function updateOverlayFromInputs(){ if(!liveOn) return; updateOverlay(); }

  // boot
  function init(){
    recalc();
    updateLiveButton();
  }

  init();
})();
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script>
(function(){
  const btn = document.getElementById("savePerf");
  if(!btn) return;

  const UA = navigator.userAgent || "";
  const isIOS = /iPhone|iPad|iPod/i.test(UA) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
  const isAndroid = /Android/i.test(UA);
  const isMobile = isIOS || isAndroid;

  function prunePerfOutput(root){
    root.querySelectorAll(".kv").forEach(kv=>{
      if ((kv.textContent||"").trim().includes("—")) kv.remove();
    });
    root.querySelectorAll(".note, .warn").forEach(n => n.remove());
    root.querySelectorAll(".box").forEach(b=>{ if(!b.querySelector(".kv")) b.remove(); });
    root.querySelectorAll(".io").forEach(io=>{ if(!io.querySelector(".box")) io.remove(); });
    root.querySelectorAll("h4").forEach(h=>{
      const next = h.nextElementSibling;
      if(!next || (!next.querySelector(".kv") && !next.matches(".io,.box"))) h.remove();
    });
  }

  btn.addEventListener("click", async function () {
    const src = document.querySelector("#panel-c172-perf .perf-output"); /* where we export from */
    if(!src) return;

    // Clone + prune to only filled outputs
    const clone = src.cloneNode(true);
    prunePerfOutput(clone);
    if(!clone.querySelector(".kv")){
      alert("No results to export yet.");
      return;
    }

    // Mark the clone so we can scope tight capture CSS
    clone.setAttribute("data-capture", "1");

    // Off-screen stage + scoped CSS to shrink-wrap width
    const stage = document.createElement("div");
    stage.style.position = "fixed";
    stage.style.left = "-9999px";
    stage.style.top = "0";
    stage.style.display = "inline-block";      // shrink-wrap container
    stage.style.background = "transparent";

    const style = document.createElement("style");
    style.textContent = `
      [data-capture]{
        background:#f0f2f5 !important;
        border-radius:14px;
        padding:12px !important;
        display:inline-block !important;
        width:max-content !important;
        max-width:unset !important;
        border:none !important;
        box-shadow:none !important;
      }
      [data-capture] .io{ display:block !important; }
      [data-capture] .box{ width:auto !important; }
      [data-capture] .kv{ white-space:normal !important; }

      /* NEW: keep top/bottom spacing perfectly even */
      [data-capture] > *:first-child{ margin-top:0 !important; }
      [data-capture] > *:last-child{  margin-bottom:0 !important; }
      [data-capture] h4:first-of-type{ margin-top:0 !important; }
    `;

    stage.appendChild(style);
    stage.appendChild(clone);
    document.body.appendChild(stage);

    try {
      const canvas = await html2canvas(clone, {
        scale: 2,
        useCORS: true,
        backgroundColor: null     // keep outside transparent
      });

      stage.remove();

      canvas.toBlob(async (blob)=>{
        const fileName = "c172-performance.png";

        if(!blob){
          const dataUrl = canvas.toDataURL("image/png");
          if(isMobile){ window.open(dataUrl, "_blank"); }
          else{
            const a = document.createElement("a");
            a.download = fileName; a.href = dataUrl; a.click();
          }
          return;
        }

        const file = new File([blob], fileName, { type: "image/png" });

        // Mobile → Share Sheet (Save Image available)
        if (isMobile && navigator.canShare && navigator.canShare({ files: [file] })) {
          try {
            await navigator.share({ files:[file], title:"C172 Performance Snapshot" });
            return;
          } catch(e){ /* fall through */ }
        }

        // Desktop → direct download
        if (!isMobile) {
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url; a.download = fileName;
          document.body.appendChild(a); a.click(); a.remove();
          setTimeout(()=>URL.revokeObjectURL(url), 1000);
          return;
        }

        // Older mobile fallback
        const url = URL.createObjectURL(blob);
        window.open(url, "_blank");
        setTimeout(()=>URL.revokeObjectURL(url), 10000);
      }, "image/png", 1.0);

    } catch (err) {
      try { stage.remove(); } catch(_){}
      console.error(err);
      alert("Could not render image—try again after results populate.");
    }
  });
})();
</script>

<script>
(function(){
  const grid   = document.getElementById('tiles');
  const LS_KEY = 'tileOrder';

  // ---------- Persist order ----------
  function saveOrder(){
    const order = [...grid.querySelectorAll('.tile')].map(t => t.dataset.panel);
    localStorage.setItem(LS_KEY, JSON.stringify(order));
  }
  function loadOrder(){
    const order = JSON.parse(localStorage.getItem(LS_KEY) || '[]');
    if(!order.length) return;
    const map = Object.fromEntries([...grid.children].map(t => [t.dataset.panel, t]));
    order.forEach(p => map[p] && grid.appendChild(map[p]));
  }

  // ---------- Moves ----------
  function moveUp(el){
    const prev = el.previousElementSibling;
    if(prev) grid.insertBefore(el, prev);
    saveOrder();
  }
  function moveDown(el){
    const next = el.nextElementSibling;
    if(next) grid.insertBefore(next, el);
    saveOrder();
  }
  function moveTop(el){
    grid.insertBefore(el, grid.firstElementChild);
    saveOrder();
  }
  function moveBottom(el){
    grid.appendChild(el);
    saveOrder();
  }

  // ---------- Menu helpers ----------
  function closeAllMenus(except){
    grid.querySelectorAll('.tile.menu-open').forEach(t=>{
      if(t !== except){
        t.classList.remove('menu-open');
        const b = t.querySelector('.tile-menu-btn');
        if(b) b.setAttribute('aria-expanded','false');
      }
    });
  }

  function enhanceTile(tile){
    if (tile.dataset.enhanced) return;
    tile.dataset.enhanced = "1";

    // Wrap header (reuse existing h3/p)
    const h3 = tile.querySelector('h3');
    const p  = tile.querySelector('p');

    const head = document.createElement('div');
    head.className = 'tile-head';

    const wrap = document.createElement('div');
    wrap.className = 'title-wrap';
    if (h3) wrap.appendChild(h3);
    if (p)  wrap.appendChild(p);

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'tile-menu-btn';
    btn.setAttribute('aria-label','Tile options');
    btn.setAttribute('aria-expanded','false');
    btn.textContent = '⋮'; // vertical dots

    head.appendChild(wrap);
    tile.prepend(head);
    tile.appendChild(btn); // position is absolute, so append is fine

    // Footer actions (bottom of tile)
    const footer = document.createElement('div');
    footer.className = 'tile-footer';
    footer.innerHTML = `
      <button class="btn flat" data-move="up">Move Up</button>
      <button class="btn flat" data-move="down">Move Down</button>
      <button class="btn flat" data-move="top">Top</button>
      <button class="btn flat" data-move="bottom">Bottom</button>
    `;
    tile.appendChild(footer);

    // Toggle menu
    btn.addEventListener('click', (e)=>{
      e.stopPropagation();
      e.preventDefault();
      const open = tile.classList.toggle('menu-open');
      btn.setAttribute('aria-expanded', open ? 'true' : 'false');
      if (open) closeAllMenus(tile);
    });

    // Actions: perform move, then CLOSE the menu
    footer.addEventListener('click', (e)=>{
      const b = e.target.closest('[data-move]');
      if(!b) return;
      e.stopPropagation();
      e.preventDefault();
      const kind = b.dataset.move;
      if (kind === 'up') moveUp(tile);
      else if (kind === 'down') moveDown(tile);
      else if (kind === 'top') moveTop(tile);
      else if (kind === 'bottom') moveBottom(tile);
      // dismiss menu after action
      tile.classList.remove('menu-open');
      btn.setAttribute('aria-expanded','false');
    });
  }

  function enhanceAll(){
    grid.querySelectorAll('.tile').forEach(enhanceTile);
  }

  // Block tile open while menu is open (capture)
  grid.addEventListener('click', (e)=>{
    const t = e.target.closest('.tile');
    if (!t) return;
    if (t.classList.contains('menu-open')){
      const ok = e.target.closest('.tile-menu-btn, .tile-footer');
      if (!ok){ e.stopPropagation(); e.preventDefault(); }
    }
  }, true);

  // Outside click or Esc closes menus
  document.addEventListener('click', (e)=>{
    if (!grid.contains(e.target)) closeAllMenus();
  });
  document.addEventListener('keydown', (e)=>{
    if (e.key === 'Escape') closeAllMenus();
  });

  // Init
  loadOrder();
  enhanceAll();
})();
</script>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const tzMode = document.getElementById("to_tzmode");
  const anchorWrap = document.getElementById("to_anchor_wrap");

  function attachZuluFormatter(inputEl) {
    if (!inputEl) return;
    inputEl.addEventListener("input", (e) => {
      let val = e.target.value.replace(/\D/g, ""); // keep digits only
      if (val.length > 2) {
        val = val.slice(0, 2) + ":" + val.slice(2, 4);
      }
      e.target.value = val;
    });
  }

  // Watch for mode changes
  tzMode.addEventListener("change", () => {
    if (tzMode.value === "zulu") {
      // give the injection a moment to render
      setTimeout(() => {
        const zuluInput = anchorWrap.querySelector("input");
        attachZuluFormatter(zuluInput);
      }, 0);
    }
  });

  // Also attach if page loads already in Zulu mode
  if (tzMode.value === "zulu") {
    setTimeout(() => {
      const zuluInput = anchorWrap.querySelector("input");
      attachZuluFormatter(zuluInput);
    }, 0);
  }
});
</script>
</body>
</html>
